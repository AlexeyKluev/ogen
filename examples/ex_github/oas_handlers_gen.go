// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
)

func NewActionsAddRepoAccessToSelfHostedRunnerGroupInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/add-repo-access-to-self-hosted-runner-group-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsAddSelectedRepoToOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsAddSelectedRepoToOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/add-selected-repo-to-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsAddSelectedRepoToOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsAddSelectedRepoToOrgSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsAddSelfHostedRunnerToGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsAddSelfHostedRunnerToGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/add-self-hosted-runner-to-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsApproveWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsApproveWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/approve-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsApproveWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsApproveWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCancelWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCancelWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/cancel-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCancelWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCancelWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateOrUpdateEnvironmentSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateEnvironmentSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-environment-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsCreateOrUpdateEnvironmentSecretRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateOrUpdateOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateOrUpdateOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsCreateOrUpdateOrgSecretRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateOrUpdateRepoSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateRepoSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-repo-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateOrUpdateRepoSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsCreateOrUpdateRepoSecretRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateRegistrationTokenForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateRegistrationTokenForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-registration-token-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateRegistrationTokenForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateRegistrationTokenForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateRegistrationTokenForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateRegistrationTokenForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-registration-token-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateRegistrationTokenForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateRegistrationTokenForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateRemoveTokenForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateRemoveTokenForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-remove-token-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateRemoveTokenForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateRemoveTokenForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateRemoveTokenForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateRemoveTokenForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-remove-token-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateRemoveTokenForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateRemoveTokenForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsCreateSelfHostedRunnerGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsCreateSelfHostedRunnerGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/create-self-hosted-runner-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteArtifactHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteArtifact`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-artifact`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteArtifactParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteArtifact(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteEnvironmentSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteEnvironmentSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-environment-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteEnvironmentSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteEnvironmentSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteOrgSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteRepoSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteRepoSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-repo-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteRepoSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteRepoSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteSelfHostedRunnerFromOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerFromOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-from-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteSelfHostedRunnerFromRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerFromRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-from-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteSelfHostedRunnerGroupFromOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerGroupFromOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-group-from-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDeleteWorkflowRunLogsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDeleteWorkflowRunLogs`,
			trace.WithAttributes(otelogen.OperationID(`actions/delete-workflow-run-logs`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDeleteWorkflowRunLogsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDeleteWorkflowRunLogs(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDisableSelectedRepositoryGithubActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDisableSelectedRepositoryGithubActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/disable-selected-repository-github-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDownloadArtifactHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDownloadArtifact`,
			trace.WithAttributes(otelogen.OperationID(`actions/download-artifact`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDownloadArtifactParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDownloadArtifact(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDownloadJobLogsForWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDownloadJobLogsForWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/download-job-logs-for-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsDownloadWorkflowRunLogsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsDownloadWorkflowRunLogs`,
			trace.WithAttributes(otelogen.OperationID(`actions/download-workflow-run-logs`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsDownloadWorkflowRunLogsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsDownloadWorkflowRunLogs(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsEnableSelectedRepositoryGithubActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsEnableSelectedRepositoryGithubActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/enable-selected-repository-github-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetAllowedActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetAllowedActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-allowed-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetAllowedActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetAllowedActionsOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetAllowedActionsRepositoryHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetAllowedActionsRepository`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-allowed-actions-repository`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetAllowedActionsRepositoryParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetAllowedActionsRepository(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetArtifactHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetArtifact`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-artifact`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetArtifactParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetArtifact(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetEnvironmentPublicKeyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetEnvironmentPublicKey`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-environment-public-key`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetEnvironmentPublicKeyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetEnvironmentPublicKey(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetEnvironmentSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetEnvironmentSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-environment-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetEnvironmentSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetEnvironmentSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetGithubActionsPermissionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetGithubActionsPermissionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-github-actions-permissions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetGithubActionsPermissionsRepositoryHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetGithubActionsPermissionsRepository`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-github-actions-permissions-repository`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetGithubActionsPermissionsRepository(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetJobForWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetJobForWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-job-for-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetJobForWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetJobForWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetOrgPublicKeyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetOrgPublicKey`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-org-public-key`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetOrgPublicKeyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetOrgPublicKey(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetOrgSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetRepoPublicKeyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetRepoPublicKey`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-repo-public-key`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetRepoPublicKeyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetRepoPublicKey(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetRepoSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetRepoSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-repo-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetRepoSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetRepoSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetReviewsForRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetReviewsForRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-reviews-for-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetReviewsForRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetReviewsForRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetSelfHostedRunnerForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetSelfHostedRunnerForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetSelfHostedRunnerForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetSelfHostedRunnerForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetSelfHostedRunnerForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetSelfHostedRunnerForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetSelfHostedRunnerGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsGetWorkflowRunUsageHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsGetWorkflowRunUsage`,
			trace.WithAttributes(otelogen.OperationID(`actions/get-workflow-run-usage`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsGetWorkflowRunUsageParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsGetWorkflowRunUsage(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListArtifactsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListArtifactsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-artifacts-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListArtifactsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListArtifactsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListEnvironmentSecretsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListEnvironmentSecrets`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-environment-secrets`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListEnvironmentSecretsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListEnvironmentSecrets(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListJobsForWorkflowRunHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListJobsForWorkflowRun`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-jobs-for-workflow-run`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListJobsForWorkflowRunParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListJobsForWorkflowRun(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListOrgSecretsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListOrgSecrets`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-org-secrets`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListOrgSecretsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListOrgSecrets(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListRepoAccessToSelfHostedRunnerGroupInOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-repo-access-to-self-hosted-runner-group-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListRepoSecretsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListRepoSecrets`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-repo-secrets`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListRepoSecretsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListRepoSecrets(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListRepoWorkflowsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListRepoWorkflows`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-repo-workflows`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListRepoWorkflowsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListRepoWorkflows(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListRunnerApplicationsForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListRunnerApplicationsForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-runner-applications-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListRunnerApplicationsForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListRunnerApplicationsForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListRunnerApplicationsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListRunnerApplicationsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-runner-applications-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListRunnerApplicationsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListRunnerApplicationsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelectedReposForOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelectedReposForOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-selected-repos-for-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelectedReposForOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelectedReposForOrgSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelectedRepositoriesEnabledGithubActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-selected-repositories-enabled-github-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelfHostedRunnerGroupsForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnerGroupsForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runner-groups-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelfHostedRunnersForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelfHostedRunnersForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelfHostedRunnersForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelfHostedRunnersForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelfHostedRunnersForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelfHostedRunnersForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListSelfHostedRunnersInGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersInGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-in-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListWorkflowRunArtifactsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListWorkflowRunArtifacts`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-workflow-run-artifacts`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListWorkflowRunArtifactsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListWorkflowRunArtifacts(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsListWorkflowRunsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsListWorkflowRunsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`actions/list-workflow-runs-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsListWorkflowRunsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsListWorkflowRunsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsReRunWorkflowHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsReRunWorkflow`,
			trace.WithAttributes(otelogen.OperationID(`actions/re-run-workflow`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsReRunWorkflowParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsReRunWorkflow(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/remove-repo-access-to-self-hosted-runner-group-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsRemoveSelectedRepoFromOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsRemoveSelectedRepoFromOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/remove-selected-repo-from-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsRemoveSelfHostedRunnerFromGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsRemoveSelfHostedRunnerFromGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/remove-self-hosted-runner-from-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsRetryWorkflowHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsRetryWorkflow`,
			trace.WithAttributes(otelogen.OperationID(`actions/retry-workflow`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsRetryWorkflowParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsRetryWorkflow(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetAllowedActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetAllowedActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-allowed-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetAllowedActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetAllowedActionsOrganizationRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetAllowedActionsOrganization(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetAllowedActionsRepositoryHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetAllowedActionsRepository`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-allowed-actions-repository`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetAllowedActionsRepositoryParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetAllowedActionsRepositoryRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetAllowedActionsRepository(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetGithubActionsPermissionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetGithubActionsPermissionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-github-actions-permissions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetGithubActionsPermissionsOrganizationRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetGithubActionsPermissionsRepositoryHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetGithubActionsPermissionsRepository`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-github-actions-permissions-repository`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetGithubActionsPermissionsRepositoryRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-repo-access-to-self-hosted-runner-group-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetSelectedReposForOrgSecretHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetSelectedReposForOrgSecret`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-selected-repos-for-org-secret`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetSelectedReposForOrgSecretParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetSelectedReposForOrgSecretRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-selected-repositories-enabled-github-actions-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsSetSelfHostedRunnersInGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsSetSelfHostedRunnersInGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/set-self-hosted-runners-in-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActionsUpdateSelfHostedRunnerGroupForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActionsUpdateSelfHostedRunnerGroupForOrg`,
			trace.WithAttributes(otelogen.OperationID(`actions/update-self-hosted-runner-group-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityCheckRepoIsStarredByAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityCheckRepoIsStarredByAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/check-repo-is-starred-by-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityDeleteRepoSubscriptionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityDeleteRepoSubscription`,
			trace.WithAttributes(otelogen.OperationID(`activity/delete-repo-subscription`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityDeleteRepoSubscriptionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityDeleteRepoSubscription(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityDeleteThreadSubscriptionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityDeleteThreadSubscription`,
			trace.WithAttributes(otelogen.OperationID(`activity/delete-thread-subscription`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityDeleteThreadSubscriptionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityDeleteThreadSubscription(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityGetFeedsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityGetFeeds`,
			trace.WithAttributes(otelogen.OperationID(`activity/get-feeds`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.ActivityGetFeeds(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityGetRepoSubscriptionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityGetRepoSubscription`,
			trace.WithAttributes(otelogen.OperationID(`activity/get-repo-subscription`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityGetRepoSubscriptionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityGetRepoSubscription(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityGetThreadHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityGetThread`,
			trace.WithAttributes(otelogen.OperationID(`activity/get-thread`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityGetThreadParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityGetThread(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityGetThreadSubscriptionForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityGetThreadSubscriptionForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/get-thread-subscription-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListEventsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListEventsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-events-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListEventsForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListEventsForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListOrgEventsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListOrgEventsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-org-events-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListPublicEventsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListPublicEvents`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-public-events`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.ActivityListPublicEvents(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListPublicEventsForRepoNetworkHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListPublicEventsForRepoNetwork`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-public-events-for-repo-network`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListPublicEventsForRepoNetworkParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListPublicEventsForRepoNetwork(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListPublicEventsForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListPublicEventsForUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-public-events-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListPublicEventsForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListPublicEventsForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListPublicOrgEventsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListPublicOrgEvents`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-public-org-events`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListPublicOrgEventsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListPublicOrgEvents(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListReceivedEventsForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListReceivedEventsForUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-received-events-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListReceivedEventsForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListReceivedEventsForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListReceivedPublicEventsForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListReceivedPublicEventsForUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-received-public-events-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListReceivedPublicEventsForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListReceivedPublicEventsForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListRepoEventsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListRepoEvents`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-repo-events`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListRepoEventsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListRepoEvents(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListRepoNotificationsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListRepoNotificationsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-repo-notifications-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListReposStarredByAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListReposStarredByAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-repos-starred-by-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.ActivityListReposStarredByAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListReposWatchedByUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListReposWatchedByUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-repos-watched-by-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListReposWatchedByUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListReposWatchedByUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListWatchedReposForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListWatchedReposForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-watched-repos-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.ActivityListWatchedReposForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityListWatchersForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityListWatchersForRepo`,
			trace.WithAttributes(otelogen.OperationID(`activity/list-watchers-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityListWatchersForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityListWatchersForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityMarkNotificationsAsReadHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityMarkNotificationsAsRead`,
			trace.WithAttributes(otelogen.OperationID(`activity/mark-notifications-as-read`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		request, err := decodeActivityMarkNotificationsAsReadRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityMarkNotificationsAsRead(ctx, request)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityMarkRepoNotificationsAsReadHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityMarkRepoNotificationsAsRead`,
			trace.WithAttributes(otelogen.OperationID(`activity/mark-repo-notifications-as-read`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityMarkRepoNotificationsAsReadParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActivityMarkRepoNotificationsAsReadRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityMarkThreadAsReadHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityMarkThreadAsRead`,
			trace.WithAttributes(otelogen.OperationID(`activity/mark-thread-as-read`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityMarkThreadAsReadParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityMarkThreadAsRead(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivitySetRepoSubscriptionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivitySetRepoSubscription`,
			trace.WithAttributes(otelogen.OperationID(`activity/set-repo-subscription`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivitySetRepoSubscriptionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActivitySetRepoSubscriptionRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivitySetRepoSubscription(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivitySetThreadSubscriptionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivitySetThreadSubscription`,
			trace.WithAttributes(otelogen.OperationID(`activity/set-thread-subscription`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivitySetThreadSubscriptionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeActivitySetThreadSubscriptionRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivitySetThreadSubscription(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityStarRepoForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityStarRepoForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/star-repo-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityStarRepoForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityStarRepoForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewActivityUnstarRepoForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ActivityUnstarRepoForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`activity/unstar-repo-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsAddRepoToInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsAddRepoToInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/add-repo-to-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsAddRepoToInstallationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsAddRepoToInstallation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsDeleteInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsDeleteInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/delete-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsDeleteInstallationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsDeleteInstallation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsGetAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsGetAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`apps/get-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsGetAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsGetBySlugHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsGetBySlug`,
			trace.WithAttributes(otelogen.OperationID(`apps/get-by-slug`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsGetBySlugParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsGetBySlug(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsGetSubscriptionPlanForAccountHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsGetSubscriptionPlanForAccount`,
			trace.WithAttributes(otelogen.OperationID(`apps/get-subscription-plan-for-account`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsGetSubscriptionPlanForAccountParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsGetSubscriptionPlanForAccount(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsGetSubscriptionPlanForAccountStubbedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsGetSubscriptionPlanForAccountStubbed`,
			trace.WithAttributes(otelogen.OperationID(`apps/get-subscription-plan-for-account-stubbed`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsGetWebhookConfigForAppHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsGetWebhookConfigForApp`,
			trace.WithAttributes(otelogen.OperationID(`apps/get-webhook-config-for-app`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsGetWebhookConfigForApp(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListAccountsForPlanStubbedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListAccountsForPlanStubbed`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-accounts-for-plan-stubbed`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsListAccountsForPlanStubbedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsListAccountsForPlanStubbed(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListInstallationReposForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListInstallationReposForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-installation-repos-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsListInstallationReposForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListPlansHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListPlans`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-plans`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsListPlans(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListPlansResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListPlansStubbedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListPlansStubbed`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-plans-stubbed`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsListPlansStubbed(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListReposAccessibleToInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListReposAccessibleToInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-repos-accessible-to-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsListReposAccessibleToInstallation(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListSubscriptionsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListSubscriptionsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-subscriptions-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsListSubscriptionsForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsListSubscriptionsForAuthenticatedUserStubbedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsListSubscriptionsForAuthenticatedUserStubbed`,
			trace.WithAttributes(otelogen.OperationID(`apps/list-subscriptions-for-authenticated-user-stubbed`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsRemoveRepoFromInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsRemoveRepoFromInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/remove-repo-from-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsRemoveRepoFromInstallationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsRemoveRepoFromInstallation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsRevokeInstallationAccessTokenHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsRevokeInstallationAccessToken`,
			trace.WithAttributes(otelogen.OperationID(`apps/revoke-installation-access-token`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.AppsRevokeInstallationAccessToken(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsSuspendInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsSuspendInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/suspend-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsSuspendInstallationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsSuspendInstallation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsUnsuspendInstallationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsUnsuspendInstallation`,
			trace.WithAttributes(otelogen.OperationID(`apps/unsuspend-installation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeAppsUnsuspendInstallationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsUnsuspendInstallation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewAppsUpdateWebhookConfigForAppHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `AppsUpdateWebhookConfigForApp`,
			trace.WithAttributes(otelogen.OperationID(`apps/update-webhook-config-for-app`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		request, err := decodeAppsUpdateWebhookConfigForAppRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.AppsUpdateWebhookConfigForApp(ctx, request)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubActionsBillingGheHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingGhe`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-ghe`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubActionsBillingGheParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubActionsBillingGhe(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubActionsBillingOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingOrg`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubActionsBillingOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubActionsBillingOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubActionsBillingUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingUser`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubActionsBillingUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubActionsBillingUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubPackagesBillingGheHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingGhe`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-ghe`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubPackagesBillingGheParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubPackagesBillingGhe(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubPackagesBillingOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingOrg`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubPackagesBillingOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubPackagesBillingOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetGithubPackagesBillingUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingUser`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetGithubPackagesBillingUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetGithubPackagesBillingUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetSharedStorageBillingGheHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingGhe`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-ghe`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetSharedStorageBillingGheParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetSharedStorageBillingGhe(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetSharedStorageBillingOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingOrg`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetSharedStorageBillingOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetSharedStorageBillingOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewBillingGetSharedStorageBillingUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingUser`,
			trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeBillingGetSharedStorageBillingUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.BillingGetSharedStorageBillingUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksCreateSuiteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksCreateSuite`,
			trace.WithAttributes(otelogen.OperationID(`checks/create-suite`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksCreateSuiteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeChecksCreateSuiteRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksCreateSuite(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksGet`,
			trace.WithAttributes(otelogen.OperationID(`checks/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksGetSuiteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksGetSuite`,
			trace.WithAttributes(otelogen.OperationID(`checks/get-suite`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksGetSuiteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksGetSuite(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksListAnnotationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksListAnnotations`,
			trace.WithAttributes(otelogen.OperationID(`checks/list-annotations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksListAnnotationsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksListAnnotations(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksListForRefHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksListForRef`,
			trace.WithAttributes(otelogen.OperationID(`checks/list-for-ref`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksListForRefParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksListForRef(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksListForRefResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksListForSuiteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksListForSuite`,
			trace.WithAttributes(otelogen.OperationID(`checks/list-for-suite`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksListForSuiteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksListForSuite(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksListSuitesForRefHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksListSuitesForRef`,
			trace.WithAttributes(otelogen.OperationID(`checks/list-suites-for-ref`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksListSuitesForRefParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksListSuitesForRef(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksRerequestSuiteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksRerequestSuite`,
			trace.WithAttributes(otelogen.OperationID(`checks/rerequest-suite`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksRerequestSuiteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksRerequestSuite(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewChecksSetSuitesPreferencesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ChecksSetSuitesPreferences`,
			trace.WithAttributes(otelogen.OperationID(`checks/set-suites-preferences`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeChecksSetSuitesPreferencesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeChecksSetSuitesPreferencesRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ChecksSetSuitesPreferences(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningDeleteAnalysisHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningDeleteAnalysis`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/delete-analysis`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningDeleteAnalysisParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningDeleteAnalysis(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningGetAlertHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningGetAlert`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/get-alert`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningGetAlertParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningGetAlert(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningGetAnalysisHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningGetAnalysis`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/get-analysis`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningGetAnalysisParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningGetAnalysis(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningGetSarifHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningGetSarif`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/get-sarif`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningGetSarifParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningGetSarif(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningListAlertInstancesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningListAlertInstances`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/list-alert-instances`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningListAlertInstancesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningListAlertInstances(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningListAlertsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningListAlertsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/list-alerts-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningListAlertsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningListAlertsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningListRecentAnalysesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningListRecentAnalyses`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/list-recent-analyses`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningListRecentAnalysesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningListRecentAnalyses(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningUpdateAlertHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningUpdateAlert`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/update-alert`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningUpdateAlertParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeCodeScanningUpdateAlertRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningUpdateAlert(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodeScanningUploadSarifHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodeScanningUploadSarif`,
			trace.WithAttributes(otelogen.OperationID(`code-scanning/upload-sarif`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodeScanningUploadSarifParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeCodeScanningUploadSarifRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodeScanningUploadSarif(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodesOfConductGetAllCodesOfConductHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodesOfConductGetAllCodesOfConduct`,
			trace.WithAttributes(otelogen.OperationID(`codes-of-conduct/get-all-codes-of-conduct`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.CodesOfConductGetAllCodesOfConduct(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewCodesOfConductGetConductCodeHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `CodesOfConductGetConductCode`,
			trace.WithAttributes(otelogen.OperationID(`codes-of-conduct/get-conduct-code`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeCodesOfConductGetConductCodeParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.CodesOfConductGetConductCode(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEmojisGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EmojisGet`,
			trace.WithAttributes(otelogen.OperationID(`emojis/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.EmojisGet(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEmojisGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/add-self-hosted-runner-to-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminCreateRegistrationTokenForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateRegistrationTokenForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-registration-token-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminCreateRemoveTokenForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateRemoveTokenForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-remove-token-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-self-hosted-runner-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminDeleteScimGroupFromEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteScimGroupFromEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-scim-group-from-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-self-hosted-runner-from-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-self-hosted-runner-group-from-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminDeleteUserFromEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteUserFromEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-user-from-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/disable-selected-organization-github-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/enable-selected-organization-github-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetAllowedActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetAllowedActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-allowed-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetAuditLogHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetAuditLog`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-audit-log`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetAuditLogParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetAuditLog(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetGithubActionsPermissionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-github-actions-permissions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetProvisioningInformationForEnterpriseGroupHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetProvisioningInformationForEnterpriseGroup`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-provisioning-information-for-enterprise-group`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetProvisioningInformationForEnterpriseUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetProvisioningInformationForEnterpriseUser`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-provisioning-information-for-enterprise-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetSelfHostedRunnerForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-self-hosted-runner-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-self-hosted-runner-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListProvisionedGroupsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListProvisionedGroupsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-provisioned-groups-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListProvisionedIdentitiesEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListProvisionedIdentitiesEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-provisioned-identities-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListRunnerApplicationsForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListRunnerApplicationsForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-runner-applications-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runner-groups-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListSelfHostedRunnersForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnersForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runners-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runners-in-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminProvisionAndInviteEnterpriseGroupHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminProvisionAndInviteEnterpriseGroup`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/provision-and-invite-enterprise-group`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminProvisionAndInviteEnterpriseUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminProvisionAndInviteEnterpriseUser`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/provision-and-invite-enterprise-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetAllowedActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetAllowedActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-allowed-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetGithubActionsPermissionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-github-actions-permissions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetInformationForProvisionedEnterpriseGroupHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetInformationForProvisionedEnterpriseGroup`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-information-for-provisioned-enterprise-group`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetInformationForProvisionedEnterpriseUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetInformationForProvisionedEnterpriseUser`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-information-for-provisioned-enterprise-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-self-hosted-runners-in-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminUpdateAttributeForEnterpriseUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminUpdateAttributeForEnterpriseUser`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/update-attribute-for-enterprise-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise`,
			trace.WithAttributes(otelogen.OperationID(`enterprise-admin/update-self-hosted-runner-group-for-enterprise`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsCheckIsStarredHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsCheckIsStarred`,
			trace.WithAttributes(otelogen.OperationID(`gists/check-is-starred`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsCheckIsStarredParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsCheckIsStarred(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsCreateCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsCreateComment`,
			trace.WithAttributes(otelogen.OperationID(`gists/create-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsCreateCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeGistsCreateCommentRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsCreateComment(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsDeleteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsDelete`,
			trace.WithAttributes(otelogen.OperationID(`gists/delete`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsDeleteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsDelete(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsDeleteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsDeleteCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsDeleteComment`,
			trace.WithAttributes(otelogen.OperationID(`gists/delete-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsDeleteCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsDeleteComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsGet`,
			trace.WithAttributes(otelogen.OperationID(`gists/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsGetCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsGetComment`,
			trace.WithAttributes(otelogen.OperationID(`gists/get-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsGetCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsGetComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsListHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsList`,
			trace.WithAttributes(otelogen.OperationID(`gists/list`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.GistsList(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsListResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsListCommentsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsListComments`,
			trace.WithAttributes(otelogen.OperationID(`gists/list-comments`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsListCommentsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsListComments(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsListCommitsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsListCommits`,
			trace.WithAttributes(otelogen.OperationID(`gists/list-commits`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsListCommitsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsListCommits(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsListForksHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsListForks`,
			trace.WithAttributes(otelogen.OperationID(`gists/list-forks`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsListForksParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsListForks(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsListForksResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsListStarredHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsListStarred`,
			trace.WithAttributes(otelogen.OperationID(`gists/list-starred`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.GistsListStarred(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsListStarredResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsStarHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsStar`,
			trace.WithAttributes(otelogen.OperationID(`gists/star`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsStarParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsStar(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsStarResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsUnstarHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsUnstar`,
			trace.WithAttributes(otelogen.OperationID(`gists/unstar`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsUnstarParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsUnstar(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsUnstarResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGistsUpdateCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GistsUpdateComment`,
			trace.WithAttributes(otelogen.OperationID(`gists/update-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGistsUpdateCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeGistsUpdateCommentRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GistsUpdateComment(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitGetCommitHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitGetCommit`,
			trace.WithAttributes(otelogen.OperationID(`git/get-commit`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGitGetCommitParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GitGetCommit(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitGetCommitResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitGetRefHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitGetRef`,
			trace.WithAttributes(otelogen.OperationID(`git/get-ref`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGitGetRefParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GitGetRef(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitGetRefResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitGetTagHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitGetTag`,
			trace.WithAttributes(otelogen.OperationID(`git/get-tag`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGitGetTagParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GitGetTag(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitGetTagResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitListMatchingRefsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitListMatchingRefs`,
			trace.WithAttributes(otelogen.OperationID(`git/list-matching-refs`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGitListMatchingRefsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GitListMatchingRefs(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitignoreGetAllTemplatesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitignoreGetAllTemplates`,
			trace.WithAttributes(otelogen.OperationID(`gitignore/get-all-templates`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.GitignoreGetAllTemplates(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewGitignoreGetTemplateHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `GitignoreGetTemplate`,
			trace.WithAttributes(otelogen.OperationID(`gitignore/get-template`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeGitignoreGetTemplateParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.GitignoreGetTemplate(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewInteractionsRemoveRestrictionsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewInteractionsRemoveRestrictionsForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForOrg`,
			trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeInteractionsRemoveRestrictionsForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.InteractionsRemoveRestrictionsForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewInteractionsRemoveRestrictionsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeInteractionsRemoveRestrictionsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.InteractionsRemoveRestrictionsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewInteractionsSetRestrictionsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `InteractionsSetRestrictionsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`interactions/set-restrictions-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeInteractionsSetRestrictionsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeInteractionsSetRestrictionsForRepoRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.InteractionsSetRestrictionsForRepo(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesAddAssigneesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesAddAssignees`,
			trace.WithAttributes(otelogen.OperationID(`issues/add-assignees`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesAddAssigneesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeIssuesAddAssigneesRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesAddAssignees(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesCheckUserCanBeAssignedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesCheckUserCanBeAssigned`,
			trace.WithAttributes(otelogen.OperationID(`issues/check-user-can-be-assigned`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesCheckUserCanBeAssignedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesCheckUserCanBeAssigned(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesDeleteCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesDeleteComment`,
			trace.WithAttributes(otelogen.OperationID(`issues/delete-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesDeleteCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesDeleteComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesDeleteLabelHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesDeleteLabel`,
			trace.WithAttributes(otelogen.OperationID(`issues/delete-label`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesDeleteLabelParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesDeleteLabel(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesDeleteMilestoneHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesDeleteMilestone`,
			trace.WithAttributes(otelogen.OperationID(`issues/delete-milestone`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesDeleteMilestoneParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesDeleteMilestone(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesGetCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesGetComment`,
			trace.WithAttributes(otelogen.OperationID(`issues/get-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesGetCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesGetComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesGetEventHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesGetEvent`,
			trace.WithAttributes(otelogen.OperationID(`issues/get-event`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesGetEventParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesGetEvent(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesGetLabelHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesGetLabel`,
			trace.WithAttributes(otelogen.OperationID(`issues/get-label`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesGetLabelParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesGetLabel(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesGetMilestoneHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesGetMilestone`,
			trace.WithAttributes(otelogen.OperationID(`issues/get-milestone`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesGetMilestoneParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesGetMilestone(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListAssigneesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListAssignees`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-assignees`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListAssigneesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListAssignees(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListCommentsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListComments`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-comments`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListCommentsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListComments(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListLabelsForMilestoneHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListLabelsForMilestone`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-labels-for-milestone`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListLabelsForMilestoneParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListLabelsForMilestone(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListLabelsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListLabelsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-labels-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListLabelsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListLabelsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListLabelsOnIssueHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListLabelsOnIssue`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-labels-on-issue`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListLabelsOnIssueParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListLabelsOnIssue(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesListMilestonesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesListMilestones`,
			trace.WithAttributes(otelogen.OperationID(`issues/list-milestones`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesListMilestonesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesListMilestones(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesRemoveAllLabelsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesRemoveAllLabels`,
			trace.WithAttributes(otelogen.OperationID(`issues/remove-all-labels`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesRemoveAllLabelsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesRemoveAllLabels(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesRemoveAssigneesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesRemoveAssignees`,
			trace.WithAttributes(otelogen.OperationID(`issues/remove-assignees`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesRemoveAssigneesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeIssuesRemoveAssigneesRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesRemoveAssignees(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesRemoveLabelHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesRemoveLabel`,
			trace.WithAttributes(otelogen.OperationID(`issues/remove-label`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesRemoveLabelParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesRemoveLabel(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesUnlockHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesUnlock`,
			trace.WithAttributes(otelogen.OperationID(`issues/unlock`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesUnlockParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesUnlock(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesUpdateLabelHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesUpdateLabel`,
			trace.WithAttributes(otelogen.OperationID(`issues/update-label`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesUpdateLabelParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeIssuesUpdateLabelRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesUpdateLabel(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewIssuesUpdateMilestoneHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `IssuesUpdateMilestone`,
			trace.WithAttributes(otelogen.OperationID(`issues/update-milestone`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeIssuesUpdateMilestoneParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeIssuesUpdateMilestoneRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.IssuesUpdateMilestone(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewLicensesGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `LicensesGet`,
			trace.WithAttributes(otelogen.OperationID(`licenses/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeLicensesGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.LicensesGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeLicensesGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewLicensesGetAllCommonlyUsedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `LicensesGetAllCommonlyUsed`,
			trace.WithAttributes(otelogen.OperationID(`licenses/get-all-commonly-used`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.LicensesGetAllCommonlyUsed(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewLicensesGetForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `LicensesGetForRepo`,
			trace.WithAttributes(otelogen.OperationID(`licenses/get-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeLicensesGetForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.LicensesGetForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMarkdownRenderHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MarkdownRender`,
			trace.WithAttributes(otelogen.OperationID(`markdown/render`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		request, err := decodeMarkdownRenderRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MarkdownRender(ctx, request)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMarkdownRenderResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMarkdownRenderRawHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MarkdownRenderRaw`,
			trace.WithAttributes(otelogen.OperationID(`markdown/render-raw`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		request, err := decodeMarkdownRenderRawRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MarkdownRenderRaw(ctx, request)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMarkdownRenderRawResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMetaGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MetaGet`,
			trace.WithAttributes(otelogen.OperationID(`meta/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.MetaGet(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMetaGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMetaGetOctocatHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MetaGetOctocat`,
			trace.WithAttributes(otelogen.OperationID(`meta/get-octocat`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.MetaGetOctocat(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMetaGetOctocatResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMetaGetZenHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MetaGetZen`,
			trace.WithAttributes(otelogen.OperationID(`meta/get-zen`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.MetaGetZen(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMetaGetZenResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMetaRootHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MetaRoot`,
			trace.WithAttributes(otelogen.OperationID(`meta/root`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.MetaRoot(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMetaRootResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsCancelImportHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsCancelImport`,
			trace.WithAttributes(otelogen.OperationID(`migrations/cancel-import`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsCancelImportParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsCancelImport(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsDeleteArchiveForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsDeleteArchiveForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/delete-archive-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsDeleteArchiveForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsDeleteArchiveForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/delete-archive-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsDeleteArchiveForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsDeleteArchiveForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsDownloadArchiveForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsDownloadArchiveForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/download-archive-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsDownloadArchiveForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsDownloadArchiveForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetArchiveForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetArchiveForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-archive-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetCommitAuthorsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetCommitAuthors`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-commit-authors`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetCommitAuthorsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetCommitAuthors(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetImportStatusHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetImportStatus`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-import-status`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetImportStatusParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetImportStatus(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetLargeFilesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetLargeFiles`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-large-files`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetLargeFilesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetLargeFiles(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetStatusForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetStatusForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-status-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetStatusForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsGetStatusForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsGetStatusForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/get-status-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsGetStatusForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsGetStatusForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsListForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsListForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/list-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.MigrationsListForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsListForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsListForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/list-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsListForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsListForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsListReposForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsListReposForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/list-repos-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsListReposForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsListReposForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsListReposForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsListReposForUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/list-repos-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsListReposForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsListReposForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsUnlockRepoForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsUnlockRepoForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`migrations/unlock-repo-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsUnlockRepoForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsUnlockRepoForOrg`,
			trace.WithAttributes(otelogen.OperationID(`migrations/unlock-repo-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsUnlockRepoForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsUnlockRepoForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewMigrationsUpdateImportHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `MigrationsUpdateImport`,
			trace.WithAttributes(otelogen.OperationID(`migrations/update-import`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeMigrationsUpdateImportParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeMigrationsUpdateImportRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.MigrationsUpdateImport(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsDeleteAuthorizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsDeleteAuthorization`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/delete-authorization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OAuthAuthorizationsDeleteAuthorization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsDeleteGrantHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsDeleteGrant`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/delete-grant`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOAuthAuthorizationsDeleteGrantParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OAuthAuthorizationsDeleteGrant(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsGetAuthorizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsGetAuthorization`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/get-authorization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOAuthAuthorizationsGetAuthorizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OAuthAuthorizationsGetAuthorization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsGetGrantHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsGetGrant`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/get-grant`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOAuthAuthorizationsGetGrantParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OAuthAuthorizationsGetGrant(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsListAuthorizationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsListAuthorizations`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/list-authorizations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.OAuthAuthorizationsListAuthorizations(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOAuthAuthorizationsListGrantsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsListGrants`,
			trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/list-grants`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.OAuthAuthorizationsListGrants(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsCheckBlockedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsCheckBlockedUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/check-blocked-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsCheckBlockedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsCheckBlockedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsCheckMembershipForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsCheckMembershipForUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/check-membership-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsCheckMembershipForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsCheckMembershipForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsCheckPublicMembershipForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsCheckPublicMembershipForUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/check-public-membership-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsCheckPublicMembershipForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsCheckPublicMembershipForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsConvertMemberToOutsideCollaboratorHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsConvertMemberToOutsideCollaborator`,
			trace.WithAttributes(otelogen.OperationID(`orgs/convert-member-to-outside-collaborator`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsConvertMemberToOutsideCollaborator(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsDeleteWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsDeleteWebhook`,
			trace.WithAttributes(otelogen.OperationID(`orgs/delete-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsDeleteWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsDeleteWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGet`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetAuditLogHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGetAuditLog`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get-audit-log`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetAuditLogParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGetAuditLog(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetMembershipForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGetMembershipForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get-membership-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGetMembershipForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetMembershipForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGetMembershipForUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get-membership-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetMembershipForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGetMembershipForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGetWebhook`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGetWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsGetWebhookConfigForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsGetWebhookConfigForOrg`,
			trace.WithAttributes(otelogen.OperationID(`orgs/get-webhook-config-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsGetWebhookConfigForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsGetWebhookConfigForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsList`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.OrgsList(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListBlockedUsersHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListBlockedUsers`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-blocked-users`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListBlockedUsersParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListBlockedUsers(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListFailedInvitationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListFailedInvitations`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-failed-invitations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListFailedInvitationsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListFailedInvitations(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.OrgsListForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListForUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListInvitationTeamsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListInvitationTeams`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-invitation-teams`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListInvitationTeamsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListInvitationTeams(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListOutsideCollaboratorsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListOutsideCollaborators`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-outside-collaborators`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListOutsideCollaboratorsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListOutsideCollaborators(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListPendingInvitationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListPendingInvitations`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-pending-invitations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListPendingInvitationsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListPendingInvitations(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListPublicMembersHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListPublicMembers`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-public-members`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListPublicMembersParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListPublicMembers(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListSamlSSOAuthorizationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListSamlSSOAuthorizations`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-saml-sso-authorizations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListSamlSSOAuthorizationsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListSamlSSOAuthorizations(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsListWebhooksHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsListWebhooks`,
			trace.WithAttributes(otelogen.OperationID(`orgs/list-webhooks`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsListWebhooksParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsListWebhooks(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsPingWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsPingWebhook`,
			trace.WithAttributes(otelogen.OperationID(`orgs/ping-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsPingWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsPingWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsRemoveMemberHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsRemoveMember`,
			trace.WithAttributes(otelogen.OperationID(`orgs/remove-member`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsRemoveMemberParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsRemoveMember(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsRemoveMembershipForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsRemoveMembershipForUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/remove-membership-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsRemoveMembershipForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsRemoveMembershipForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsRemoveOutsideCollaboratorHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsRemoveOutsideCollaborator`,
			trace.WithAttributes(otelogen.OperationID(`orgs/remove-outside-collaborator`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsRemoveOutsideCollaboratorParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsRemoveOutsideCollaborator(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsRemovePublicMembershipForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsRemovePublicMembershipForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/remove-public-membership-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsRemoveSamlSSOAuthorizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsRemoveSamlSSOAuthorization`,
			trace.WithAttributes(otelogen.OperationID(`orgs/remove-saml-sso-authorization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsRemoveSamlSSOAuthorization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsSetPublicMembershipForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsSetPublicMembershipForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/set-public-membership-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsUnblockUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsUnblockUser`,
			trace.WithAttributes(otelogen.OperationID(`orgs/unblock-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsUnblockUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsUnblockUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewOrgsUpdateWebhookConfigForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `OrgsUpdateWebhookConfigForOrg`,
			trace.WithAttributes(otelogen.OperationID(`orgs/update-webhook-config-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeOrgsUpdateWebhookConfigForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeOrgsUpdateWebhookConfigForOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForOrg`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageVersionForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageVersionForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForOrg`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageVersionForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageVersionForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesDeletePackageVersionForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesDeletePackageVersionForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesDeletePackageVersionForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetAllPackageVersionsForPackageOwnedByOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByOrg`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetAllPackageVersionsForPackageOwnedByUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageForOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageForOrganization`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageForOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageForOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageVersionForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageVersionForOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForOrganization`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageVersionForOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageVersionForOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesGetPackageVersionForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesGetPackageVersionForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesGetPackageVersionForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesListPackagesForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesListPackagesForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesListPackagesForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesListPackagesForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesListPackagesForOrganizationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesListPackagesForOrganization`,
			trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-organization`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesListPackagesForOrganizationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesListPackagesForOrganization(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesListPackagesForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesListPackagesForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesListPackagesForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesListPackagesForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForOrg`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageVersionForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageVersionForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForOrg`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageVersionForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageVersionForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPackagesRestorePackageVersionForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForUser`,
			trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePackagesRestorePackageVersionForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PackagesRestorePackageVersionForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsCreateColumnHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsCreateColumn`,
			trace.WithAttributes(otelogen.OperationID(`projects/create-column`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsCreateColumnParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsCreateColumnRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsCreateColumn(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsCreateForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsCreateForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`projects/create-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		request, err := decodeProjectsCreateForAuthenticatedUserRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsCreateForAuthenticatedUser(ctx, request)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsCreateForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsCreateForOrg`,
			trace.WithAttributes(otelogen.OperationID(`projects/create-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsCreateForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsCreateForOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsCreateForOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsCreateForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsCreateForRepo`,
			trace.WithAttributes(otelogen.OperationID(`projects/create-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsCreateForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsCreateForRepoRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsCreateForRepo(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsDeleteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsDelete`,
			trace.WithAttributes(otelogen.OperationID(`projects/delete`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsDeleteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsDelete(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsDeleteCardHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsDeleteCard`,
			trace.WithAttributes(otelogen.OperationID(`projects/delete-card`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsDeleteCardParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsDeleteCard(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsDeleteColumnHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsDeleteColumn`,
			trace.WithAttributes(otelogen.OperationID(`projects/delete-column`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsDeleteColumnParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsDeleteColumn(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsGet`,
			trace.WithAttributes(otelogen.OperationID(`projects/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsGetCardHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsGetCard`,
			trace.WithAttributes(otelogen.OperationID(`projects/get-card`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsGetCardParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsGetCard(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsGetColumnHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsGetColumn`,
			trace.WithAttributes(otelogen.OperationID(`projects/get-column`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsGetColumnParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsGetColumn(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsListCardsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsListCards`,
			trace.WithAttributes(otelogen.OperationID(`projects/list-cards`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsListCardsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsListCards(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsListColumnsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsListColumns`,
			trace.WithAttributes(otelogen.OperationID(`projects/list-columns`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsListColumnsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsListColumns(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsListForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsListForOrg`,
			trace.WithAttributes(otelogen.OperationID(`projects/list-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsListForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsListForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsListForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsListForRepo`,
			trace.WithAttributes(otelogen.OperationID(`projects/list-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsListForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsListForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsMoveColumnHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsMoveColumn`,
			trace.WithAttributes(otelogen.OperationID(`projects/move-column`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsMoveColumnParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsMoveColumnRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsMoveColumn(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsUpdateHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsUpdate`,
			trace.WithAttributes(otelogen.OperationID(`projects/update`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsUpdateParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsUpdateRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsUpdate(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsUpdateCardHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsUpdateCard`,
			trace.WithAttributes(otelogen.OperationID(`projects/update-card`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsUpdateCardParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsUpdateCardRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsUpdateCard(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewProjectsUpdateColumnHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ProjectsUpdateColumn`,
			trace.WithAttributes(otelogen.OperationID(`projects/update-column`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeProjectsUpdateColumnParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeProjectsUpdateColumnRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ProjectsUpdateColumn(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsCheckIfMergedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsCheckIfMerged`,
			trace.WithAttributes(otelogen.OperationID(`pulls/check-if-merged`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsCheckIfMergedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsCheckIfMerged(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsCreateReplyForReviewCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsCreateReplyForReviewComment`,
			trace.WithAttributes(otelogen.OperationID(`pulls/create-reply-for-review-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsCreateReplyForReviewCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsCreateReplyForReviewCommentRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsCreateReplyForReviewComment(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsCreateReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsCreateReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/create-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsCreateReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsCreateReviewRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsCreateReview(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsDeletePendingReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsDeletePendingReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/delete-pending-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsDeletePendingReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsDeletePendingReview(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsDeleteReviewCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsDeleteReviewComment`,
			trace.WithAttributes(otelogen.OperationID(`pulls/delete-review-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsDeleteReviewCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsDeleteReviewComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsDismissReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsDismissReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/dismiss-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsDismissReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsDismissReviewRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsDismissReview(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsGet`,
			trace.WithAttributes(otelogen.OperationID(`pulls/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsGetReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsGetReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/get-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsGetReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsGetReview(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsGetReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsGetReviewCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsGetReviewComment`,
			trace.WithAttributes(otelogen.OperationID(`pulls/get-review-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsGetReviewCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsGetReviewComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListCommentsForReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListCommentsForReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-comments-for-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListCommentsForReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListCommentsForReview(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListCommitsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListCommits`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-commits`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListCommitsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListCommits(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListCommitsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListRequestedReviewersHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListRequestedReviewers`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-requested-reviewers`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListRequestedReviewersParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListRequestedReviewers(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListReviewCommentsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListReviewComments`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-review-comments`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListReviewCommentsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListReviewComments(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListReviewCommentsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListReviewCommentsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-review-comments-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListReviewCommentsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListReviewCommentsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsListReviewsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsListReviews`,
			trace.WithAttributes(otelogen.OperationID(`pulls/list-reviews`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsListReviewsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsListReviews(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsListReviewsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsSubmitReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsSubmitReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/submit-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsSubmitReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsSubmitReviewRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsSubmitReview(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsUpdateReviewHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsUpdateReview`,
			trace.WithAttributes(otelogen.OperationID(`pulls/update-review`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsUpdateReviewParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsUpdateReviewRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsUpdateReview(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewPullsUpdateReviewCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `PullsUpdateReviewComment`,
			trace.WithAttributes(otelogen.OperationID(`pulls/update-review-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodePullsUpdateReviewCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodePullsUpdateReviewCommentRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.PullsUpdateReviewComment(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewRateLimitGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `RateLimitGet`,
			trace.WithAttributes(otelogen.OperationID(`rate-limit/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.RateLimitGet(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeRateLimitGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsCreateForTeamDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsCreateForTeamDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsCreateForTeamDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReactionsCreateForTeamDiscussionInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsCreateForTeamDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReactionsCreateForTeamDiscussionLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForCommitCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForCommitComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-commit-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForCommitCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForCommitComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForIssueHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForIssue`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-issue`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForIssueParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForIssue(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForIssueCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForIssueComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-issue-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForIssueCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForIssueComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForPullRequestCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForPullRequestComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-pull-request-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForPullRequestCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForPullRequestComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForTeamDiscussionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForTeamDiscussion`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-team-discussion`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForTeamDiscussionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForTeamDiscussion(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteForTeamDiscussionCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteForTeamDiscussionComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-team-discussion-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteForTeamDiscussionComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsDeleteLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsDeleteLegacy`,
			trace.WithAttributes(otelogen.OperationID(`reactions/delete-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsDeleteLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsDeleteLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForCommitCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForCommitComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-commit-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForCommitCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForCommitComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForIssueHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForIssue`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-issue`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForIssueParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForIssue(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForIssueCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForIssueComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-issue-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForIssueCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForIssueComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForPullRequestReviewCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForPullRequestReviewComment`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-pull-request-review-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForPullRequestReviewCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForPullRequestReviewComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForTeamDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForTeamDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForTeamDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForTeamDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForTeamDiscussionInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReactionsListForTeamDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReactionsListForTeamDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReactionsListForTeamDiscussionLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposAcceptInvitationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposAcceptInvitation`,
			trace.WithAttributes(otelogen.OperationID(`repos/accept-invitation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposAcceptInvitationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposAcceptInvitation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCheckCollaboratorHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCheckCollaborator`,
			trace.WithAttributes(otelogen.OperationID(`repos/check-collaborator`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCheckCollaboratorParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCheckCollaborator(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCheckVulnerabilityAlertsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCheckVulnerabilityAlerts`,
			trace.WithAttributes(otelogen.OperationID(`repos/check-vulnerability-alerts`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCheckVulnerabilityAlertsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCheckVulnerabilityAlerts(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCompareCommitsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCompareCommits`,
			trace.WithAttributes(otelogen.OperationID(`repos/compare-commits`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCompareCommitsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCompareCommits(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCreateCommitSignatureProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCreateCommitSignatureProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/create-commit-signature-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCreateCommitSignatureProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCreateCommitSignatureProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCreateCommitStatusHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCreateCommitStatus`,
			trace.WithAttributes(otelogen.OperationID(`repos/create-commit-status`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCreateCommitStatusParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposCreateCommitStatusRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCreateCommitStatus(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposCreateUsingTemplateHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposCreateUsingTemplate`,
			trace.WithAttributes(otelogen.OperationID(`repos/create-using-template`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposCreateUsingTemplateParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposCreateUsingTemplateRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposCreateUsingTemplate(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeclineInvitationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeclineInvitation`,
			trace.WithAttributes(otelogen.OperationID(`repos/decline-invitation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeclineInvitationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeclineInvitation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDelete`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDelete(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteAccessRestrictionsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteAccessRestrictions`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-access-restrictions`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteAccessRestrictionsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteAccessRestrictions(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteAdminBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteAdminBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-admin-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteAdminBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteAdminBranchProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteAnEnvironmentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteAnEnvironment`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-an-environment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteAnEnvironmentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteAnEnvironment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteAutolinkHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteAutolink`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-autolink`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteAutolinkParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteAutolink(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteBranchProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteCommitCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteCommitComment`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-commit-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteCommitCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteCommitComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteCommitSignatureProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteCommitSignatureProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-commit-signature-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteCommitSignatureProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteCommitSignatureProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteDeployKeyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteDeployKey`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-deploy-key`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteDeployKeyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteDeployKey(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteDeploymentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteDeployment`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-deployment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteDeploymentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteDeployment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteInvitationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteInvitation`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-invitation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteInvitationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteInvitation(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeletePullRequestReviewProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeletePullRequestReviewProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-pull-request-review-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeletePullRequestReviewProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeletePullRequestReviewProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteReleaseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteRelease`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-release`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteReleaseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteRelease(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteReleaseAssetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteReleaseAsset`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-release-asset`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteReleaseAssetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteReleaseAsset(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDeleteWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDeleteWebhook`,
			trace.WithAttributes(otelogen.OperationID(`repos/delete-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDeleteWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDeleteWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDisableAutomatedSecurityFixesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDisableAutomatedSecurityFixes`,
			trace.WithAttributes(otelogen.OperationID(`repos/disable-automated-security-fixes`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDisableAutomatedSecurityFixesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDisableAutomatedSecurityFixes(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDisableLfsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDisableLfsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`repos/disable-lfs-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDisableLfsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDisableLfsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDisableVulnerabilityAlertsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDisableVulnerabilityAlerts`,
			trace.WithAttributes(otelogen.OperationID(`repos/disable-vulnerability-alerts`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDisableVulnerabilityAlertsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDisableVulnerabilityAlerts(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDownloadTarballArchiveHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDownloadTarballArchive`,
			trace.WithAttributes(otelogen.OperationID(`repos/download-tarball-archive`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDownloadTarballArchiveParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDownloadTarballArchive(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposDownloadZipballArchiveHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposDownloadZipballArchive`,
			trace.WithAttributes(otelogen.OperationID(`repos/download-zipball-archive`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposDownloadZipballArchiveParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposDownloadZipballArchive(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposEnableAutomatedSecurityFixesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposEnableAutomatedSecurityFixes`,
			trace.WithAttributes(otelogen.OperationID(`repos/enable-automated-security-fixes`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposEnableAutomatedSecurityFixesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposEnableAutomatedSecurityFixes(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposEnableLfsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposEnableLfsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`repos/enable-lfs-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposEnableLfsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposEnableLfsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposEnableVulnerabilityAlertsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposEnableVulnerabilityAlerts`,
			trace.WithAttributes(otelogen.OperationID(`repos/enable-vulnerability-alerts`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposEnableVulnerabilityAlertsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposEnableVulnerabilityAlerts(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGet`,
			trace.WithAttributes(otelogen.OperationID(`repos/get`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGet(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAccessRestrictionsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAccessRestrictions`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-access-restrictions`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAccessRestrictionsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAccessRestrictions(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAdminBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAdminBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-admin-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAdminBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAdminBranchProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAllStatusCheckContextsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAllStatusCheckContexts`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-all-status-check-contexts`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAllStatusCheckContextsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAllStatusCheckContexts(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAllTopicsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAllTopics`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-all-topics`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAllTopicsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAllTopics(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAppsWithAccessToProtectedBranchHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAppsWithAccessToProtectedBranch`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-apps-with-access-to-protected-branch`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetAutolinkHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetAutolink`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-autolink`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetAutolinkParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetAutolink(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetBranchHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetBranch`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-branch`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetBranchParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetBranch(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetBranchResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetBranchProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetClonesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetClones`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-clones`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetClonesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetClones(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetClonesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCodeFrequencyStatsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCodeFrequencyStats`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-code-frequency-stats`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCodeFrequencyStatsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCodeFrequencyStats(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCollaboratorPermissionLevelHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCollaboratorPermissionLevel`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-collaborator-permission-level`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCollaboratorPermissionLevelParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCollaboratorPermissionLevel(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCombinedStatusForRefHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCombinedStatusForRef`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-combined-status-for-ref`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCombinedStatusForRefParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCombinedStatusForRef(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCommitActivityStatsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCommitActivityStats`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-commit-activity-stats`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCommitActivityStatsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCommitActivityStats(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCommitCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCommitComment`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-commit-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCommitCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCommitComment(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCommitSignatureProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCommitSignatureProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-commit-signature-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCommitSignatureProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCommitSignatureProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetCommunityProfileMetricsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetCommunityProfileMetrics`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-community-profile-metrics`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetCommunityProfileMetricsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetCommunityProfileMetrics(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetContributorsStatsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetContributorsStats`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-contributors-stats`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetContributorsStatsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetContributorsStats(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetDeployKeyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetDeployKey`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-deploy-key`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetDeployKeyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetDeployKey(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetDeploymentStatusHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetDeploymentStatus`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-deployment-status`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetDeploymentStatusParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetDeploymentStatus(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetLatestPagesBuildHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetLatestPagesBuild`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-latest-pages-build`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetLatestPagesBuildParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetLatestPagesBuild(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetLatestReleaseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetLatestRelease`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-latest-release`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetLatestReleaseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetLatestRelease(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetPagesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetPages`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-pages`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetPagesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetPages(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetPagesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetPagesBuildHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetPagesBuild`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-pages-build`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetPagesBuildParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetPagesBuild(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetPagesHealthCheckHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetPagesHealthCheck`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-pages-health-check`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetPagesHealthCheckParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetPagesHealthCheck(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetParticipationStatsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetParticipationStats`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-participation-stats`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetParticipationStatsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetParticipationStats(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetPullRequestReviewProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetPullRequestReviewProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-pull-request-review-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetPullRequestReviewProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetPullRequestReviewProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetPunchCardStatsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetPunchCardStats`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-punch-card-stats`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetPunchCardStatsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetPunchCardStats(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetReleaseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetRelease`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-release`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetReleaseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetRelease(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetReleaseAssetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetReleaseAsset`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-release-asset`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetReleaseAssetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetReleaseAsset(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetReleaseByTagHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetReleaseByTag`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-release-by-tag`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetReleaseByTagParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetReleaseByTag(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetStatusChecksProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetStatusChecksProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-status-checks-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetStatusChecksProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetStatusChecksProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetTeamsWithAccessToProtectedBranchHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetTeamsWithAccessToProtectedBranch`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-teams-with-access-to-protected-branch`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetTopPathsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetTopPaths`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-top-paths`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetTopPathsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetTopPaths(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetTopReferrersHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetTopReferrers`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-top-referrers`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetTopReferrersParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetTopReferrers(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetUsersWithAccessToProtectedBranchHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetUsersWithAccessToProtectedBranch`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-users-with-access-to-protected-branch`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetViewsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetViews`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-views`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetViewsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetViews(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetViewsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetWebhook`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposGetWebhookConfigForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposGetWebhookConfigForRepo`,
			trace.WithAttributes(otelogen.OperationID(`repos/get-webhook-config-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposGetWebhookConfigForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposGetWebhookConfigForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListAutolinksHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListAutolinks`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-autolinks`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListAutolinksParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListAutolinks(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListBranchesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListBranches`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-branches`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListBranchesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListBranches(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListBranchesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListCollaboratorsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListCollaborators`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-collaborators`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListCollaboratorsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListCollaborators(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListCommentsForCommitHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListCommentsForCommit`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-comments-for-commit`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListCommentsForCommitParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListCommentsForCommit(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListCommitCommentsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListCommitCommentsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-commit-comments-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListCommitCommentsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListCommitCommentsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListCommitStatusesForRefHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListCommitStatusesForRef`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-commit-statuses-for-ref`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListCommitStatusesForRefParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListCommitStatusesForRef(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListCommitsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListCommits`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-commits`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListCommitsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListCommits(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListCommitsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListContributorsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListContributors`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-contributors`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListContributorsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListContributors(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListContributorsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListDeployKeysHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListDeployKeys`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-deploy-keys`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListDeployKeysParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListDeployKeys(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListDeploymentStatusesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListDeploymentStatuses`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-deployment-statuses`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListDeploymentStatusesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListDeploymentStatuses(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListForOrg`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListForUser`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListForksHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListForks`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-forks`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListForksParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListForks(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListForksResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListInvitationsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListInvitations`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-invitations`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListInvitationsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListInvitations(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListInvitationsForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListInvitationsForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-invitations-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.ReposListInvitationsForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListLanguagesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListLanguages`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-languages`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListLanguagesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListLanguages(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListPagesBuildsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListPagesBuilds`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-pages-builds`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListPagesBuildsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListPagesBuilds(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListPullRequestsAssociatedWithCommitHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListPullRequestsAssociatedWithCommit`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-pull-requests-associated-with-commit`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListPullRequestsAssociatedWithCommitParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListPullRequestsAssociatedWithCommit(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListReleaseAssetsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListReleaseAssets`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-release-assets`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListReleaseAssetsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListReleaseAssets(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListReleasesHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListReleases`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-releases`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListReleasesParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListReleases(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListReleasesResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListTagsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListTags`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-tags`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListTagsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListTags(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListTagsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListTeamsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListTeams`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-teams`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListTeamsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListTeams(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListTeamsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposListWebhooksHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposListWebhooks`,
			trace.WithAttributes(otelogen.OperationID(`repos/list-webhooks`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposListWebhooksParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposListWebhooks(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposMergeUpstreamHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposMergeUpstream`,
			trace.WithAttributes(otelogen.OperationID(`repos/merge-upstream`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposMergeUpstreamParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposMergeUpstreamRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposMergeUpstream(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposPingWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposPingWebhook`,
			trace.WithAttributes(otelogen.OperationID(`repos/ping-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposPingWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposPingWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposRemoveCollaboratorHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposRemoveCollaborator`,
			trace.WithAttributes(otelogen.OperationID(`repos/remove-collaborator`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposRemoveCollaboratorParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposRemoveCollaborator(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposRemoveStatusCheckProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposRemoveStatusCheckProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/remove-status-check-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposRemoveStatusCheckProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposRemoveStatusCheckProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposReplaceAllTopicsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposReplaceAllTopics`,
			trace.WithAttributes(otelogen.OperationID(`repos/replace-all-topics`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposReplaceAllTopicsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposReplaceAllTopicsRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposReplaceAllTopics(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposRequestPagesBuildHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposRequestPagesBuild`,
			trace.WithAttributes(otelogen.OperationID(`repos/request-pages-build`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposRequestPagesBuildParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposRequestPagesBuild(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposSetAdminBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposSetAdminBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/set-admin-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposSetAdminBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposSetAdminBranchProtection(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposTestPushWebhookHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposTestPushWebhook`,
			trace.WithAttributes(otelogen.OperationID(`repos/test-push-webhook`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposTestPushWebhookParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposTestPushWebhook(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposTransferHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposTransfer`,
			trace.WithAttributes(otelogen.OperationID(`repos/transfer`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposTransferParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposTransferRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposTransfer(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposTransferResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateBranchProtectionHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateBranchProtection`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-branch-protection`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateBranchProtectionParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateBranchProtectionRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateBranchProtection(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateCommitCommentHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateCommitComment`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-commit-comment`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateCommitCommentParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateCommitCommentRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateCommitComment(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateInvitationHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateInvitation`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-invitation`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateInvitationParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateInvitationRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateInvitation(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateReleaseHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateRelease`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-release`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateReleaseParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateReleaseRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateRelease(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateReleaseAssetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateReleaseAsset`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-release-asset`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateReleaseAssetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateReleaseAssetRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateReleaseAsset(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUpdateWebhookConfigForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUpdateWebhookConfigForRepo`,
			trace.WithAttributes(otelogen.OperationID(`repos/update-webhook-config-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUpdateWebhookConfigForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUpdateWebhookConfigForRepoRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUpdateWebhookConfigForRepo(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewReposUploadReleaseAssetHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ReposUploadReleaseAsset`,
			trace.WithAttributes(otelogen.OperationID(`repos/upload-release-asset`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeReposUploadReleaseAssetParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeReposUploadReleaseAssetRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ReposUploadReleaseAsset(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeReposUploadReleaseAssetResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewScimDeleteUserFromOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `ScimDeleteUserFromOrg`,
			trace.WithAttributes(otelogen.OperationID(`scim/delete-user-from-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeScimDeleteUserFromOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.ScimDeleteUserFromOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSearchCommitsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SearchCommits`,
			trace.WithAttributes(otelogen.OperationID(`search/commits`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSearchCommitsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SearchCommits(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSearchCommitsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSearchTopicsHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SearchTopics`,
			trace.WithAttributes(otelogen.OperationID(`search/topics`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSearchTopicsParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SearchTopics(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSearchTopicsResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSecretScanningGetAlertHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SecretScanningGetAlert`,
			trace.WithAttributes(otelogen.OperationID(`secret-scanning/get-alert`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSecretScanningGetAlertParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SecretScanningGetAlert(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSecretScanningListAlertsForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SecretScanningListAlertsForOrg`,
			trace.WithAttributes(otelogen.OperationID(`secret-scanning/list-alerts-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSecretScanningListAlertsForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SecretScanningListAlertsForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSecretScanningListAlertsForRepoHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SecretScanningListAlertsForRepo`,
			trace.WithAttributes(otelogen.OperationID(`secret-scanning/list-alerts-for-repo`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSecretScanningListAlertsForRepoParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SecretScanningListAlertsForRepo(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewSecretScanningUpdateAlertHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `SecretScanningUpdateAlert`,
			trace.WithAttributes(otelogen.OperationID(`secret-scanning/update-alert`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeSecretScanningUpdateAlertParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeSecretScanningUpdateAlertRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.SecretScanningUpdateAlert(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsAddMemberLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsAddMemberLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/add-member-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsAddMemberLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsAddMemberLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsAddOrUpdateMembershipForUserInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateMembershipForUserInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-membership-for-user-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsAddOrUpdateMembershipForUserLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateMembershipForUserLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-membership-for-user-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsAddOrUpdateProjectPermissionsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateProjectPermissionsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-project-permissions-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsAddOrUpdateRepoPermissionsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateRepoPermissionsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-repo-permissions-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCheckPermissionsForProjectInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForProjectInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-project-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCheckPermissionsForProjectInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCheckPermissionsForProjectLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForProjectLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-project-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCheckPermissionsForProjectLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCheckPermissionsForRepoInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForRepoInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-repo-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCheckPermissionsForRepoInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCheckPermissionsForRepoLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForRepoLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-repo-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCheckPermissionsForRepoLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCreateDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCreateDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsCreateDiscussionCommentInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCreateDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCreateDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsCreateDiscussionCommentLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCreateDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCreateDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsCreateDiscussionInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCreateDiscussionInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCreateDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCreateDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsCreateDiscussionLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCreateDiscussionLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsCreateOrUpdateIdpGroupConnectionsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsCreateOrUpdateIdpGroupConnectionsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/create-or-update-idp-group-connections-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsDeleteDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsDeleteDiscussionCommentInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsDeleteDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsDeleteDiscussionCommentLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsDeleteDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsDeleteDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsDeleteDiscussionInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsDeleteDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsDeleteDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsDeleteDiscussionLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsDeleteInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsDeleteInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/delete-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsDeleteInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsDeleteInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetByNameHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetByName`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-by-name`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetByNameParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetByName(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetDiscussionCommentInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetDiscussionCommentLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetDiscussionInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetDiscussionLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetMemberLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetMemberLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-member-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetMemberLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetMemberLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetMembershipForUserInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetMembershipForUserInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-membership-for-user-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetMembershipForUserInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetMembershipForUserInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsGetMembershipForUserLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsGetMembershipForUserLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/get-membership-for-user-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsGetMembershipForUserLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsGetMembershipForUserLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsList`,
			trace.WithAttributes(otelogen.OperationID(`teams/list`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsList(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListChildInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListChildInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-child-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListChildInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListChildInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListDiscussionCommentsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListDiscussionCommentsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-discussion-comments-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListDiscussionCommentsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListDiscussionCommentsInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListDiscussionCommentsLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListDiscussionCommentsLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-discussion-comments-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListDiscussionCommentsLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListDiscussionCommentsLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListDiscussionsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListDiscussionsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-discussions-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListDiscussionsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListDiscussionsInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListDiscussionsLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListDiscussionsLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-discussions-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListDiscussionsLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListDiscussionsLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.TeamsListForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListIdpGroupsForLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsForLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-for-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListIdpGroupsForLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListIdpGroupsForLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListIdpGroupsForOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsForOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-for-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListIdpGroupsForOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListIdpGroupsForOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListIdpGroupsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListIdpGroupsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListIdpGroupsInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListMembersInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListMembersInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-members-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListMembersInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListMembersInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListMembersLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListMembersLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-members-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListMembersLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListMembersLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListPendingInvitationsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListPendingInvitationsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-pending-invitations-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListPendingInvitationsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListPendingInvitationsInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListPendingInvitationsLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListPendingInvitationsLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-pending-invitations-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListPendingInvitationsLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListPendingInvitationsLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListProjectsInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListProjectsInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-projects-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListProjectsInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListProjectsInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListProjectsLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListProjectsLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-projects-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListProjectsLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListProjectsLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListReposInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListReposInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-repos-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListReposInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListReposInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsListReposLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsListReposLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/list-repos-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsListReposLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsListReposLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveMemberLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveMemberLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-member-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveMemberLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveMemberLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveMembershipForUserInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveMembershipForUserInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-membership-for-user-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveMembershipForUserInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveMembershipForUserInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveMembershipForUserLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveMembershipForUserLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-membership-for-user-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveMembershipForUserLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveMembershipForUserLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveProjectInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveProjectInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-project-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveProjectInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveProjectInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveRepoInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveRepoInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-repo-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveRepoInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveRepoInOrg(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsRemoveRepoLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsRemoveRepoLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/remove-repo-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsRemoveRepoLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsRemoveRepoLegacy(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsUpdateDiscussionCommentInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionCommentInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-comment-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsUpdateDiscussionCommentInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsUpdateDiscussionCommentLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionCommentLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-comment-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsUpdateDiscussionCommentLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsUpdateDiscussionInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsUpdateDiscussionInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsUpdateDiscussionInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsUpdateDiscussionInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsUpdateDiscussionLegacyHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionLegacy`,
			trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-legacy`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsUpdateDiscussionLegacyParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsUpdateDiscussionLegacyRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsUpdateDiscussionLegacy(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewTeamsUpdateInOrgHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `TeamsUpdateInOrg`,
			trace.WithAttributes(otelogen.OperationID(`teams/update-in-org`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeTeamsUpdateInOrgParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}
		request, err := decodeTeamsUpdateInOrgRequest(r, span)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.TeamsUpdateInOrg(ctx, request, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersCheckBlockedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersCheckBlocked`,
			trace.WithAttributes(otelogen.OperationID(`users/check-blocked`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersCheckBlockedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersCheckBlocked(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersCheckFollowingForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersCheckFollowingForUser`,
			trace.WithAttributes(otelogen.OperationID(`users/check-following-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersCheckFollowingForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersCheckFollowingForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersCheckPersonIsFollowedByAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersCheckPersonIsFollowedByAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/check-person-is-followed-by-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersDeletePublicSSHKeyForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersDeletePublicSSHKeyForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/delete-public-ssh-key-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersFollowHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersFollow`,
			trace.WithAttributes(otelogen.OperationID(`users/follow`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersFollowParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersFollow(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersFollowResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersGetAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersGetAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/get-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersGetAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersGetByUsernameHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersGetByUsername`,
			trace.WithAttributes(otelogen.OperationID(`users/get-by-username`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersGetByUsernameParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersGetByUsername(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersGetGpgKeyForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersGetGpgKeyForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/get-gpg-key-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersGetGpgKeyForAuthenticatedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersGetGpgKeyForAuthenticated(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersGetPublicSSHKeyForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersGetPublicSSHKeyForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/get-public-ssh-key-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersList`,
			trace.WithAttributes(otelogen.OperationID(`users/list`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersList(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListBlockedByAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListBlockedByAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-blocked-by-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListBlockedByAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListEmailsForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListEmailsForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-emails-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListEmailsForAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListFollowedByAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListFollowedByAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-followed-by-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListFollowedByAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListFollowersForAuthenticatedUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListFollowersForAuthenticatedUser`,
			trace.WithAttributes(otelogen.OperationID(`users/list-followers-for-authenticated-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListFollowersForAuthenticatedUser(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListFollowersForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListFollowersForUser`,
			trace.WithAttributes(otelogen.OperationID(`users/list-followers-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersListFollowersForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersListFollowersForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListFollowingForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListFollowingForUser`,
			trace.WithAttributes(otelogen.OperationID(`users/list-following-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersListFollowingForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersListFollowingForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListGpgKeysForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListGpgKeysForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-gpg-keys-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListGpgKeysForAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListGpgKeysForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListGpgKeysForUser`,
			trace.WithAttributes(otelogen.OperationID(`users/list-gpg-keys-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersListGpgKeysForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersListGpgKeysForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListPublicEmailsForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListPublicEmailsForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-public-emails-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListPublicEmailsForAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListPublicKeysForUserHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListPublicKeysForUser`,
			trace.WithAttributes(otelogen.OperationID(`users/list-public-keys-for-user`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersListPublicKeysForUserParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersListPublicKeysForUser(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersListPublicSSHKeysForAuthenticatedHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersListPublicSSHKeysForAuthenticated`,
			trace.WithAttributes(otelogen.OperationID(`users/list-public-ssh-keys-for-authenticated`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()

		response, err := s.UsersListPublicSSHKeysForAuthenticated(ctx)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersUnblockHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersUnblock`,
			trace.WithAttributes(otelogen.OperationID(`users/unblock`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersUnblockParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersUnblock(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersUnblockResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func NewUsersUnfollowHandler(s Server, opts ...Option) func(w http.ResponseWriter, r *http.Request) {
	cfg := newConfig(opts...)
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := cfg.Tracer.Start(r.Context(), `UsersUnfollow`,
			trace.WithAttributes(otelogen.OperationID(`users/unfollow`)),
			trace.WithSpanKind(trace.SpanKindServer),
		)
		defer span.End()
		params, err := decodeUsersUnfollowParams(r)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusBadRequest, err)
			return
		}

		response, err := s.UsersUnfollow(ctx, params)
		if err != nil {
			span.RecordError(err)
			respondError(w, http.StatusInternalServerError, err)
			return
		}

		if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
			span.RecordError(err)
			return
		}
	}
}

func respondError(w http.ResponseWriter, code int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	data, writeErr := json.Marshal(struct {
		ErrorMessage string `json:"error_message"`
	}{
		ErrorMessage: err.Error(),
	})
	if writeErr == nil {
		w.Write(data)
	}
}
