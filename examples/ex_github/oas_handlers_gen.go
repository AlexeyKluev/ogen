// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
			ID:   "actions/add-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/add-repo-access-to-self-hosted-runner-group-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"repository_id":   params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsAddSelectedRepoToOrgSecretRequest handles actions/add-selected-repo-to-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsAddSelectedRepoToOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelectedRepoToOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsAddSelectedRepoToOrgSecret",
			ID:   "actions/add-selected-repo-to-org-secret",
		}
	)
	params, err := decodeActionsAddSelectedRepoToOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsAddSelectedRepoToOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddSelectedRepoToOrgSecret",
			OperationID:   "actions/add-selected-repo-to-org-secret",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"secret_name":   params.SecretName,
				"repository_id": params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelectedRepoToOrgSecretParams
			Response = ActionsAddSelectedRepoToOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelectedRepoToOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsAddSelfHostedRunnerToGroupForOrgRequest handles actions/add-self-hosted-runner-to-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelfHostedRunnerToGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsAddSelfHostedRunnerToGroupForOrg",
			ID:   "actions/add-self-hosted-runner-to-group-for-org",
		}
	)
	params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsAddSelfHostedRunnerToGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddSelfHostedRunnerToGroupForOrg",
			OperationID:   "actions/add-self-hosted-runner-to-group-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"runner_id":       params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelfHostedRunnerToGroupForOrgParams
			Response = ActionsAddSelfHostedRunnerToGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelfHostedRunnerToGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsApproveWorkflowRunRequest handles actions/approve-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (s *Server) handleActionsApproveWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsApproveWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsApproveWorkflowRun",
			ID:   "actions/approve-workflow-run",
		}
	)
	params, err := decodeActionsApproveWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsApproveWorkflowRunRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsApproveWorkflowRun",
			OperationID:   "actions/approve-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsApproveWorkflowRunParams
			Response = ActionsApproveWorkflowRunRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsApproveWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsApproveWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsApproveWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCancelWorkflowRunRequest handles actions/cancel-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (s *Server) handleActionsCancelWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCancelWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCancelWorkflowRun",
			ID:   "actions/cancel-workflow-run",
		}
	)
	params, err := decodeActionsCancelWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsCancelWorkflowRunAccepted
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCancelWorkflowRun",
			OperationID:   "actions/cancel-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCancelWorkflowRunParams
			Response = ActionsCancelWorkflowRunAccepted
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCancelWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCancelWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsCancelWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateEnvironmentSecretRequest handles actions/create-or-update-environment-secret operation.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateOrUpdateEnvironmentSecret",
			ID:   "actions/create-or-update-environment-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateEnvironmentSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateEnvironmentSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateEnvironmentSecret",
			OperationID:   "actions/create-or-update-environment-secret",
			Body:          request,
			Params: map[string]any{
				"repository_id":    params.RepositoryID,
				"environment_name": params.EnvironmentName,
				"secret_name":      params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = ActionsCreateOrUpdateEnvironmentSecretReq
			Params   = ActionsCreateOrUpdateEnvironmentSecretParams
			Response = ActionsCreateOrUpdateEnvironmentSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateOrgSecretRequest handles actions/create-or-update-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateOrUpdateOrgSecret",
			ID:   "actions/create-or-update-org-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateOrgSecret",
			OperationID:   "actions/create-or-update-org-secret",
			Body:          request,
			Params: map[string]any{
				"org":         params.Org,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = ActionsCreateOrUpdateOrgSecretReq
			Params   = ActionsCreateOrUpdateOrgSecretParams
			Response = ActionsCreateOrUpdateOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateRepoSecretRequest handles actions/create-or-update-repo-secret operation.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateOrUpdateRepoSecret",
			ID:   "actions/create-or-update-repo-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateRepoSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateRepoSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateRepoSecret",
			OperationID:   "actions/create-or-update-repo-secret",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = ActionsCreateOrUpdateRepoSecretReq
			Params   = ActionsCreateOrUpdateRepoSecretParams
			Response = ActionsCreateOrUpdateRepoSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRegistrationTokenForOrgRequest handles actions/create-registration-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateRegistrationTokenForOrg",
			ID:   "actions/create-registration-token-for-org",
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRegistrationTokenForOrg",
			OperationID:   "actions/create-registration-token-for-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForOrgParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRegistrationTokenForRepoRequest handles actions/create-registration-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateRegistrationTokenForRepo",
			ID:   "actions/create-registration-token-for-repo",
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRegistrationTokenForRepo",
			OperationID:   "actions/create-registration-token-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForRepoParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRemoveTokenForOrgRequest handles actions/create-remove-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateRemoveTokenForOrg",
			ID:   "actions/create-remove-token-for-org",
		}
	)
	params, err := decodeActionsCreateRemoveTokenForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRemoveTokenForOrg",
			OperationID:   "actions/create-remove-token-for-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForOrgParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRemoveTokenForRepoRequest handles actions/create-remove-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateRemoveTokenForRepo",
			ID:   "actions/create-remove-token-for-repo",
		}
	)
	params, err := decodeActionsCreateRemoveTokenForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRemoveTokenForRepo",
			OperationID:   "actions/create-remove-token-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForRepoParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateSelfHostedRunnerGroupForOrgRequest handles actions/create-self-hosted-runner-group-for-org operation.
//
// POST /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsCreateSelfHostedRunnerGroupForOrg",
			ID:   "actions/create-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/create-self-hosted-runner-group-for-org",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = ActionsCreateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsCreateSelfHostedRunnerGroupForOrgParams
			Response = RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteArtifactRequest handles actions/delete-artifact operation.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsDeleteArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteArtifact",
			ID:   "actions/delete-artifact",
		}
	)
	params, err := decodeActionsDeleteArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteArtifactNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteArtifact",
			OperationID:   "actions/delete-artifact",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"artifact_id": params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteArtifactParams
			Response = ActionsDeleteArtifactNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteArtifactParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteArtifact(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteEnvironmentSecretRequest handles actions/delete-environment-secret operation.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsDeleteEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteEnvironmentSecret",
			ID:   "actions/delete-environment-secret",
		}
	)
	params, err := decodeActionsDeleteEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteEnvironmentSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteEnvironmentSecret",
			OperationID:   "actions/delete-environment-secret",
			Body:          nil,
			Params: map[string]any{
				"repository_id":    params.RepositoryID,
				"environment_name": params.EnvironmentName,
				"secret_name":      params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteEnvironmentSecretParams
			Response = ActionsDeleteEnvironmentSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteEnvironmentSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteEnvironmentSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteOrgSecretRequest handles actions/delete-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteOrgSecret",
			ID:   "actions/delete-org-secret",
		}
	)
	params, err := decodeActionsDeleteOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteOrgSecret",
			OperationID:   "actions/delete-org-secret",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteOrgSecretParams
			Response = ActionsDeleteOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteOrgSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteRepoSecretRequest handles actions/delete-repo-secret operation.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteRepoSecret",
			ID:   "actions/delete-repo-secret",
		}
	)
	params, err := decodeActionsDeleteRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteRepoSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteRepoSecret",
			OperationID:   "actions/delete-repo-secret",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteRepoSecretParams
			Response = ActionsDeleteRepoSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteRepoSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteRepoSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromOrgRequest handles actions/delete-self-hosted-runner-from-org operation.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteSelfHostedRunnerFromOrg",
			ID:   "actions/delete-self-hosted-runner-from-org",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteSelfHostedRunnerFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerFromOrg",
			OperationID:   "actions/delete-self-hosted-runner-from-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"runner_id": params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromOrgParams
			Response = ActionsDeleteSelfHostedRunnerFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromRepoRequest handles actions/delete-self-hosted-runner-from-repo operation.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteSelfHostedRunnerFromRepo",
			ID:   "actions/delete-self-hosted-runner-from-repo",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteSelfHostedRunnerFromRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerFromRepo",
			OperationID:   "actions/delete-self-hosted-runner-from-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"runner_id": params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromRepoParams
			Response = ActionsDeleteSelfHostedRunnerFromRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest handles actions/delete-self-hosted-runner-group-from-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerGroupFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteSelfHostedRunnerGroupFromOrg",
			ID:   "actions/delete-self-hosted-runner-group-from-org",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerGroupFromOrg",
			OperationID:   "actions/delete-self-hosted-runner-group-from-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerGroupFromOrgParams
			Response = ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerGroupFromOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteWorkflowRunRequest handles actions/delete-workflow-run operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsDeleteWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteWorkflowRun",
			ID:   "actions/delete-workflow-run",
		}
	)
	params, err := decodeActionsDeleteWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteWorkflowRunNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteWorkflowRun",
			OperationID:   "actions/delete-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunParams
			Response = ActionsDeleteWorkflowRunNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteWorkflowRunLogsRequest handles actions/delete-workflow-run-logs operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDeleteWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDeleteWorkflowRunLogs",
			ID:   "actions/delete-workflow-run-logs",
		}
	)
	params, err := decodeActionsDeleteWorkflowRunLogsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDeleteWorkflowRunLogsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteWorkflowRunLogs",
			OperationID:   "actions/delete-workflow-run-logs",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunLogsParams
			Response = ActionsDeleteWorkflowRunLogsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest handles actions/disable-selected-repository-github-actions-organization operation.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDisableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDisableSelectedRepositoryGithubActionsOrganization",
			ID:   "actions/disable-selected-repository-github-actions-organization",
		}
	)
	params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDisableSelectedRepositoryGithubActionsOrganization",
			OperationID:   "actions/disable-selected-repository-github-actions-organization",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"repository_id": params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
			Response = ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDisableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadArtifactRequest handles actions/download-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (s *Server) handleActionsDownloadArtifactRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDownloadArtifact",
			ID:   "actions/download-artifact",
		}
	)
	params, err := decodeActionsDownloadArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDownloadArtifactFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadArtifact",
			OperationID:   "actions/download-artifact",
			Body:          nil,
			Params: map[string]any{
				"owner":          params.Owner,
				"repo":           params.Repo,
				"artifact_id":    params.ArtifactID,
				"archive_format": params.ArchiveFormat,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadArtifactParams
			Response = ActionsDownloadArtifactFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadArtifactParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDownloadArtifact(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDownloadArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadJobLogsForWorkflowRunRequest handles actions/download-job-logs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (s *Server) handleActionsDownloadJobLogsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadJobLogsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDownloadJobLogsForWorkflowRun",
			ID:   "actions/download-job-logs-for-workflow-run",
		}
	)
	params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDownloadJobLogsForWorkflowRunFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadJobLogsForWorkflowRun",
			OperationID:   "actions/download-job-logs-for-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"job_id": params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadJobLogsForWorkflowRunParams
			Response = ActionsDownloadJobLogsForWorkflowRunFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadJobLogsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadWorkflowRunLogsRequest handles actions/download-workflow-run-logs operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDownloadWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsDownloadWorkflowRunLogs",
			ID:   "actions/download-workflow-run-logs",
		}
	)
	params, err := decodeActionsDownloadWorkflowRunLogsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsDownloadWorkflowRunLogsFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadWorkflowRunLogs",
			OperationID:   "actions/download-workflow-run-logs",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadWorkflowRunLogsParams
			Response = ActionsDownloadWorkflowRunLogsFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest handles actions/enable-selected-repository-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsEnableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsEnableSelectedRepositoryGithubActionsOrganization",
			ID:   "actions/enable-selected-repository-github-actions-organization",
		}
	)
	params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsEnableSelectedRepositoryGithubActionsOrganization",
			OperationID:   "actions/enable-selected-repository-github-actions-organization",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"repository_id": params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
			Response = ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsEnableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetAllowedActionsOrganizationRequest handles actions/get-allowed-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetAllowedActionsOrganization",
			ID:   "actions/get-allowed-actions-organization",
		}
	)
	params, err := decodeActionsGetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetAllowedActionsOrganization",
			OperationID:   "actions/get-allowed-actions-organization",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsOrganizationParams
			Response = SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetAllowedActionsOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetAllowedActionsRepositoryRequest handles actions/get-allowed-actions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetAllowedActionsRepository",
			ID:   "actions/get-allowed-actions-repository",
		}
	)
	params, err := decodeActionsGetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetAllowedActionsRepository",
			OperationID:   "actions/get-allowed-actions-repository",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsRepositoryParams
			Response = SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetAllowedActionsRepository(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsRepository(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetArtifactRequest handles actions/get-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsGetArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetArtifact",
			ID:   "actions/get-artifact",
		}
	)
	params, err := decodeActionsGetArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Artifact
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetArtifact",
			OperationID:   "actions/get-artifact",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"artifact_id": params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetArtifactParams
			Response = Artifact
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetArtifactParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetArtifact(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetEnvironmentPublicKeyRequest handles actions/get-environment-public-key operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (s *Server) handleActionsGetEnvironmentPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetEnvironmentPublicKey",
			ID:   "actions/get-environment-public-key",
		}
	)
	params, err := decodeActionsGetEnvironmentPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetEnvironmentPublicKey",
			OperationID:   "actions/get-environment-public-key",
			Body:          nil,
			Params: map[string]any{
				"repository_id":    params.RepositoryID,
				"environment_name": params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentPublicKeyParams
			Response = ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetEnvironmentPublicKey(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetEnvironmentSecretRequest handles actions/get-environment-secret operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsGetEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetEnvironmentSecret",
			ID:   "actions/get-environment-secret",
		}
	)
	params, err := decodeActionsGetEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetEnvironmentSecret",
			OperationID:   "actions/get-environment-secret",
			Body:          nil,
			Params: map[string]any{
				"repository_id":    params.RepositoryID,
				"environment_name": params.EnvironmentName,
				"secret_name":      params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentSecretParams
			Response = ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetEnvironmentSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetGithubActionsPermissionsOrganizationRequest handles actions/get-github-actions-permissions-organization operation.
//
// GET /orgs/{org}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetGithubActionsPermissionsOrganization",
			ID:   "actions/get-github-actions-permissions-organization",
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsOrganizationPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetGithubActionsPermissionsOrganization",
			OperationID:   "actions/get-github-actions-permissions-organization",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsOrganizationParams
			Response = ActionsOrganizationPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetGithubActionsPermissionsRepositoryRequest handles actions/get-github-actions-permissions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetGithubActionsPermissionsRepository",
			ID:   "actions/get-github-actions-permissions-repository",
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRepositoryPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetGithubActionsPermissionsRepository",
			OperationID:   "actions/get-github-actions-permissions-repository",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsRepositoryParams
			Response = ActionsRepositoryPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetJobForWorkflowRunRequest handles actions/get-job-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (s *Server) handleActionsGetJobForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetJobForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetJobForWorkflowRun",
			ID:   "actions/get-job-for-workflow-run",
		}
	)
	params, err := decodeActionsGetJobForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Job
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetJobForWorkflowRun",
			OperationID:   "actions/get-job-for-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"job_id": params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetJobForWorkflowRunParams
			Response = Job
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetJobForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetJobForWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetJobForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetOrgPublicKeyRequest handles actions/get-org-public-key operation.
//
// GET /orgs/{org}/actions/secrets/public-key
func (s *Server) handleActionsGetOrgPublicKeyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetOrgPublicKey",
			ID:   "actions/get-org-public-key",
		}
	)
	params, err := decodeActionsGetOrgPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetOrgPublicKey",
			OperationID:   "actions/get-org-public-key",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgPublicKeyParams
			Response = ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetOrgPublicKey(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetOrgSecretRequest handles actions/get-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetOrgSecret",
			ID:   "actions/get-org-secret",
		}
	)
	params, err := decodeActionsGetOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrganizationActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetOrgSecret",
			OperationID:   "actions/get-org-secret",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgSecretParams
			Response = OrganizationActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetOrgSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetRepoPublicKeyRequest handles actions/get-repo-public-key operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (s *Server) handleActionsGetRepoPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetRepoPublicKey",
			ID:   "actions/get-repo-public-key",
		}
	)
	params, err := decodeActionsGetRepoPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetRepoPublicKey",
			OperationID:   "actions/get-repo-public-key",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoPublicKeyParams
			Response = ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetRepoPublicKey(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetRepoSecretRequest handles actions/get-repo-secret operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetRepoSecret",
			ID:   "actions/get-repo-secret",
		}
	)
	params, err := decodeActionsGetRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetRepoSecret",
			OperationID:   "actions/get-repo-secret",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoSecretParams
			Response = ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetRepoSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetReviewsForRunRequest handles actions/get-reviews-for-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (s *Server) handleActionsGetReviewsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetReviewsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetReviewsForRun",
			ID:   "actions/get-reviews-for-run",
		}
	)
	params, err := decodeActionsGetReviewsForRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []EnvironmentApprovals
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetReviewsForRun",
			OperationID:   "actions/get-reviews-for-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetReviewsForRunParams
			Response = []EnvironmentApprovals
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetReviewsForRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetReviewsForRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetReviewsForRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerForOrgRequest handles actions/get-self-hosted-runner-for-org operation.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetSelfHostedRunnerForOrg",
			ID:   "actions/get-self-hosted-runner-for-org",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerForOrg",
			OperationID:   "actions/get-self-hosted-runner-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"runner_id": params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForOrgParams
			Response = Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerForRepoRequest handles actions/get-self-hosted-runner-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetSelfHostedRunnerForRepo",
			ID:   "actions/get-self-hosted-runner-for-repo",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerForRepo",
			OperationID:   "actions/get-self-hosted-runner-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"runner_id": params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForRepoParams
			Response = Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerGroupForOrgRequest handles actions/get-self-hosted-runner-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsGetSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetSelfHostedRunnerGroupForOrg",
			ID:   "actions/get-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/get-self-hosted-runner-group-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerGroupForOrgParams
			Response = RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetWorkflowRunRequest handles actions/get-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsGetWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetWorkflowRun",
			ID:   "actions/get-workflow-run",
		}
	)
	params, err := decodeActionsGetWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WorkflowRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetWorkflowRun",
			OperationID:   "actions/get-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunParams
			Response = WorkflowRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetWorkflowRunUsageRequest handles actions/get-workflow-run-usage operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (s *Server) handleActionsGetWorkflowRunUsageRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRunUsage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsGetWorkflowRunUsage",
			ID:   "actions/get-workflow-run-usage",
		}
	)
	params, err := decodeActionsGetWorkflowRunUsageParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WorkflowRunUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetWorkflowRunUsage",
			OperationID:   "actions/get-workflow-run-usage",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunUsageParams
			Response = WorkflowRunUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunUsageParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsGetWorkflowRunUsage(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRunUsage(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListArtifactsForRepoRequest handles actions/list-artifacts-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (s *Server) handleActionsListArtifactsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListArtifactsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListArtifactsForRepo",
			ID:   "actions/list-artifacts-for-repo",
		}
	)
	params, err := decodeActionsListArtifactsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListArtifactsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListArtifactsForRepo",
			OperationID:   "actions/list-artifacts-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListArtifactsForRepoParams
			Response = ActionsListArtifactsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListArtifactsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListArtifactsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListArtifactsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListEnvironmentSecretsRequest handles actions/list-environment-secrets operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (s *Server) handleActionsListEnvironmentSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListEnvironmentSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListEnvironmentSecrets",
			ID:   "actions/list-environment-secrets",
		}
	)
	params, err := decodeActionsListEnvironmentSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListEnvironmentSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListEnvironmentSecrets",
			OperationID:   "actions/list-environment-secrets",
			Body:          nil,
			Params: map[string]any{
				"repository_id":    params.RepositoryID,
				"environment_name": params.EnvironmentName,
				"per_page":         params.PerPage,
				"page":             params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListEnvironmentSecretsParams
			Response = ActionsListEnvironmentSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListEnvironmentSecretsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListEnvironmentSecrets(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListEnvironmentSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListJobsForWorkflowRunRequest handles actions/list-jobs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (s *Server) handleActionsListJobsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListJobsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListJobsForWorkflowRun",
			ID:   "actions/list-jobs-for-workflow-run",
		}
	)
	params, err := decodeActionsListJobsForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListJobsForWorkflowRunOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListJobsForWorkflowRun",
			OperationID:   "actions/list-jobs-for-workflow-run",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"run_id":   params.RunID,
				"filter":   params.Filter,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListJobsForWorkflowRunParams
			Response = ActionsListJobsForWorkflowRunOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListJobsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListJobsForWorkflowRun(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListJobsForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListOrgSecretsRequest handles actions/list-org-secrets operation.
//
// GET /orgs/{org}/actions/secrets
func (s *Server) handleActionsListOrgSecretsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListOrgSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListOrgSecrets",
			ID:   "actions/list-org-secrets",
		}
	)
	params, err := decodeActionsListOrgSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListOrgSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListOrgSecrets",
			OperationID:   "actions/list-org-secrets",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListOrgSecretsParams
			Response = ActionsListOrgSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListOrgSecretsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListOrgSecrets(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListOrgSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
			ID:   "actions/list-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/list-repo-access-to-self-hosted-runner-group-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"page":            params.Page,
				"per_page":        params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoSecretsRequest handles actions/list-repo-secrets operation.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (s *Server) handleActionsListRepoSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListRepoSecrets",
			ID:   "actions/list-repo-secrets",
		}
	)
	params, err := decodeActionsListRepoSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListRepoSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoSecrets",
			OperationID:   "actions/list-repo-secrets",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoSecretsParams
			Response = ActionsListRepoSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoSecretsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListRepoSecrets(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListRepoSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoWorkflowsRequest handles actions/list-repo-workflows operation.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (s *Server) handleActionsListRepoWorkflowsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoWorkflows",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListRepoWorkflows",
			ID:   "actions/list-repo-workflows",
		}
	)
	params, err := decodeActionsListRepoWorkflowsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListRepoWorkflowsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoWorkflows",
			OperationID:   "actions/list-repo-workflows",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoWorkflowsParams
			Response = ActionsListRepoWorkflowsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoWorkflowsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListRepoWorkflows(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListRepoWorkflows(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRunnerApplicationsForOrgRequest handles actions/list-runner-applications-for-org operation.
//
// GET /orgs/{org}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListRunnerApplicationsForOrg",
			ID:   "actions/list-runner-applications-for-org",
		}
	)
	params, err := decodeActionsListRunnerApplicationsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRunnerApplicationsForOrg",
			OperationID:   "actions/list-runner-applications-for-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForOrgParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRunnerApplicationsForRepoRequest handles actions/list-runner-applications-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListRunnerApplicationsForRepo",
			ID:   "actions/list-runner-applications-for-repo",
		}
	)
	params, err := decodeActionsListRunnerApplicationsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRunnerApplicationsForRepo",
			OperationID:   "actions/list-runner-applications-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForRepoParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelectedReposForOrgSecretRequest handles actions/list-selected-repos-for-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsListSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelectedReposForOrgSecret",
			ID:   "actions/list-selected-repos-for-org-secret",
		}
	)
	params, err := decodeActionsListSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelectedReposForOrgSecretOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelectedReposForOrgSecret",
			OperationID:   "actions/list-selected-repos-for-org-secret",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"secret_name": params.SecretName,
				"page":        params.Page,
				"per_page":    params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedReposForOrgSecretParams
			Response = ActionsListSelectedReposForOrgSecretOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
			ID:   "actions/list-selected-repositories-enabled-github-actions-organization",
		}
	)
	params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
			OperationID:   "actions/list-selected-repositories-enabled-github-actions-organization",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnerGroupsForOrgRequest handles actions/list-self-hosted-runner-groups-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsListSelfHostedRunnerGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnerGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelfHostedRunnerGroupsForOrg",
			ID:   "actions/list-self-hosted-runner-groups-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelfHostedRunnerGroupsForOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnerGroupsForOrg",
			OperationID:   "actions/list-self-hosted-runner-groups-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnerGroupsForOrgParams
			Response = ActionsListSelfHostedRunnerGroupsForOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnerGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersForOrgRequest handles actions/list-self-hosted-runners-for-org operation.
//
// GET /orgs/{org}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelfHostedRunnersForOrg",
			ID:   "actions/list-self-hosted-runners-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelfHostedRunnersForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersForOrg",
			OperationID:   "actions/list-self-hosted-runners-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForOrgParams
			Response = ActionsListSelfHostedRunnersForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersForRepoRequest handles actions/list-self-hosted-runners-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelfHostedRunnersForRepo",
			ID:   "actions/list-self-hosted-runners-for-repo",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelfHostedRunnersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersForRepo",
			OperationID:   "actions/list-self-hosted-runners-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForRepoParams
			Response = ActionsListSelfHostedRunnersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersInGroupForOrgRequest handles actions/list-self-hosted-runners-in-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsListSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListSelfHostedRunnersInGroupForOrg",
			ID:   "actions/list-self-hosted-runners-in-group-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersInGroupForOrg",
			OperationID:   "actions/list-self-hosted-runners-in-group-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"per_page":        params.PerPage,
				"page":            params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersInGroupForOrgParams
			Response = ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListWorkflowRunArtifactsRequest handles actions/list-workflow-run-artifacts operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (s *Server) handleActionsListWorkflowRunArtifactsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunArtifacts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListWorkflowRunArtifacts",
			ID:   "actions/list-workflow-run-artifacts",
		}
	)
	params, err := decodeActionsListWorkflowRunArtifactsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListWorkflowRunArtifactsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListWorkflowRunArtifacts",
			OperationID:   "actions/list-workflow-run-artifacts",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"run_id":   params.RunID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunArtifactsParams
			Response = ActionsListWorkflowRunArtifactsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunArtifactsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListWorkflowRunArtifacts(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunArtifacts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListWorkflowRunsForRepoRequest handles actions/list-workflow-runs-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runs
func (s *Server) handleActionsListWorkflowRunsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsListWorkflowRunsForRepo",
			ID:   "actions/list-workflow-runs-for-repo",
		}
	)
	params, err := decodeActionsListWorkflowRunsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsListWorkflowRunsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListWorkflowRunsForRepo",
			OperationID:   "actions/list-workflow-runs-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"actor":    params.Actor,
				"branch":   params.Branch,
				"event":    params.Event,
				"status":   params.Status,
				"per_page": params.PerPage,
				"page":     params.Page,
				"created":  params.Created,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunsForRepoParams
			Response = ActionsListWorkflowRunsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsListWorkflowRunsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsReRunWorkflowRequest handles actions/re-run-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (s *Server) handleActionsReRunWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReRunWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsReRunWorkflow",
			ID:   "actions/re-run-workflow",
		}
	)
	params, err := decodeActionsReRunWorkflowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsReRunWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsReRunWorkflow",
			OperationID:   "actions/re-run-workflow",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsReRunWorkflowParams
			Response = ActionsReRunWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReRunWorkflowParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsReRunWorkflow(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsReRunWorkflow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
			ID:   "actions/remove-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/remove-repo-access-to-self-hosted-runner-group-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"repository_id":   params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveSelectedRepoFromOrgSecretRequest handles actions/remove-selected-repo-from-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsRemoveSelectedRepoFromOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelectedRepoFromOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsRemoveSelectedRepoFromOrgSecret",
			ID:   "actions/remove-selected-repo-from-org-secret",
		}
	)
	params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRemoveSelectedRepoFromOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveSelectedRepoFromOrgSecret",
			OperationID:   "actions/remove-selected-repo-from-org-secret",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"secret_name":   params.SecretName,
				"repository_id": params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelectedRepoFromOrgSecretParams
			Response = ActionsRemoveSelectedRepoFromOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelectedRepoFromOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest handles actions/remove-self-hosted-runner-from-group-for-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
			ID:   "actions/remove-self-hosted-runner-from-group-for-org",
		}
	)
	params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
			OperationID:   "actions/remove-self-hosted-runner-from-group-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
				"runner_id":       params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
			Response = ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelfHostedRunnerFromGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRetryWorkflowRequest handles actions/retry-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (s *Server) handleActionsRetryWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRetryWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsRetryWorkflow",
			ID:   "actions/retry-workflow",
		}
	)
	params, err := decodeActionsRetryWorkflowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRetryWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRetryWorkflow",
			OperationID:   "actions/retry-workflow",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRetryWorkflowParams
			Response = ActionsRetryWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRetryWorkflowParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsRetryWorkflow(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActionsRetryWorkflow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsReviewPendingDeploymentsForRunRequest handles actions/review-pending-deployments-for-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (s *Server) handleActionsReviewPendingDeploymentsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReviewPendingDeploymentsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsReviewPendingDeploymentsForRun",
			ID:   "actions/review-pending-deployments-for-run",
		}
	)
	params, err := decodeActionsReviewPendingDeploymentsForRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsReviewPendingDeploymentsForRunRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []Deployment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsReviewPendingDeploymentsForRun",
			OperationID:   "actions/review-pending-deployments-for-run",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"run_id": params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = ActionsReviewPendingDeploymentsForRunReq
			Params   = ActionsReviewPendingDeploymentsForRunParams
			Response = []Deployment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReviewPendingDeploymentsForRunParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReviewPendingDeploymentsForRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetAllowedActionsOrganizationRequest handles actions/set-allowed-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetAllowedActionsOrganization",
			ID:   "actions/set-allowed-actions-organization",
		}
	)
	params, err := decodeActionsSetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetAllowedActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetAllowedActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetAllowedActionsOrganization",
			OperationID:   "actions/set-allowed-actions-organization",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsOrganizationParams
			Response = ActionsSetAllowedActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetAllowedActionsRepositoryRequest handles actions/set-allowed-actions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetAllowedActionsRepository",
			ID:   "actions/set-allowed-actions-repository",
		}
	)
	params, err := decodeActionsSetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetAllowedActionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetAllowedActionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetAllowedActionsRepository",
			OperationID:   "actions/set-allowed-actions-repository",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsRepositoryParams
			Response = ActionsSetAllowedActionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetGithubActionsPermissionsOrganizationRequest handles actions/set-github-actions-permissions-organization operation.
//
// PUT /orgs/{org}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetGithubActionsPermissionsOrganization",
			ID:   "actions/set-github-actions-permissions-organization",
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetGithubActionsPermissionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetGithubActionsPermissionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetGithubActionsPermissionsOrganization",
			OperationID:   "actions/set-github-actions-permissions-organization",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetGithubActionsPermissionsOrganizationReq
			Params   = ActionsSetGithubActionsPermissionsOrganizationParams
			Response = ActionsSetGithubActionsPermissionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetGithubActionsPermissionsRepositoryRequest handles actions/set-github-actions-permissions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetGithubActionsPermissionsRepository",
			ID:   "actions/set-github-actions-permissions-repository",
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetGithubActionsPermissionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetGithubActionsPermissionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetGithubActionsPermissionsRepository",
			OperationID:   "actions/set-github-actions-permissions-repository",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetGithubActionsPermissionsRepositoryReq
			Params   = ActionsSetGithubActionsPermissionsRepositoryParams
			Response = ActionsSetGithubActionsPermissionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
			ID:   "actions/set-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/set-repo-access-to-self-hosted-runner-group-in-org",
			Body:          request,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
			Params   = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelectedReposForOrgSecretRequest handles actions/set-selected-repos-for-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsSetSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetSelectedReposForOrgSecret",
			ID:   "actions/set-selected-repos-for-org-secret",
		}
	)
	params, err := decodeActionsSetSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelectedReposForOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetSelectedReposForOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelectedReposForOrgSecret",
			OperationID:   "actions/set-selected-repos-for-org-secret",
			Body:          request,
			Params: map[string]any{
				"org":         params.Org,
				"secret_name": params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetSelectedReposForOrgSecretReq
			Params   = ActionsSetSelectedReposForOrgSecretParams
			Response = ActionsSetSelectedReposForOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
			ID:   "actions/set-selected-repositories-enabled-github-actions-organization",
		}
	)
	params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
			OperationID:   "actions/set-selected-repositories-enabled-github-actions-organization",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
			Params   = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelfHostedRunnersInGroupForOrgRequest handles actions/set-self-hosted-runners-in-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsSetSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsSetSelfHostedRunnersInGroupForOrg",
			ID:   "actions/set-self-hosted-runners-in-group-for-org",
		}
	)
	params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsSetSelfHostedRunnersInGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelfHostedRunnersInGroupForOrg",
			OperationID:   "actions/set-self-hosted-runners-in-group-for-org",
			Body:          request,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = ActionsSetSelfHostedRunnersInGroupForOrgReq
			Params   = ActionsSetSelfHostedRunnersInGroupForOrgParams
			Response = ActionsSetSelfHostedRunnersInGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsUpdateSelfHostedRunnerGroupForOrgRequest handles actions/update-self-hosted-runner-group-for-org operation.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsUpdateSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsUpdateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActionsUpdateSelfHostedRunnerGroupForOrg",
			ID:   "actions/update-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsUpdateSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/update-self-hosted-runner-group-for-org",
			Body:          request,
			Params: map[string]any{
				"org":             params.Org,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = ActionsUpdateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsUpdateSelfHostedRunnerGroupForOrgParams
			Response = RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsUpdateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityCheckRepoIsStarredByAuthenticatedUserRequest handles activity/check-repo-is-starred-by-authenticated-user operation.
//
// GET /user/starred/{owner}/{repo}
func (s *Server) handleActivityCheckRepoIsStarredByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityCheckRepoIsStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityCheckRepoIsStarredByAuthenticatedUser",
			ID:   "activity/check-repo-is-starred-by-authenticated-user",
		}
	)
	params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityCheckRepoIsStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityCheckRepoIsStarredByAuthenticatedUser",
			OperationID:   "activity/check-repo-is-starred-by-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityCheckRepoIsStarredByAuthenticatedUserParams
			Response = ActivityCheckRepoIsStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityCheckRepoIsStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityDeleteRepoSubscriptionRequest handles activity/delete-repo-subscription operation.
//
// DELETE /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityDeleteRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityDeleteRepoSubscription",
			ID:   "activity/delete-repo-subscription",
		}
	)
	params, err := decodeActivityDeleteRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityDeleteRepoSubscriptionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityDeleteRepoSubscription",
			OperationID:   "activity/delete-repo-subscription",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteRepoSubscriptionParams
			Response = ActivityDeleteRepoSubscriptionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityDeleteRepoSubscription(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityDeleteRepoSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityDeleteThreadSubscriptionRequest handles activity/delete-thread-subscription operation.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityDeleteThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityDeleteThreadSubscription",
			ID:   "activity/delete-thread-subscription",
		}
	)
	params, err := decodeActivityDeleteThreadSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityDeleteThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityDeleteThreadSubscription",
			OperationID:   "activity/delete-thread-subscription",
			Body:          nil,
			Params: map[string]any{
				"thread_id": params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteThreadSubscriptionParams
			Response = ActivityDeleteThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityDeleteThreadSubscription(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityDeleteThreadSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetFeedsRequest handles activity/get-feeds operation.
//
// GET /feeds
func (s *Server) handleActivityGetFeedsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetFeeds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response Feed
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetFeeds",
			OperationID:   "activity/get-feeds",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = Feed
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityGetFeeds(ctx)
			},
		)
	} else {
		response, err = s.h.ActivityGetFeeds(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetRepoSubscriptionRequest handles activity/get-repo-subscription operation.
//
// GET /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityGetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityGetRepoSubscription",
			ID:   "activity/get-repo-subscription",
		}
	)
	params, err := decodeActivityGetRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetRepoSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetRepoSubscription",
			OperationID:   "activity/get-repo-subscription",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetRepoSubscriptionParams
			Response = ActivityGetRepoSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityGetRepoSubscription(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityGetRepoSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetThreadRequest handles activity/get-thread operation.
//
// GET /notifications/threads/{thread_id}
func (s *Server) handleActivityGetThreadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThread",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityGetThread",
			ID:   "activity/get-thread",
		}
	)
	params, err := decodeActivityGetThreadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetThreadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetThread",
			OperationID:   "activity/get-thread",
			Body:          nil,
			Params: map[string]any{
				"thread_id": params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadParams
			Response = ActivityGetThreadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityGetThread(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityGetThread(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetThreadSubscriptionForAuthenticatedUserRequest handles activity/get-thread-subscription-for-authenticated-user operation.
//
// GET /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityGetThreadSubscriptionForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThreadSubscriptionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityGetThreadSubscriptionForAuthenticatedUser",
			ID:   "activity/get-thread-subscription-for-authenticated-user",
		}
	)
	params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetThreadSubscriptionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetThreadSubscriptionForAuthenticatedUser",
			OperationID:   "activity/get-thread-subscription-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"thread_id": params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadSubscriptionForAuthenticatedUserParams
			Response = ActivityGetThreadSubscriptionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadSubscriptionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListEventsForAuthenticatedUserRequest handles activity/list-events-for-authenticated-user operation.
//
// GET /users/{username}/events
func (s *Server) handleActivityListEventsForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListEventsForAuthenticatedUser",
			ID:   "activity/list-events-for-authenticated-user",
		}
	)
	params, err := decodeActivityListEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListEventsForAuthenticatedUser",
			OperationID:   "activity/list-events-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListNotificationsForAuthenticatedUserRequest handles activity/list-notifications-for-authenticated-user operation.
//
// GET /notifications
func (s *Server) handleActivityListNotificationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListNotificationsForAuthenticatedUser",
			ID:   "activity/list-notifications-for-authenticated-user",
		}
	)
	params, err := decodeActivityListNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListNotificationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListNotificationsForAuthenticatedUser",
			OperationID:   "activity/list-notifications-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"all":           params.All,
				"participating": params.Participating,
				"since":         params.Since,
				"before":        params.Before,
				"per_page":      params.PerPage,
				"page":          params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListNotificationsForAuthenticatedUserParams
			Response = ActivityListNotificationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListOrgEventsForAuthenticatedUserRequest handles activity/list-org-events-for-authenticated-user operation.
//
// GET /users/{username}/events/orgs/{org}
func (s *Server) handleActivityListOrgEventsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListOrgEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListOrgEventsForAuthenticatedUser",
			ID:   "activity/list-org-events-for-authenticated-user",
		}
	)
	params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListOrgEventsForAuthenticatedUser",
			OperationID:   "activity/list-org-events-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListOrgEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListOrgEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsRequest handles activity/list-public-events operation.
//
// GET /events
func (s *Server) handleActivityListPublicEventsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListPublicEvents",
			ID:   "activity/list-public-events",
		}
	)
	params, err := decodeActivityListPublicEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListPublicEventsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEvents",
			OperationID:   "activity/list-public-events",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsParams
			Response = ActivityListPublicEventsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListPublicEvents(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsForRepoNetworkRequest handles activity/list-public-events-for-repo-network operation.
//
// GET /networks/{owner}/{repo}/events
func (s *Server) handleActivityListPublicEventsForRepoNetworkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForRepoNetwork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListPublicEventsForRepoNetwork",
			ID:   "activity/list-public-events-for-repo-network",
		}
	)
	params, err := decodeActivityListPublicEventsForRepoNetworkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListPublicEventsForRepoNetworkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEventsForRepoNetwork",
			OperationID:   "activity/list-public-events-for-repo-network",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForRepoNetworkParams
			Response = ActivityListPublicEventsForRepoNetworkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForRepoNetworkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsForUserRequest handles activity/list-public-events-for-user operation.
//
// GET /users/{username}/events/public
func (s *Server) handleActivityListPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListPublicEventsForUser",
			ID:   "activity/list-public-events-for-user",
		}
	)
	params, err := decodeActivityListPublicEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEventsForUser",
			OperationID:   "activity/list-public-events-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListPublicEventsForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicOrgEventsRequest handles activity/list-public-org-events operation.
//
// GET /orgs/{org}/events
func (s *Server) handleActivityListPublicOrgEventsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicOrgEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListPublicOrgEvents",
			ID:   "activity/list-public-org-events",
		}
	)
	params, err := decodeActivityListPublicOrgEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicOrgEvents",
			OperationID:   "activity/list-public-org-events",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicOrgEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicOrgEventsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListPublicOrgEvents(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListPublicOrgEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReceivedEventsForUserRequest handles activity/list-received-events-for-user operation.
//
// GET /users/{username}/received_events
func (s *Server) handleActivityListReceivedEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListReceivedEventsForUser",
			ID:   "activity/list-received-events-for-user",
		}
	)
	params, err := decodeActivityListReceivedEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReceivedEventsForUser",
			OperationID:   "activity/list-received-events-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListReceivedEventsForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReceivedPublicEventsForUserRequest handles activity/list-received-public-events-for-user operation.
//
// GET /users/{username}/received_events/public
func (s *Server) handleActivityListReceivedPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListReceivedPublicEventsForUser",
			ID:   "activity/list-received-public-events-for-user",
		}
	)
	params, err := decodeActivityListReceivedPublicEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReceivedPublicEventsForUser",
			OperationID:   "activity/list-received-public-events-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListRepoEventsRequest handles activity/list-repo-events operation.
//
// GET /repos/{owner}/{repo}/events
func (s *Server) handleActivityListRepoEventsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListRepoEvents",
			ID:   "activity/list-repo-events",
		}
	)
	params, err := decodeActivityListRepoEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListRepoEvents",
			OperationID:   "activity/list-repo-events",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoEventsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListRepoEvents(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListRepoEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListRepoNotificationsForAuthenticatedUserRequest handles activity/list-repo-notifications-for-authenticated-user operation.
//
// GET /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityListRepoNotificationsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListRepoNotificationsForAuthenticatedUser",
			ID:   "activity/list-repo-notifications-for-authenticated-user",
		}
	)
	params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListRepoNotificationsForAuthenticatedUser",
			OperationID:   "activity/list-repo-notifications-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"all":           params.All,
				"participating": params.Participating,
				"since":         params.Since,
				"before":        params.Before,
				"per_page":      params.PerPage,
				"page":          params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoNotificationsForAuthenticatedUserParams
			Response = ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReposStarredByAuthenticatedUserRequest handles activity/list-repos-starred-by-authenticated-user operation.
//
// GET /user/starred
func (s *Server) handleActivityListReposStarredByAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListReposStarredByAuthenticatedUser",
			ID:   "activity/list-repos-starred-by-authenticated-user",
		}
	)
	params, err := decodeActivityListReposStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListReposStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReposStarredByAuthenticatedUser",
			OperationID:   "activity/list-repos-starred-by-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposStarredByAuthenticatedUserParams
			Response = ActivityListReposStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReposWatchedByUserRequest handles activity/list-repos-watched-by-user operation.
//
// GET /users/{username}/subscriptions
func (s *Server) handleActivityListReposWatchedByUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposWatchedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListReposWatchedByUser",
			ID:   "activity/list-repos-watched-by-user",
		}
	)
	params, err := decodeActivityListReposWatchedByUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListReposWatchedByUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReposWatchedByUser",
			OperationID:   "activity/list-repos-watched-by-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposWatchedByUserParams
			Response = ActivityListReposWatchedByUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposWatchedByUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListReposWatchedByUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListReposWatchedByUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListWatchedReposForAuthenticatedUserRequest handles activity/list-watched-repos-for-authenticated-user operation.
//
// GET /user/subscriptions
func (s *Server) handleActivityListWatchedReposForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchedReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListWatchedReposForAuthenticatedUser",
			ID:   "activity/list-watched-repos-for-authenticated-user",
		}
	)
	params, err := decodeActivityListWatchedReposForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListWatchedReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListWatchedReposForAuthenticatedUser",
			OperationID:   "activity/list-watched-repos-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchedReposForAuthenticatedUserParams
			Response = ActivityListWatchedReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchedReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListWatchersForRepoRequest handles activity/list-watchers-for-repo operation.
//
// GET /repos/{owner}/{repo}/subscribers
func (s *Server) handleActivityListWatchersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityListWatchersForRepo",
			ID:   "activity/list-watchers-for-repo",
		}
	)
	params, err := decodeActivityListWatchersForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListWatchersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListWatchersForRepo",
			OperationID:   "activity/list-watchers-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchersForRepoParams
			Response = ActivityListWatchersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchersForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityListWatchersForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityListWatchersForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkNotificationsAsReadRequest handles activity/mark-notifications-as-read operation.
//
// PUT /notifications
func (s *Server) handleActivityMarkNotificationsAsReadRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityMarkNotificationsAsRead",
			ID:   "activity/mark-notifications-as-read",
		}
	)
	request, close, err := s.decodeActivityMarkNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkNotificationsAsRead",
			OperationID:   "activity/mark-notifications-as-read",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptActivityMarkNotificationsAsReadReq
			Params   = struct{}
			Response = ActivityMarkNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityMarkNotificationsAsRead(ctx, request)
			},
		)
	} else {
		response, err = s.h.ActivityMarkNotificationsAsRead(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkRepoNotificationsAsReadRequest handles activity/mark-repo-notifications-as-read operation.
//
// PUT /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityMarkRepoNotificationsAsReadRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkRepoNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityMarkRepoNotificationsAsRead",
			ID:   "activity/mark-repo-notifications-as-read",
		}
	)
	params, err := decodeActivityMarkRepoNotificationsAsReadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivityMarkRepoNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkRepoNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkRepoNotificationsAsRead",
			OperationID:   "activity/mark-repo-notifications-as-read",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivityMarkRepoNotificationsAsReadReq
			Params   = ActivityMarkRepoNotificationsAsReadParams
			Response = ActivityMarkRepoNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkRepoNotificationsAsReadParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkThreadAsReadRequest handles activity/mark-thread-as-read operation.
//
// PATCH /notifications/threads/{thread_id}
func (s *Server) handleActivityMarkThreadAsReadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkThreadAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityMarkThreadAsRead",
			ID:   "activity/mark-thread-as-read",
		}
	)
	params, err := decodeActivityMarkThreadAsReadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityMarkThreadAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkThreadAsRead",
			OperationID:   "activity/mark-thread-as-read",
			Body:          nil,
			Params: map[string]any{
				"thread_id": params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityMarkThreadAsReadParams
			Response = ActivityMarkThreadAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkThreadAsReadParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityMarkThreadAsRead(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityMarkThreadAsRead(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivitySetRepoSubscriptionRequest handles activity/set-repo-subscription operation.
//
// PUT /repos/{owner}/{repo}/subscription
func (s *Server) handleActivitySetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivitySetRepoSubscription",
			ID:   "activity/set-repo-subscription",
		}
	)
	params, err := decodeActivitySetRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivitySetRepoSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RepositorySubscription
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivitySetRepoSubscription",
			OperationID:   "activity/set-repo-subscription",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetRepoSubscriptionReq
			Params   = ActivitySetRepoSubscriptionParams
			Response = RepositorySubscription
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivitySetRepoSubscription(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActivitySetRepoSubscription(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivitySetThreadSubscriptionRequest handles activity/set-thread-subscription operation.
//
// PUT /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivitySetThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivitySetThreadSubscription",
			ID:   "activity/set-thread-subscription",
		}
	)
	params, err := decodeActivitySetThreadSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivitySetThreadSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivitySetThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivitySetThreadSubscription",
			OperationID:   "activity/set-thread-subscription",
			Body:          request,
			Params: map[string]any{
				"thread_id": params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetThreadSubscriptionReq
			Params   = ActivitySetThreadSubscriptionParams
			Response = ActivitySetThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivitySetThreadSubscription(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ActivitySetThreadSubscription(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityStarRepoForAuthenticatedUserRequest handles activity/star-repo-for-authenticated-user operation.
//
// PUT /user/starred/{owner}/{repo}
func (s *Server) handleActivityStarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityStarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityStarRepoForAuthenticatedUser",
			ID:   "activity/star-repo-for-authenticated-user",
		}
	)
	params, err := decodeActivityStarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityStarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityStarRepoForAuthenticatedUser",
			OperationID:   "activity/star-repo-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityStarRepoForAuthenticatedUserParams
			Response = ActivityStarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityStarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityUnstarRepoForAuthenticatedUserRequest handles activity/unstar-repo-for-authenticated-user operation.
//
// DELETE /user/starred/{owner}/{repo}
func (s *Server) handleActivityUnstarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityUnstarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ActivityUnstarRepoForAuthenticatedUser",
			ID:   "activity/unstar-repo-for-authenticated-user",
		}
	)
	params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityUnstarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityUnstarRepoForAuthenticatedUser",
			OperationID:   "activity/unstar-repo-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityUnstarRepoForAuthenticatedUserParams
			Response = ActivityUnstarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityUnstarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsAddRepoToInstallationRequest handles apps/add-repo-to-installation operation.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsAddRepoToInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsAddRepoToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsAddRepoToInstallation",
			ID:   "apps/add-repo-to-installation",
		}
	)
	params, err := decodeAppsAddRepoToInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsAddRepoToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsAddRepoToInstallation",
			OperationID:   "apps/add-repo-to-installation",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
				"repository_id":   params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsAddRepoToInstallationParams
			Response = AppsAddRepoToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsAddRepoToInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsAddRepoToInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsAddRepoToInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCheckTokenRequest handles apps/check-token operation.
//
// POST /applications/{client_id}/token
func (s *Server) handleAppsCheckTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCheckToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsCheckToken",
			ID:   "apps/check-token",
		}
	)
	params, err := decodeAppsCheckTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCheckTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCheckTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCheckToken",
			OperationID:   "apps/check-token",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = AppsCheckTokenReq
			Params   = AppsCheckTokenParams
			Response = AppsCheckTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCheckTokenParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsCheckToken(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsCheckToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCheckTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateContentAttachmentRequest handles apps/create-content-attachment operation.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (s *Server) handleAppsCreateContentAttachmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateContentAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsCreateContentAttachment",
			ID:   "apps/create-content-attachment",
		}
	)
	params, err := decodeAppsCreateContentAttachmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateContentAttachmentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateContentAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateContentAttachment",
			OperationID:   "apps/create-content-attachment",
			Body:          request,
			Params: map[string]any{
				"owner":                params.Owner,
				"repo":                 params.Repo,
				"content_reference_id": params.ContentReferenceID,
			},
			Raw: r,
		}

		type (
			Request  = AppsCreateContentAttachmentReq
			Params   = AppsCreateContentAttachmentParams
			Response = AppsCreateContentAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateContentAttachmentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsCreateContentAttachment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsCreateContentAttachment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateContentAttachmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateFromManifestRequest handles apps/create-from-manifest operation.
//
// POST /app-manifests/{code}/conversions
func (s *Server) handleAppsCreateFromManifestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-from-manifest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateFromManifest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsCreateFromManifest",
			ID:   "apps/create-from-manifest",
		}
	)
	params, err := decodeAppsCreateFromManifestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateFromManifestRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateFromManifestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateFromManifest",
			OperationID:   "apps/create-from-manifest",
			Body:          request,
			Params: map[string]any{
				"code": params.Code,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCreateFromManifestReq
			Params   = AppsCreateFromManifestParams
			Response = AppsCreateFromManifestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateFromManifestParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsCreateFromManifest(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsCreateFromManifest(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateFromManifestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateInstallationAccessTokenRequest handles apps/create-installation-access-token operation.
//
// POST /app/installations/{installation_id}/access_tokens
func (s *Server) handleAppsCreateInstallationAccessTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsCreateInstallationAccessToken",
			ID:   "apps/create-installation-access-token",
		}
	)
	params, err := decodeAppsCreateInstallationAccessTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateInstallationAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateInstallationAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateInstallationAccessToken",
			OperationID:   "apps/create-installation-access-token",
			Body:          request,
			Params: map[string]any{
				"installation_id": params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = OptAppsCreateInstallationAccessTokenReq
			Params   = AppsCreateInstallationAccessTokenParams
			Response = AppsCreateInstallationAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateInstallationAccessTokenParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsCreateInstallationAccessToken(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsCreateInstallationAccessToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateInstallationAccessTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteAuthorizationRequest handles apps/delete-authorization operation.
//
// DELETE /applications/{client_id}/grant
func (s *Server) handleAppsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsDeleteAuthorization",
			ID:   "apps/delete-authorization",
		}
	)
	params, err := decodeAppsDeleteAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsDeleteAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteAuthorization",
			OperationID:   "apps/delete-authorization",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = AppsDeleteAuthorizationReq
			Params   = AppsDeleteAuthorizationParams
			Response = AppsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsDeleteAuthorization(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsDeleteAuthorization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteInstallationRequest handles apps/delete-installation operation.
//
// DELETE /app/installations/{installation_id}
func (s *Server) handleAppsDeleteInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsDeleteInstallation",
			ID:   "apps/delete-installation",
		}
	)
	params, err := decodeAppsDeleteInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsDeleteInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteInstallation",
			OperationID:   "apps/delete-installation",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsDeleteInstallationParams
			Response = AppsDeleteInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsDeleteInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsDeleteInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteTokenRequest handles apps/delete-token operation.
//
// DELETE /applications/{client_id}/token
func (s *Server) handleAppsDeleteTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsDeleteToken",
			ID:   "apps/delete-token",
		}
	)
	params, err := decodeAppsDeleteTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsDeleteTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteToken",
			OperationID:   "apps/delete-token",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = AppsDeleteTokenReq
			Params   = AppsDeleteTokenParams
			Response = AppsDeleteTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteTokenParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsDeleteToken(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsDeleteToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetAuthenticatedRequest handles apps/get-authenticated operation.
//
// GET /app
func (s *Server) handleAppsGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response Integration
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetAuthenticated",
			OperationID:   "apps/get-authenticated",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = Integration
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetAuthenticated(ctx)
			},
		)
	} else {
		response, err = s.h.AppsGetAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetBySlugRequest handles apps/get-by-slug operation.
//
// GET /apps/{app_slug}
func (s *Server) handleAppsGetBySlugRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetBySlug",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsGetBySlug",
			ID:   "apps/get-by-slug",
		}
	)
	params, err := decodeAppsGetBySlugParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetBySlugRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetBySlug",
			OperationID:   "apps/get-by-slug",
			Body:          nil,
			Params: map[string]any{
				"app_slug": params.AppSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetBySlugParams
			Response = AppsGetBySlugRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetBySlugParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetBySlug(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsGetBySlug(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountRequest handles apps/get-subscription-plan-for-account operation.
//
// GET /marketplace_listing/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsGetSubscriptionPlanForAccount",
			ID:   "apps/get-subscription-plan-for-account",
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetSubscriptionPlanForAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetSubscriptionPlanForAccount",
			OperationID:   "apps/get-subscription-plan-for-account",
			Body:          nil,
			Params: map[string]any{
				"account_id": params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountParams
			Response = AppsGetSubscriptionPlanForAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountStubbedRequest handles apps/get-subscription-plan-for-account-stubbed operation.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccountStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsGetSubscriptionPlanForAccountStubbed",
			ID:   "apps/get-subscription-plan-for-account-stubbed",
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetSubscriptionPlanForAccountStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetSubscriptionPlanForAccountStubbed",
			OperationID:   "apps/get-subscription-plan-for-account-stubbed",
			Body:          nil,
			Params: map[string]any{
				"account_id": params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountStubbedParams
			Response = AppsGetSubscriptionPlanForAccountStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountStubbedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetWebhookConfigForAppRequest handles apps/get-webhook-config-for-app operation.
//
// GET /app/hook/config
func (s *Server) handleAppsGetWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetWebhookConfigForApp",
			OperationID:   "apps/get-webhook-config-for-app",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetWebhookConfigForApp(ctx)
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookConfigForApp(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetWebhookDeliveryRequest handles apps/get-webhook-delivery operation.
//
// GET /app/hook/deliveries/{delivery_id}
func (s *Server) handleAppsGetWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsGetWebhookDelivery",
			ID:   "apps/get-webhook-delivery",
		}
	)
	params, err := decodeAppsGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetWebhookDelivery",
			OperationID:   "apps/get-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetWebhookDeliveryParams
			Response = AppsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsGetWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListAccountsForPlanRequest handles apps/list-accounts-for-plan operation.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlan",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListAccountsForPlan",
			ID:   "apps/list-accounts-for-plan",
		}
	)
	params, err := decodeAppsListAccountsForPlanParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListAccountsForPlanRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListAccountsForPlan",
			OperationID:   "apps/list-accounts-for-plan",
			Body:          nil,
			Params: map[string]any{
				"plan_id":   params.PlanID,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanParams
			Response = AppsListAccountsForPlanRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListAccountsForPlan(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlan(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListAccountsForPlanStubbedRequest handles apps/list-accounts-for-plan-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlanStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListAccountsForPlanStubbed",
			ID:   "apps/list-accounts-for-plan-stubbed",
		}
	)
	params, err := decodeAppsListAccountsForPlanStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListAccountsForPlanStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListAccountsForPlanStubbed",
			OperationID:   "apps/list-accounts-for-plan-stubbed",
			Body:          nil,
			Params: map[string]any{
				"plan_id":   params.PlanID,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanStubbedParams
			Response = AppsListAccountsForPlanStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanStubbedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListAccountsForPlanStubbed(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlanStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListInstallationReposForAuthenticatedUserRequest handles apps/list-installation-repos-for-authenticated-user operation.
//
// GET /user/installations/{installation_id}/repositories
func (s *Server) handleAppsListInstallationReposForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListInstallationReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListInstallationReposForAuthenticatedUser",
			ID:   "apps/list-installation-repos-for-authenticated-user",
		}
	)
	params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListInstallationReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListInstallationReposForAuthenticatedUser",
			OperationID:   "apps/list-installation-repos-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
				"per_page":        params.PerPage,
				"page":            params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListInstallationReposForAuthenticatedUserParams
			Response = AppsListInstallationReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListInstallationReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListPlansRequest handles apps/list-plans operation.
//
// GET /marketplace_listing/plans
func (s *Server) handleAppsListPlansRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlans",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListPlans",
			ID:   "apps/list-plans",
		}
	)
	params, err := decodeAppsListPlansParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListPlansRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListPlans",
			OperationID:   "apps/list-plans",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansParams
			Response = AppsListPlansRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListPlans(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListPlans(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListPlansStubbedRequest handles apps/list-plans-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans
func (s *Server) handleAppsListPlansStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlansStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListPlansStubbed",
			ID:   "apps/list-plans-stubbed",
		}
	)
	params, err := decodeAppsListPlansStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListPlansStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListPlansStubbed",
			OperationID:   "apps/list-plans-stubbed",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansStubbedParams
			Response = AppsListPlansStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansStubbedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListPlansStubbed(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListPlansStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListReposAccessibleToInstallationRequest handles apps/list-repos-accessible-to-installation operation.
//
// GET /installation/repositories
func (s *Server) handleAppsListReposAccessibleToInstallationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListReposAccessibleToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListReposAccessibleToInstallation",
			ID:   "apps/list-repos-accessible-to-installation",
		}
	)
	params, err := decodeAppsListReposAccessibleToInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListReposAccessibleToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListReposAccessibleToInstallation",
			OperationID:   "apps/list-repos-accessible-to-installation",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListReposAccessibleToInstallationParams
			Response = AppsListReposAccessibleToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListReposAccessibleToInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListReposAccessibleToInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListReposAccessibleToInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserRequest handles apps/list-subscriptions-for-authenticated-user operation.
//
// GET /user/marketplace_purchases
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListSubscriptionsForAuthenticatedUser",
			ID:   "apps/list-subscriptions-for-authenticated-user",
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListSubscriptionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListSubscriptionsForAuthenticatedUser",
			OperationID:   "apps/list-subscriptions-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserParams
			Response = AppsListSubscriptionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest handles apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// GET /user/marketplace_purchases/stubbed
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUserStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListSubscriptionsForAuthenticatedUserStubbed",
			ID:   "apps/list-subscriptions-for-authenticated-user-stubbed",
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListSubscriptionsForAuthenticatedUserStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListSubscriptionsForAuthenticatedUserStubbed",
			OperationID:   "apps/list-subscriptions-for-authenticated-user-stubbed",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserStubbedParams
			Response = AppsListSubscriptionsForAuthenticatedUserStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserStubbedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListWebhookDeliveriesRequest handles apps/list-webhook-deliveries operation.
//
// GET /app/hook/deliveries
func (s *Server) handleAppsListWebhookDeliveriesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsListWebhookDeliveries",
			ID:   "apps/list-webhook-deliveries",
		}
	)
	params, err := decodeAppsListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListWebhookDeliveries",
			OperationID:   "apps/list-webhook-deliveries",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"cursor":   params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListWebhookDeliveriesParams
			Response = AppsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsListWebhookDeliveries(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRedeliverWebhookDeliveryRequest handles apps/redeliver-webhook-delivery operation.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (s *Server) handleAppsRedeliverWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsRedeliverWebhookDelivery",
			ID:   "apps/redeliver-webhook-delivery",
		}
	)
	params, err := decodeAppsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRedeliverWebhookDelivery",
			OperationID:   "apps/redeliver-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRedeliverWebhookDeliveryParams
			Response = AppsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsRedeliverWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRemoveRepoFromInstallationRequest handles apps/remove-repo-from-installation operation.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsRemoveRepoFromInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRemoveRepoFromInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsRemoveRepoFromInstallation",
			ID:   "apps/remove-repo-from-installation",
		}
	)
	params, err := decodeAppsRemoveRepoFromInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsRemoveRepoFromInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRemoveRepoFromInstallation",
			OperationID:   "apps/remove-repo-from-installation",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
				"repository_id":   params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRemoveRepoFromInstallationParams
			Response = AppsRemoveRepoFromInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRemoveRepoFromInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsRemoveRepoFromInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsRemoveRepoFromInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsResetTokenRequest handles apps/reset-token operation.
//
// PATCH /applications/{client_id}/token
func (s *Server) handleAppsResetTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsResetToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsResetToken",
			ID:   "apps/reset-token",
		}
	)
	params, err := decodeAppsResetTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsResetTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsResetTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsResetToken",
			OperationID:   "apps/reset-token",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = AppsResetTokenReq
			Params   = AppsResetTokenParams
			Response = AppsResetTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsResetTokenParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsResetToken(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsResetToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsResetTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRevokeInstallationAccessTokenRequest handles apps/revoke-installation-access-token operation.
//
// DELETE /installation/token
func (s *Server) handleAppsRevokeInstallationAccessTokenRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRevokeInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response AppsRevokeInstallationAccessTokenNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRevokeInstallationAccessToken",
			OperationID:   "apps/revoke-installation-access-token",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = AppsRevokeInstallationAccessTokenNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsRevokeInstallationAccessToken(ctx)
			},
		)
	} else {
		response, err = s.h.AppsRevokeInstallationAccessToken(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsScopeTokenRequest handles apps/scope-token operation.
//
// POST /applications/{client_id}/token/scoped
func (s *Server) handleAppsScopeTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsScopeToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsScopeToken",
			ID:   "apps/scope-token",
		}
	)
	params, err := decodeAppsScopeTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsScopeTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsScopeTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsScopeToken",
			OperationID:   "apps/scope-token",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = AppsScopeTokenReq
			Params   = AppsScopeTokenParams
			Response = AppsScopeTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsScopeTokenParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsScopeToken(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.AppsScopeToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsScopeTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsSuspendInstallationRequest handles apps/suspend-installation operation.
//
// PUT /app/installations/{installation_id}/suspended
func (s *Server) handleAppsSuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsSuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsSuspendInstallation",
			ID:   "apps/suspend-installation",
		}
	)
	params, err := decodeAppsSuspendInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsSuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsSuspendInstallation",
			OperationID:   "apps/suspend-installation",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsSuspendInstallationParams
			Response = AppsSuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsSuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsSuspendInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsSuspendInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsUnsuspendInstallationRequest handles apps/unsuspend-installation operation.
//
// DELETE /app/installations/{installation_id}/suspended
func (s *Server) handleAppsUnsuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUnsuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsUnsuspendInstallation",
			ID:   "apps/unsuspend-installation",
		}
	)
	params, err := decodeAppsUnsuspendInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsUnsuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsUnsuspendInstallation",
			OperationID:   "apps/unsuspend-installation",
			Body:          nil,
			Params: map[string]any{
				"installation_id": params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsUnsuspendInstallationParams
			Response = AppsUnsuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsUnsuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsUnsuspendInstallation(ctx, params)
			},
		)
	} else {
		response, err = s.h.AppsUnsuspendInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsUpdateWebhookConfigForAppRequest handles apps/update-webhook-config-for-app operation.
//
// PATCH /app/hook/config
func (s *Server) handleAppsUpdateWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUpdateWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AppsUpdateWebhookConfigForApp",
			ID:   "apps/update-webhook-config-for-app",
		}
	)
	request, close, err := s.decodeAppsUpdateWebhookConfigForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsUpdateWebhookConfigForApp",
			OperationID:   "apps/update-webhook-config-for-app",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptAppsUpdateWebhookConfigForAppReq
			Params   = struct{}
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.AppsUpdateWebhookConfigForApp(ctx, request)
			},
		)
	} else {
		response, err = s.h.AppsUpdateWebhookConfigForApp(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingGheRequest handles billing/get-github-actions-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubActionsBillingGhe",
			ID:   "billing/get-github-actions-billing-ghe",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingGhe",
			OperationID:   "billing/get-github-actions-billing-ghe",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingGheParams
			Response = ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingGheParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubActionsBillingGhe(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingOrgRequest handles billing/get-github-actions-billing-org operation.
//
// GET /orgs/{org}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubActionsBillingOrg",
			ID:   "billing/get-github-actions-billing-org",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingOrg",
			OperationID:   "billing/get-github-actions-billing-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingOrgParams
			Response = ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubActionsBillingOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingUserRequest handles billing/get-github-actions-billing-user operation.
//
// GET /users/{username}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubActionsBillingUser",
			ID:   "billing/get-github-actions-billing-user",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingUser",
			OperationID:   "billing/get-github-actions-billing-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingUserParams
			Response = ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubActionsBillingUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingGheRequest handles billing/get-github-packages-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubPackagesBillingGhe",
			ID:   "billing/get-github-packages-billing-ghe",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingGhe",
			OperationID:   "billing/get-github-packages-billing-ghe",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingGheParams
			Response = PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingGheParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingOrgRequest handles billing/get-github-packages-billing-org operation.
//
// GET /orgs/{org}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubPackagesBillingOrg",
			ID:   "billing/get-github-packages-billing-org",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingOrg",
			OperationID:   "billing/get-github-packages-billing-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingOrgParams
			Response = PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingUserRequest handles billing/get-github-packages-billing-user operation.
//
// GET /users/{username}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetGithubPackagesBillingUser",
			ID:   "billing/get-github-packages-billing-user",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingUser",
			OperationID:   "billing/get-github-packages-billing-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingUserParams
			Response = PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetGithubPackagesBillingUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingGheRequest handles billing/get-shared-storage-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetSharedStorageBillingGhe",
			ID:   "billing/get-shared-storage-billing-ghe",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingGhe",
			OperationID:   "billing/get-shared-storage-billing-ghe",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingGheParams
			Response = CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingGheParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetSharedStorageBillingGhe(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingOrgRequest handles billing/get-shared-storage-billing-org operation.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetSharedStorageBillingOrg",
			ID:   "billing/get-shared-storage-billing-org",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingOrg",
			OperationID:   "billing/get-shared-storage-billing-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingOrgParams
			Response = CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetSharedStorageBillingOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingUserRequest handles billing/get-shared-storage-billing-user operation.
//
// GET /users/{username}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "BillingGetSharedStorageBillingUser",
			ID:   "billing/get-shared-storage-billing-user",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingUser",
			OperationID:   "billing/get-shared-storage-billing-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingUserParams
			Response = CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.BillingGetSharedStorageBillingUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksCreateSuiteRequest handles checks/create-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites
func (s *Server) handleChecksCreateSuiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksCreateSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksCreateSuite",
			ID:   "checks/create-suite",
		}
	)
	params, err := decodeChecksCreateSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeChecksCreateSuiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ChecksCreateSuiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksCreateSuite",
			OperationID:   "checks/create-suite",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ChecksCreateSuiteReq
			Params   = ChecksCreateSuiteParams
			Response = ChecksCreateSuiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksCreateSuiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksCreateSuite(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ChecksCreateSuite(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksGetRequest handles checks/get operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (s *Server) handleChecksGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksGet",
			ID:   "checks/get",
		}
	)
	params, err := decodeChecksGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CheckRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksGet",
			OperationID:   "checks/get",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"check_run_id": params.CheckRunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetParams
			Response = CheckRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksGetSuiteRequest handles checks/get-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (s *Server) handleChecksGetSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGetSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksGetSuite",
			ID:   "checks/get-suite",
		}
	)
	params, err := decodeChecksGetSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CheckSuite
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksGetSuite",
			OperationID:   "checks/get-suite",
			Body:          nil,
			Params: map[string]any{
				"owner":          params.Owner,
				"repo":           params.Repo,
				"check_suite_id": params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetSuiteParams
			Response = CheckSuite
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetSuiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksGetSuite(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksGetSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListAnnotationsRequest handles checks/list-annotations operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (s *Server) handleChecksListAnnotationsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListAnnotations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksListAnnotations",
			ID:   "checks/list-annotations",
		}
	)
	params, err := decodeChecksListAnnotationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ChecksListAnnotationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListAnnotations",
			OperationID:   "checks/list-annotations",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"check_run_id": params.CheckRunID,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListAnnotationsParams
			Response = ChecksListAnnotationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListAnnotationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksListAnnotations(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksListAnnotations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListForRefRequest handles checks/list-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (s *Server) handleChecksListForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksListForRef",
			ID:   "checks/list-for-ref",
		}
	)
	params, err := decodeChecksListForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ChecksListForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListForRef",
			OperationID:   "checks/list-for-ref",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"ref":        params.Ref,
				"check_name": params.CheckName,
				"status":     params.Status,
				"filter":     params.Filter,
				"per_page":   params.PerPage,
				"page":       params.Page,
				"app_id":     params.AppID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForRefParams
			Response = ChecksListForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksListForRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksListForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListForSuiteRequest handles checks/list-for-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (s *Server) handleChecksListForSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksListForSuite",
			ID:   "checks/list-for-suite",
		}
	)
	params, err := decodeChecksListForSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ChecksListForSuiteOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListForSuite",
			OperationID:   "checks/list-for-suite",
			Body:          nil,
			Params: map[string]any{
				"owner":          params.Owner,
				"repo":           params.Repo,
				"check_suite_id": params.CheckSuiteID,
				"check_name":     params.CheckName,
				"status":         params.Status,
				"filter":         params.Filter,
				"per_page":       params.PerPage,
				"page":           params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForSuiteParams
			Response = ChecksListForSuiteOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForSuiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksListForSuite(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksListForSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListSuitesForRefRequest handles checks/list-suites-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (s *Server) handleChecksListSuitesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListSuitesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksListSuitesForRef",
			ID:   "checks/list-suites-for-ref",
		}
	)
	params, err := decodeChecksListSuitesForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ChecksListSuitesForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListSuitesForRef",
			OperationID:   "checks/list-suites-for-ref",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"ref":        params.Ref,
				"app_id":     params.AppID,
				"check_name": params.CheckName,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListSuitesForRefParams
			Response = ChecksListSuitesForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListSuitesForRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksListSuitesForRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksListSuitesForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksRerequestSuiteRequest handles checks/rerequest-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (s *Server) handleChecksRerequestSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksRerequestSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksRerequestSuite",
			ID:   "checks/rerequest-suite",
		}
	)
	params, err := decodeChecksRerequestSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ChecksRerequestSuiteCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksRerequestSuite",
			OperationID:   "checks/rerequest-suite",
			Body:          nil,
			Params: map[string]any{
				"owner":          params.Owner,
				"repo":           params.Repo,
				"check_suite_id": params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksRerequestSuiteParams
			Response = ChecksRerequestSuiteCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksRerequestSuiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksRerequestSuite(ctx, params)
			},
		)
	} else {
		response, err = s.h.ChecksRerequestSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksSetSuitesPreferencesRequest handles checks/set-suites-preferences operation.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (s *Server) handleChecksSetSuitesPreferencesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksSetSuitesPreferences",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ChecksSetSuitesPreferences",
			ID:   "checks/set-suites-preferences",
		}
	)
	params, err := decodeChecksSetSuitesPreferencesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeChecksSetSuitesPreferencesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CheckSuitePreference
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksSetSuitesPreferences",
			OperationID:   "checks/set-suites-preferences",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ChecksSetSuitesPreferencesReq
			Params   = ChecksSetSuitesPreferencesParams
			Response = CheckSuitePreference
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksSetSuitesPreferencesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ChecksSetSuitesPreferences(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ChecksSetSuitesPreferences(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningDeleteAnalysisRequest handles code-scanning/delete-analysis operation.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningDeleteAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningDeleteAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningDeleteAnalysis",
			ID:   "code-scanning/delete-analysis",
		}
	)
	params, err := decodeCodeScanningDeleteAnalysisParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningDeleteAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningDeleteAnalysis",
			OperationID:   "code-scanning/delete-analysis",
			Body:          nil,
			Params: map[string]any{
				"owner":          params.Owner,
				"repo":           params.Repo,
				"analysis_id":    params.AnalysisID,
				"confirm_delete": params.ConfirmDelete,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningDeleteAnalysisParams
			Response = CodeScanningDeleteAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningDeleteAnalysisParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningDeleteAnalysis(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningDeleteAnalysis(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetAlertRequest handles code-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningGetAlert",
			ID:   "code-scanning/get-alert",
		}
	)
	params, err := decodeCodeScanningGetAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetAlert",
			OperationID:   "code-scanning/get-alert",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"alert_number": params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAlertParams
			Response = CodeScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningGetAlert(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAlert(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetAnalysisRequest handles code-scanning/get-analysis operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningGetAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningGetAnalysis",
			ID:   "code-scanning/get-analysis",
		}
	)
	params, err := decodeCodeScanningGetAnalysisParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetAnalysis",
			OperationID:   "code-scanning/get-analysis",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"analysis_id": params.AnalysisID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAnalysisParams
			Response = CodeScanningGetAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAnalysisParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningGetAnalysis(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAnalysis(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetSarifRequest handles code-scanning/get-sarif operation.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (s *Server) handleCodeScanningGetSarifRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningGetSarif",
			ID:   "code-scanning/get-sarif",
		}
	)
	params, err := decodeCodeScanningGetSarifParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetSarif",
			OperationID:   "code-scanning/get-sarif",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"sarif_id": params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetSarifParams
			Response = CodeScanningGetSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetSarifParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningGetSarif(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningGetSarif(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListAlertInstancesRequest handles code-scanning/list-alert-instances operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (s *Server) handleCodeScanningListAlertInstancesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertInstances",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningListAlertInstances",
			ID:   "code-scanning/list-alert-instances",
		}
	)
	params, err := decodeCodeScanningListAlertInstancesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListAlertInstancesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListAlertInstances",
			OperationID:   "code-scanning/list-alert-instances",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"alert_number": params.AlertNumber,
				"page":         params.Page,
				"per_page":     params.PerPage,
				"ref":          params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertInstancesParams
			Response = CodeScanningListAlertInstancesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertInstancesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningListAlertInstances(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertInstances(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListAlertsForRepoRequest handles code-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (s *Server) handleCodeScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningListAlertsForRepo",
			ID:   "code-scanning/list-alerts-for-repo",
		}
	)
	params, err := decodeCodeScanningListAlertsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListAlertsForRepo",
			OperationID:   "code-scanning/list-alerts-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"tool_name": params.ToolName,
				"tool_guid": params.ToolGUID,
				"page":      params.Page,
				"per_page":  params.PerPage,
				"ref":       params.Ref,
				"state":     params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertsForRepoParams
			Response = CodeScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningListAlertsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListRecentAnalysesRequest handles code-scanning/list-recent-analyses operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (s *Server) handleCodeScanningListRecentAnalysesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListRecentAnalyses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningListRecentAnalyses",
			ID:   "code-scanning/list-recent-analyses",
		}
	)
	params, err := decodeCodeScanningListRecentAnalysesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListRecentAnalysesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListRecentAnalyses",
			OperationID:   "code-scanning/list-recent-analyses",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"tool_name": params.ToolName,
				"tool_guid": params.ToolGUID,
				"page":      params.Page,
				"per_page":  params.PerPage,
				"ref":       params.Ref,
				"sarif_id":  params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListRecentAnalysesParams
			Response = CodeScanningListRecentAnalysesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListRecentAnalysesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningListRecentAnalyses(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningListRecentAnalyses(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningUpdateAlertRequest handles code-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningUpdateAlert",
			ID:   "code-scanning/update-alert",
		}
	)
	params, err := decodeCodeScanningUpdateAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeCodeScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningUpdateAlert",
			OperationID:   "code-scanning/update-alert",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"alert_number": params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = CodeScanningUpdateAlertReq
			Params   = CodeScanningUpdateAlertParams
			Response = CodeScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningUpdateAlert(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningUploadSarifRequest handles code-scanning/upload-sarif operation.
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (s *Server) handleCodeScanningUploadSarifRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUploadSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodeScanningUploadSarif",
			ID:   "code-scanning/upload-sarif",
		}
	)
	params, err := decodeCodeScanningUploadSarifParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeCodeScanningUploadSarifRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUploadSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningUploadSarif",
			OperationID:   "code-scanning/upload-sarif",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = CodeScanningUploadSarifReq
			Params   = CodeScanningUploadSarifParams
			Response = CodeScanningUploadSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUploadSarifParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodeScanningUploadSarif(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.CodeScanningUploadSarif(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodesOfConductGetAllCodesOfConductRequest handles codes-of-conduct/get-all-codes-of-conduct operation.
//
// GET /codes_of_conduct
func (s *Server) handleCodesOfConductGetAllCodesOfConductRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetAllCodesOfConduct",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response CodesOfConductGetAllCodesOfConductRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodesOfConductGetAllCodesOfConduct",
			OperationID:   "codes-of-conduct/get-all-codes-of-conduct",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = CodesOfConductGetAllCodesOfConductRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodesOfConductGetAllCodesOfConduct(ctx)
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetAllCodesOfConduct(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodesOfConductGetConductCodeRequest handles codes-of-conduct/get-conduct-code operation.
//
// GET /codes_of_conduct/{key}
func (s *Server) handleCodesOfConductGetConductCodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetConductCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CodesOfConductGetConductCode",
			ID:   "codes-of-conduct/get-conduct-code",
		}
	)
	params, err := decodeCodesOfConductGetConductCodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodesOfConductGetConductCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodesOfConductGetConductCode",
			OperationID:   "codes-of-conduct/get-conduct-code",
			Body:          nil,
			Params: map[string]any{
				"key": params.Key,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodesOfConductGetConductCodeParams
			Response = CodesOfConductGetConductCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodesOfConductGetConductCodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.CodesOfConductGetConductCode(ctx, params)
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetConductCode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEmojisGetRequest handles emojis/get operation.
//
// GET /emojis
func (s *Server) handleEmojisGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmojisGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response EmojisGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EmojisGet",
			OperationID:   "emojis/get",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = EmojisGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EmojisGet(ctx)
			},
		)
	} else {
		response, err = s.h.EmojisGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEmojisGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
			ID:   "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"org_id":          params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest handles enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
			ID:   "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
			OperationID:   "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"runner_id":       params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
			Response = EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest handles enterprise-admin/create-registration-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (s *Server) handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRegistrationTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminCreateRegistrationTokenForEnterprise",
			ID:   "enterprise-admin/create-registration-token-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateRegistrationTokenForEnterprise",
			OperationID:   "enterprise-admin/create-registration-token-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRegistrationTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest handles enterprise-admin/create-remove-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (s *Server) handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRemoveTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminCreateRemoveTokenForEnterprise",
			ID:   "enterprise-admin/create-remove-token-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateRemoveTokenForEnterprise",
			OperationID:   "enterprise-admin/create-remove-token-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRemoveTokenForEnterpriseParams
			Response = AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRemoveTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
			ID:   "enterprise-admin/create-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/create-self-hosted-runner-group-for-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
			Response = RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest handles enterprise-admin/delete-scim-group-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteScimGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminDeleteScimGroupFromEnterprise",
			ID:   "enterprise-admin/delete-scim-group-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteScimGroupFromEnterprise",
			OperationID:   "enterprise-admin/delete-scim-group-from-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":    params.Enterprise,
				"scim_group_id": params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteScimGroupFromEnterpriseParams
			Response = EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteScimGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
			ID:   "enterprise-admin/delete-self-hosted-runner-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
			OperationID:   "enterprise-admin/delete-self-hosted-runner-from-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"runner_id":  params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
			Response = EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
			ID:   "enterprise-admin/delete-self-hosted-runner-group-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
			OperationID:   "enterprise-admin/delete-self-hosted-runner-group-from-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
			Response = EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteUserFromEnterpriseRequest handles enterprise-admin/delete-user-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteUserFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminDeleteUserFromEnterprise",
			ID:   "enterprise-admin/delete-user-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminDeleteUserFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteUserFromEnterprise",
			OperationID:   "enterprise-admin/delete-user-from-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":   params.Enterprise,
				"scim_user_id": params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteUserFromEnterpriseParams
			Response = EnterpriseAdminDeleteUserFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteUserFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
			ID:   "enterprise-admin/disable-selected-organization-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
			OperationID:   "enterprise-admin/disable-selected-organization-github-actions-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"org_id":     params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
			Response = EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
			ID:   "enterprise-admin/enable-selected-organization-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
			OperationID:   "enterprise-admin/enable-selected-organization-github-actions-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"org_id":     params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
			Response = EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetAllowedActionsEnterpriseRequest handles enterprise-admin/get-allowed-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetAllowedActionsEnterprise",
			ID:   "enterprise-admin/get-allowed-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetAllowedActionsEnterprise",
			OperationID:   "enterprise-admin/get-allowed-actions-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAllowedActionsEnterpriseParams
			Response = SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetAuditLogRequest handles enterprise-admin/get-audit-log operation.
//
// GET /enterprises/{enterprise}/audit-log
func (s *Server) handleEnterpriseAdminGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetAuditLog",
			ID:   "enterprise-admin/get-audit-log",
		}
	)
	params, err := decodeEnterpriseAdminGetAuditLogParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetAuditLog",
			OperationID:   "enterprise-admin/get-audit-log",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"phrase":     params.Phrase,
				"include":    params.Include,
				"after":      params.After,
				"before":     params.Before,
				"order":      params.Order,
				"page":       params.Page,
				"per_page":   params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetAuditLog(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAuditLog(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
			ID:   "enterprise-admin/get-github-actions-permissions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsEnterprisePermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
			OperationID:   "enterprise-admin/get-github-actions-permissions-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
			Response = ActionsEnterprisePermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest handles enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
			ID:   "enterprise-admin/get-provisioning-information-for-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
			OperationID:   "enterprise-admin/get-provisioning-information-for-enterprise-group",
			Body:          nil,
			Params: map[string]any{
				"enterprise":         params.Enterprise,
				"scim_group_id":      params.ScimGroupID,
				"excludedAttributes": params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
			Response = ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest handles enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
			ID:   "enterprise-admin/get-provisioning-information-for-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
			OperationID:   "enterprise-admin/get-provisioning-information-for-enterprise-user",
			Body:          nil,
			Params: map[string]any{
				"enterprise":   params.Enterprise,
				"scim_user_id": params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
			Response = ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
			ID:   "enterprise-admin/get-self-hosted-runner-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
			OperationID:   "enterprise-admin/get-self-hosted-runner-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"runner_id":  params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
			Response = Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
			ID:   "enterprise-admin/get-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/get-self-hosted-runner-group-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
			Response = RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
			ID:   "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"per_page":        params.PerPage,
				"page":            params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest handles enterprise-admin/list-provisioned-groups-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedGroupsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListProvisionedGroupsEnterprise",
			ID:   "enterprise-admin/list-provisioned-groups-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimGroupListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListProvisionedGroupsEnterprise",
			OperationID:   "enterprise-admin/list-provisioned-groups-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":         params.Enterprise,
				"startIndex":         params.StartIndex,
				"count":              params.Count,
				"filter":             params.Filter,
				"excludedAttributes": params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedGroupsEnterpriseParams
			Response = ScimGroupListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedGroupsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest handles enterprise-admin/list-provisioned-identities-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedIdentitiesEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListProvisionedIdentitiesEnterprise",
			ID:   "enterprise-admin/list-provisioned-identities-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimUserListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListProvisionedIdentitiesEnterprise",
			OperationID:   "enterprise-admin/list-provisioned-identities-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"startIndex": params.StartIndex,
				"count":      params.Count,
				"filter":     params.Filter,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
			Response = ScimUserListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedIdentitiesEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest handles enterprise-admin/list-runner-applications-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (s *Server) handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListRunnerApplicationsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListRunnerApplicationsForEnterprise",
			ID:   "enterprise-admin/list-runner-applications-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListRunnerApplicationsForEnterprise",
			OperationID:   "enterprise-admin/list-runner-applications-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListRunnerApplicationsForEnterpriseParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListRunnerApplicationsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
			ID:   "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
			OperationID:   "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest handles enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
			ID:   "enterprise-admin/list-self-hosted-runner-groups-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runner-groups-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
			Response = EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListSelfHostedRunnersForEnterprise",
			ID:   "enterprise-admin/list-self-hosted-runners-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnersForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runners-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise": params.Enterprise,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
			Response = EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
			ID:   "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"per_page":        params.PerPage,
				"page":            params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
			Response = EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest handles enterprise-admin/provision-and-invite-enterprise-group operation.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
			ID:   "enterprise-admin/provision-and-invite-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
			OperationID:   "enterprise-admin/provision-and-invite-enterprise-group",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
			Response = ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest handles enterprise-admin/provision-and-invite-enterprise-user operation.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminProvisionAndInviteEnterpriseUser",
			ID:   "enterprise-admin/provision-and-invite-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminProvisionAndInviteEnterpriseUser",
			OperationID:   "enterprise-admin/provision-and-invite-enterprise-user",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminProvisionAndInviteEnterpriseUserReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseUserParams
			Response = ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
			ID:   "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"org_id":          params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest handles enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
			ID:   "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
			OperationID:   "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise",
			Body:          nil,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
				"runner_id":       params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
			Response = EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetAllowedActionsEnterpriseRequest handles enterprise-admin/set-allowed-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetAllowedActionsEnterprise",
			ID:   "enterprise-admin/set-allowed-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response EnterpriseAdminSetAllowedActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetAllowedActionsEnterprise",
			OperationID:   "enterprise-admin/set-allowed-actions-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = SelectedActions
			Params   = EnterpriseAdminSetAllowedActionsEnterpriseParams
			Response = EnterpriseAdminSetAllowedActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
			ID:   "enterprise-admin/set-github-actions-permissions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
			OperationID:   "enterprise-admin/set-github-actions-permissions-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
			Params   = EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
			Response = EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest handles enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
			ID:   "enterprise-admin/set-information-for-provisioned-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
			OperationID:   "enterprise-admin/set-information-for-provisioned-enterprise-group",
			Body:          request,
			Params: map[string]any{
				"enterprise":    params.Enterprise,
				"scim_group_id": params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
			Response = ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest handles enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
			ID:   "enterprise-admin/set-information-for-provisioned-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
			OperationID:   "enterprise-admin/set-information-for-provisioned-enterprise-user",
			Body:          request,
			Params: map[string]any{
				"enterprise":   params.Enterprise,
				"scim_user_id": params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
			Response = ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
			ID:   "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
			Params   = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
			ID:   "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
			OperationID:   "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise": params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
			Params   = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
			ID:   "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
			OperationID:   "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
			Params   = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
			Response = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest handles enterprise-admin/update-attribute-for-enterprise-group operation.
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
			ID:   "enterprise-admin/update-attribute-for-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
			OperationID:   "enterprise-admin/update-attribute-for-enterprise-group",
			Body:          request,
			Params: map[string]any{
				"enterprise":    params.Enterprise,
				"scim_group_id": params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseGroupParams
			Response = ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest handles enterprise-admin/update-attribute-for-enterprise-user operation.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminUpdateAttributeForEnterpriseUser",
			ID:   "enterprise-admin/update-attribute-for-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateAttributeForEnterpriseUser",
			OperationID:   "enterprise-admin/update-attribute-for-enterprise-user",
			Body:          request,
			Params: map[string]any{
				"enterprise":   params.Enterprise,
				"scim_user_id": params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = EnterpriseAdminUpdateAttributeForEnterpriseUserReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseUserParams
			Response = ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
			ID:   "enterprise-admin/update-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/update-self-hosted-runner-group-for-enterprise",
			Body:          request,
			Params: map[string]any{
				"enterprise":      params.Enterprise,
				"runner_group_id": params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
			Response = RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCheckIsStarredRequest handles gists/check-is-starred operation.
//
// GET /gists/{gist_id}/star
func (s *Server) handleGistsCheckIsStarredRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCheckIsStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsCheckIsStarred",
			ID:   "gists/check-is-starred",
		}
	)
	params, err := decodeGistsCheckIsStarredParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsCheckIsStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCheckIsStarred",
			OperationID:   "gists/check-is-starred",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsCheckIsStarredParams
			Response = GistsCheckIsStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCheckIsStarredParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsCheckIsStarred(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsCheckIsStarred(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCreateRequest handles gists/create operation.
//
// POST /gists
func (s *Server) handleGistsCreateRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsCreate",
			ID:   "gists/create",
		}
	)
	request, close, err := s.decodeGistsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCreate",
			OperationID:   "gists/create",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = GistsCreateReq
			Params   = struct{}
			Response = GistsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsCreate(ctx, request)
			},
		)
	} else {
		response, err = s.h.GistsCreate(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCreateCommentRequest handles gists/create-comment operation.
//
// POST /gists/{gist_id}/comments
func (s *Server) handleGistsCreateCommentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsCreateComment",
			ID:   "gists/create-comment",
		}
	)
	params, err := decodeGistsCreateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGistsCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCreateComment",
			OperationID:   "gists/create-comment",
			Body:          request,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = GistsCreateCommentReq
			Params   = GistsCreateCommentParams
			Response = GistsCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsCreateComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GistsCreateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsDeleteRequest handles gists/delete operation.
//
// DELETE /gists/{gist_id}
func (s *Server) handleGistsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsDelete",
			ID:   "gists/delete",
		}
	)
	params, err := decodeGistsDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsDelete",
			OperationID:   "gists/delete",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteParams
			Response = GistsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsDelete(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsDeleteCommentRequest handles gists/delete-comment operation.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsDeleteCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsDeleteComment",
			ID:   "gists/delete-comment",
		}
	)
	params, err := decodeGistsDeleteCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsDeleteCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsDeleteComment",
			OperationID:   "gists/delete-comment",
			Body:          nil,
			Params: map[string]any{
				"gist_id":    params.GistID,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteCommentParams
			Response = GistsDeleteCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsDeleteComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsDeleteComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsForkRequest handles gists/fork operation.
//
// POST /gists/{gist_id}/forks
func (s *Server) handleGistsForkRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsFork",
			ID:   "gists/fork",
		}
	)
	params, err := decodeGistsForkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsFork",
			OperationID:   "gists/fork",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsForkParams
			Response = GistsForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsForkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsFork(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsFork(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsForkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetRequest handles gists/get operation.
//
// GET /gists/{gist_id}
func (s *Server) handleGistsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsGet",
			ID:   "gists/get",
		}
	)
	params, err := decodeGistsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGet",
			OperationID:   "gists/get",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetParams
			Response = GistsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetCommentRequest handles gists/get-comment operation.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsGetCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsGetComment",
			ID:   "gists/get-comment",
		}
	)
	params, err := decodeGistsGetCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGetComment",
			OperationID:   "gists/get-comment",
			Body:          nil,
			Params: map[string]any{
				"gist_id":    params.GistID,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetCommentParams
			Response = GistsGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsGetComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsGetComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetRevisionRequest handles gists/get-revision operation.
//
// GET /gists/{gist_id}/{sha}
func (s *Server) handleGistsGetRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsGetRevision",
			ID:   "gists/get-revision",
		}
	)
	params, err := decodeGistsGetRevisionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGetRevision",
			OperationID:   "gists/get-revision",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
				"sha":     params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetRevisionParams
			Response = GistsGetRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetRevisionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsGetRevision(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsGetRevision(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetRevisionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListRequest handles gists/list operation.
//
// GET /gists
func (s *Server) handleGistsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsList",
			ID:   "gists/list",
		}
	)
	params, err := decodeGistsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsList",
			OperationID:   "gists/list",
			Body:          nil,
			Params: map[string]any{
				"since":    params.Since,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListParams
			Response = GistsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsList(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListCommentsRequest handles gists/list-comments operation.
//
// GET /gists/{gist_id}/comments
func (s *Server) handleGistsListCommentsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListComments",
			ID:   "gists/list-comments",
		}
	)
	params, err := decodeGistsListCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListComments",
			OperationID:   "gists/list-comments",
			Body:          nil,
			Params: map[string]any{
				"gist_id":  params.GistID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommentsParams
			Response = GistsListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommentsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListComments(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListCommitsRequest handles gists/list-commits operation.
//
// GET /gists/{gist_id}/commits
func (s *Server) handleGistsListCommitsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListCommits",
			ID:   "gists/list-commits",
		}
	)
	params, err := decodeGistsListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListCommits",
			OperationID:   "gists/list-commits",
			Body:          nil,
			Params: map[string]any{
				"gist_id":  params.GistID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommitsParams
			Response = GistsListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListCommits(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListForUserRequest handles gists/list-for-user operation.
//
// GET /users/{username}/gists
func (s *Server) handleGistsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListForUser",
			ID:   "gists/list-for-user",
		}
	)
	params, err := decodeGistsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListForUser",
			OperationID:   "gists/list-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"since":    params.Since,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForUserParams
			Response = GistsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListForksRequest handles gists/list-forks operation.
//
// GET /gists/{gist_id}/forks
func (s *Server) handleGistsListForksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListForks",
			ID:   "gists/list-forks",
		}
	)
	params, err := decodeGistsListForksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListForks",
			OperationID:   "gists/list-forks",
			Body:          nil,
			Params: map[string]any{
				"gist_id":  params.GistID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForksParams
			Response = GistsListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForksParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListForks(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListForks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListPublicRequest handles gists/list-public operation.
//
// GET /gists/public
func (s *Server) handleGistsListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListPublic",
			ID:   "gists/list-public",
		}
	)
	params, err := decodeGistsListPublicParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListPublic",
			OperationID:   "gists/list-public",
			Body:          nil,
			Params: map[string]any{
				"since":    params.Since,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListPublicParams
			Response = GistsListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListPublicParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListPublic(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListPublic(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListPublicResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListStarredRequest handles gists/list-starred operation.
//
// GET /gists/starred
func (s *Server) handleGistsListStarredRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsListStarred",
			ID:   "gists/list-starred",
		}
	)
	params, err := decodeGistsListStarredParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListStarred",
			OperationID:   "gists/list-starred",
			Body:          nil,
			Params: map[string]any{
				"since":    params.Since,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListStarredParams
			Response = GistsListStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListStarredParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsListStarred(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsListStarred(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListStarredResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsStarRequest handles gists/star operation.
//
// PUT /gists/{gist_id}/star
func (s *Server) handleGistsStarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsStar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsStar",
			ID:   "gists/star",
		}
	)
	params, err := decodeGistsStarParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsStarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsStar",
			OperationID:   "gists/star",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsStarParams
			Response = GistsStarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsStarParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsStar(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsStar(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsStarResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsUnstarRequest handles gists/unstar operation.
//
// DELETE /gists/{gist_id}/star
func (s *Server) handleGistsUnstarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUnstar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsUnstar",
			ID:   "gists/unstar",
		}
	)
	params, err := decodeGistsUnstarParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsUnstarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsUnstar",
			OperationID:   "gists/unstar",
			Body:          nil,
			Params: map[string]any{
				"gist_id": params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsUnstarParams
			Response = GistsUnstarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUnstarParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsUnstar(ctx, params)
			},
		)
	} else {
		response, err = s.h.GistsUnstar(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUnstarResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsUpdateCommentRequest handles gists/update-comment operation.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsUpdateCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GistsUpdateComment",
			ID:   "gists/update-comment",
		}
	)
	params, err := decodeGistsUpdateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGistsUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsUpdateComment",
			OperationID:   "gists/update-comment",
			Body:          request,
			Params: map[string]any{
				"gist_id":    params.GistID,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = GistsUpdateCommentReq
			Params   = GistsUpdateCommentParams
			Response = GistsUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GistsUpdateComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GistsUpdateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateBlobRequest handles git/create-blob operation.
//
// POST /repos/{owner}/{repo}/git/blobs
func (s *Server) handleGitCreateBlobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitCreateBlob",
			ID:   "git/create-blob",
		}
	)
	params, err := decodeGitCreateBlobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateBlobRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateBlob",
			OperationID:   "git/create-blob",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = GitCreateBlobReq
			Params   = GitCreateBlobParams
			Response = GitCreateBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateBlobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitCreateBlob(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitCreateBlob(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateBlobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateCommitRequest handles git/create-commit operation.
//
// POST /repos/{owner}/{repo}/git/commits
func (s *Server) handleGitCreateCommitRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitCreateCommit",
			ID:   "git/create-commit",
		}
	)
	params, err := decodeGitCreateCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateCommitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateCommit",
			OperationID:   "git/create-commit",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = GitCreateCommitReq
			Params   = GitCreateCommitParams
			Response = GitCreateCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitCreateCommit(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitCreateCommit(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateRefRequest handles git/create-ref operation.
//
// POST /repos/{owner}/{repo}/git/refs
func (s *Server) handleGitCreateRefRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitCreateRef",
			ID:   "git/create-ref",
		}
	)
	params, err := decodeGitCreateRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateRef",
			OperationID:   "git/create-ref",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = GitCreateRefReq
			Params   = GitCreateRefParams
			Response = GitCreateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitCreateRef(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitCreateRef(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateTagRequest handles git/create-tag operation.
//
// POST /repos/{owner}/{repo}/git/tags
func (s *Server) handleGitCreateTagRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitCreateTag",
			ID:   "git/create-tag",
		}
	)
	params, err := decodeGitCreateTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateTagRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateTag",
			OperationID:   "git/create-tag",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = GitCreateTagReq
			Params   = GitCreateTagParams
			Response = GitCreateTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTagParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitCreateTag(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitCreateTag(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateTreeRequest handles git/create-tree operation.
//
// POST /repos/{owner}/{repo}/git/trees
func (s *Server) handleGitCreateTreeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitCreateTree",
			ID:   "git/create-tree",
		}
	)
	params, err := decodeGitCreateTreeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateTreeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateTree",
			OperationID:   "git/create-tree",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = GitCreateTreeReq
			Params   = GitCreateTreeParams
			Response = GitCreateTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTreeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitCreateTree(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitCreateTree(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTreeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitDeleteRefRequest handles git/delete-ref operation.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitDeleteRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitDeleteRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitDeleteRef",
			ID:   "git/delete-ref",
		}
	)
	params, err := decodeGitDeleteRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitDeleteRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitDeleteRef",
			OperationID:   "git/delete-ref",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitDeleteRefParams
			Response = GitDeleteRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitDeleteRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitDeleteRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitDeleteRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitDeleteRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetBlobRequest handles git/get-blob operation.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (s *Server) handleGitGetBlobRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitGetBlob",
			ID:   "git/get-blob",
		}
	)
	params, err := decodeGitGetBlobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetBlob",
			OperationID:   "git/get-blob",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"file_sha": params.FileSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetBlobParams
			Response = GitGetBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetBlobParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitGetBlob(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitGetBlob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetBlobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetCommitRequest handles git/get-commit operation.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (s *Server) handleGitGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitGetCommit",
			ID:   "git/get-commit",
		}
	)
	params, err := decodeGitGetCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetCommit",
			OperationID:   "git/get-commit",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"commit_sha": params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetCommitParams
			Response = GitGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitGetCommit(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitGetCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetRefRequest handles git/get-ref operation.
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (s *Server) handleGitGetRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitGetRef",
			ID:   "git/get-ref",
		}
	)
	params, err := decodeGitGetRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetRef",
			OperationID:   "git/get-ref",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetRefParams
			Response = GitGetRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitGetRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitGetRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetTagRequest handles git/get-tag operation.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (s *Server) handleGitGetTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitGetTag",
			ID:   "git/get-tag",
		}
	)
	params, err := decodeGitGetTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetTag",
			OperationID:   "git/get-tag",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"tag_sha": params.TagSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTagParams
			Response = GitGetTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTagParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitGetTag(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitGetTag(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetTreeRequest handles git/get-tree operation.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (s *Server) handleGitGetTreeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitGetTree",
			ID:   "git/get-tree",
		}
	)
	params, err := decodeGitGetTreeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetTree",
			OperationID:   "git/get-tree",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"tree_sha":  params.TreeSha,
				"recursive": params.Recursive,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTreeParams
			Response = GitGetTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTreeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitGetTree(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitGetTree(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTreeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitListMatchingRefsRequest handles git/list-matching-refs operation.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (s *Server) handleGitListMatchingRefsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitListMatchingRefs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitListMatchingRefs",
			ID:   "git/list-matching-refs",
		}
	)
	params, err := decodeGitListMatchingRefsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitListMatchingRefsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitListMatchingRefs",
			OperationID:   "git/list-matching-refs",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"ref":      params.Ref,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitListMatchingRefsParams
			Response = GitListMatchingRefsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitListMatchingRefsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitListMatchingRefs(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitListMatchingRefs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitUpdateRefRequest handles git/update-ref operation.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitUpdateRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitUpdateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitUpdateRef",
			ID:   "git/update-ref",
		}
	)
	params, err := decodeGitUpdateRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitUpdateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitUpdateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitUpdateRef",
			OperationID:   "git/update-ref",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = GitUpdateRefReq
			Params   = GitUpdateRefParams
			Response = GitUpdateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitUpdateRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitUpdateRef(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.GitUpdateRef(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitUpdateRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitignoreGetAllTemplatesRequest handles gitignore/get-all-templates operation.
//
// GET /gitignore/templates
func (s *Server) handleGitignoreGetAllTemplatesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetAllTemplates",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response GitignoreGetAllTemplatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitignoreGetAllTemplates",
			OperationID:   "gitignore/get-all-templates",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GitignoreGetAllTemplatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitignoreGetAllTemplates(ctx)
			},
		)
	} else {
		response, err = s.h.GitignoreGetAllTemplates(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitignoreGetTemplateRequest handles gitignore/get-template operation.
//
// GET /gitignore/templates/{name}
func (s *Server) handleGitignoreGetTemplateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GitignoreGetTemplate",
			ID:   "gitignore/get-template",
		}
	)
	params, err := decodeGitignoreGetTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitignoreGetTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitignoreGetTemplate",
			OperationID:   "gitignore/get-template",
			Body:          nil,
			Params: map[string]any{
				"name": params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitignoreGetTemplateParams
			Response = GitignoreGetTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitignoreGetTemplateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.GitignoreGetTemplate(ctx, params)
			},
		)
	} else {
		response, err = s.h.GitignoreGetTemplate(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest handles interactions/remove-restrictions-for-authenticated-user operation.
//
// DELETE /user/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForAuthenticatedUser",
			OperationID:   "interactions/remove-restrictions-for-authenticated-user",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
			},
		)
	} else {
		response, err = s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForOrgRequest handles interactions/remove-restrictions-for-org operation.
//
// DELETE /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InteractionsRemoveRestrictionsForOrg",
			ID:   "interactions/remove-restrictions-for-org",
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response InteractionsRemoveRestrictionsForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForOrg",
			OperationID:   "interactions/remove-restrictions-for-org",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForOrgParams
			Response = InteractionsRemoveRestrictionsForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForRepoRequest handles interactions/remove-restrictions-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InteractionsRemoveRestrictionsForRepo",
			ID:   "interactions/remove-restrictions-for-repo",
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response InteractionsRemoveRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForRepo",
			OperationID:   "interactions/remove-restrictions-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForRepoParams
			Response = InteractionsRemoveRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForAuthenticatedUserRequest handles interactions/set-restrictions-for-authenticated-user operation.
//
// PUT /user/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InteractionsSetRestrictionsForAuthenticatedUser",
			ID:   "interactions/set-restrictions-for-authenticated-user",
		}
	)
	request, close, err := s.decodeInteractionsSetRestrictionsForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForAuthenticatedUser",
			OperationID:   "interactions/set-restrictions-for-authenticated-user",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = InteractionLimit
			Params   = struct{}
			Response = InteractionsSetRestrictionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForOrgRequest handles interactions/set-restrictions-for-org operation.
//
// PUT /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InteractionsSetRestrictionsForOrg",
			ID:   "interactions/set-restrictions-for-org",
		}
	)
	params, err := decodeInteractionsSetRestrictionsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeInteractionsSetRestrictionsForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForOrg",
			OperationID:   "interactions/set-restrictions-for-org",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = InteractionLimit
			Params   = InteractionsSetRestrictionsForOrgParams
			Response = InteractionsSetRestrictionsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForRepoRequest handles interactions/set-restrictions-for-repo operation.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "InteractionsSetRestrictionsForRepo",
			ID:   "interactions/set-restrictions-for-repo",
		}
	)
	params, err := decodeInteractionsSetRestrictionsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeInteractionsSetRestrictionsForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForRepo",
			OperationID:   "interactions/set-restrictions-for-repo",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = InteractionLimit
			Params   = InteractionsSetRestrictionsForRepoParams
			Response = InteractionsSetRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesAddAssigneesRequest handles issues/add-assignees operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesAddAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesAddAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesAddAssignees",
			ID:   "issues/add-assignees",
		}
	)
	params, err := decodeIssuesAddAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesAddAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesAddAssignees",
			OperationID:   "issues/add-assignees",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesAddAssigneesReq
			Params   = IssuesAddAssigneesParams
			Response = IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesAddAssigneesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesAddAssignees(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesAddAssignees(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCheckUserCanBeAssignedRequest handles issues/check-user-can-be-assigned operation.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (s *Server) handleIssuesCheckUserCanBeAssignedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCheckUserCanBeAssigned",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesCheckUserCanBeAssigned",
			ID:   "issues/check-user-can-be-assigned",
		}
	)
	params, err := decodeIssuesCheckUserCanBeAssignedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesCheckUserCanBeAssignedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCheckUserCanBeAssigned",
			OperationID:   "issues/check-user-can-be-assigned",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"assignee": params.Assignee,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesCheckUserCanBeAssignedParams
			Response = IssuesCheckUserCanBeAssignedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCheckUserCanBeAssignedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesCheckUserCanBeAssigned(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesCheckUserCanBeAssigned(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateRequest handles issues/create operation.
//
// POST /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesCreate",
			ID:   "issues/create",
		}
	)
	params, err := decodeIssuesCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreate",
			OperationID:   "issues/create",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = IssuesCreateReq
			Params   = IssuesCreateParams
			Response = IssuesCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesCreate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateCommentRequest handles issues/create-comment operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesCreateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesCreateComment",
			ID:   "issues/create-comment",
		}
	)
	params, err := decodeIssuesCreateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateComment",
			OperationID:   "issues/create-comment",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = IssuesCreateCommentReq
			Params   = IssuesCreateCommentParams
			Response = IssuesCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesCreateComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesCreateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateLabelRequest handles issues/create-label operation.
//
// POST /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesCreateLabelRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesCreateLabel",
			ID:   "issues/create-label",
		}
	)
	params, err := decodeIssuesCreateLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateLabel",
			OperationID:   "issues/create-label",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = IssuesCreateLabelReq
			Params   = IssuesCreateLabelParams
			Response = IssuesCreateLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateLabelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesCreateLabel(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesCreateLabel(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateMilestoneRequest handles issues/create-milestone operation.
//
// POST /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesCreateMilestoneRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesCreateMilestone",
			ID:   "issues/create-milestone",
		}
	)
	params, err := decodeIssuesCreateMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateMilestone",
			OperationID:   "issues/create-milestone",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = IssuesCreateMilestoneReq
			Params   = IssuesCreateMilestoneParams
			Response = IssuesCreateMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesCreateMilestone(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesCreateMilestone(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteCommentRequest handles issues/delete-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesDeleteCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesDeleteComment",
			ID:   "issues/delete-comment",
		}
	)
	params, err := decodeIssuesDeleteCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesDeleteCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteComment",
			OperationID:   "issues/delete-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteCommentParams
			Response = IssuesDeleteCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesDeleteComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesDeleteComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteLabelRequest handles issues/delete-label operation.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesDeleteLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesDeleteLabel",
			ID:   "issues/delete-label",
		}
	)
	params, err := decodeIssuesDeleteLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesDeleteLabelNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteLabel",
			OperationID:   "issues/delete-label",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"name":  params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteLabelParams
			Response = IssuesDeleteLabelNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteLabelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesDeleteLabel(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesDeleteLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteMilestoneRequest handles issues/delete-milestone operation.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesDeleteMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesDeleteMilestone",
			ID:   "issues/delete-milestone",
		}
	)
	params, err := decodeIssuesDeleteMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesDeleteMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteMilestone",
			OperationID:   "issues/delete-milestone",
			Body:          nil,
			Params: map[string]any{
				"owner":            params.Owner,
				"repo":             params.Repo,
				"milestone_number": params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteMilestoneParams
			Response = IssuesDeleteMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteMilestoneParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesDeleteMilestone(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesDeleteMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetRequest handles issues/get operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesGet",
			ID:   "issues/get",
		}
	)
	params, err := decodeIssuesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGet",
			OperationID:   "issues/get",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetParams
			Response = IssuesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetCommentRequest handles issues/get-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesGetCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesGetComment",
			ID:   "issues/get-comment",
		}
	)
	params, err := decodeIssuesGetCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetComment",
			OperationID:   "issues/get-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetCommentParams
			Response = IssuesGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesGetComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesGetComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetEventRequest handles issues/get-event operation.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (s *Server) handleIssuesGetEventRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesGetEvent",
			ID:   "issues/get-event",
		}
	)
	params, err := decodeIssuesGetEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetEvent",
			OperationID:   "issues/get-event",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"event_id": params.EventID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetEventParams
			Response = IssuesGetEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesGetEvent(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesGetEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetLabelRequest handles issues/get-label operation.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesGetLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesGetLabel",
			ID:   "issues/get-label",
		}
	)
	params, err := decodeIssuesGetLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetLabel",
			OperationID:   "issues/get-label",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"name":  params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetLabelParams
			Response = IssuesGetLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetLabelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesGetLabel(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesGetLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetMilestoneRequest handles issues/get-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesGetMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesGetMilestone",
			ID:   "issues/get-milestone",
		}
	)
	params, err := decodeIssuesGetMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetMilestone",
			OperationID:   "issues/get-milestone",
			Body:          nil,
			Params: map[string]any{
				"owner":            params.Owner,
				"repo":             params.Repo,
				"milestone_number": params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetMilestoneParams
			Response = IssuesGetMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetMilestoneParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesGetMilestone(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesGetMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListRequest handles issues/list operation.
//
// GET /issues
func (s *Server) handleIssuesListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesList",
			ID:   "issues/list",
		}
	)
	params, err := decodeIssuesListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesList",
			OperationID:   "issues/list",
			Body:          nil,
			Params: map[string]any{
				"filter":    params.Filter,
				"state":     params.State,
				"labels":    params.Labels,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"collab":    params.Collab,
				"orgs":      params.Orgs,
				"owned":     params.Owned,
				"pulls":     params.Pulls,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListParams
			Response = IssuesListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesList(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListAssigneesRequest handles issues/list-assignees operation.
//
// GET /repos/{owner}/{repo}/assignees
func (s *Server) handleIssuesListAssigneesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListAssignees",
			ID:   "issues/list-assignees",
		}
	)
	params, err := decodeIssuesListAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListAssigneesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListAssignees",
			OperationID:   "issues/list-assignees",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListAssigneesParams
			Response = IssuesListAssigneesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListAssigneesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListAssignees(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListAssignees(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListCommentsRequest handles issues/list-comments operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesListCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListComments",
			ID:   "issues/list-comments",
		}
	)
	params, err := decodeIssuesListCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListComments",
			OperationID:   "issues/list-comments",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
				"since":        params.Since,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsParams
			Response = IssuesListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListComments(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListCommentsForRepoRequest handles issues/list-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues/comments
func (s *Server) handleIssuesListCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListCommentsForRepo",
			ID:   "issues/list-comments-for-repo",
		}
	)
	params, err := decodeIssuesListCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListCommentsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListCommentsForRepo",
			OperationID:   "issues/list-comments-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsForRepoParams
			Response = IssuesListCommentsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListCommentsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListEventsForRepoRequest handles issues/list-events-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues/events
func (s *Server) handleIssuesListEventsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListEventsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListEventsForRepo",
			ID:   "issues/list-events-for-repo",
		}
	)
	params, err := decodeIssuesListEventsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListEventsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListEventsForRepo",
			OperationID:   "issues/list-events-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListEventsForRepoParams
			Response = IssuesListEventsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListEventsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListEventsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListEventsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListEventsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForAuthenticatedUserRequest handles issues/list-for-authenticated-user operation.
//
// GET /user/issues
func (s *Server) handleIssuesListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListForAuthenticatedUser",
			ID:   "issues/list-for-authenticated-user",
		}
	)
	params, err := decodeIssuesListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForAuthenticatedUser",
			OperationID:   "issues/list-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"filter":    params.Filter,
				"state":     params.State,
				"labels":    params.Labels,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForAuthenticatedUserParams
			Response = IssuesListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForOrgRequest handles issues/list-for-org operation.
//
// GET /orgs/{org}/issues
func (s *Server) handleIssuesListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListForOrg",
			ID:   "issues/list-for-org",
		}
	)
	params, err := decodeIssuesListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForOrg",
			OperationID:   "issues/list-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"filter":    params.Filter,
				"state":     params.State,
				"labels":    params.Labels,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForOrgParams
			Response = IssuesListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForRepoRequest handles issues/list-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListForRepo",
			ID:   "issues/list-for-repo",
		}
	)
	params, err := decodeIssuesListForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForRepo",
			OperationID:   "issues/list-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"milestone": params.Milestone,
				"state":     params.State,
				"assignee":  params.Assignee,
				"creator":   params.Creator,
				"mentioned": params.Mentioned,
				"labels":    params.Labels,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForRepoParams
			Response = IssuesListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsForMilestoneRequest handles issues/list-labels-for-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (s *Server) handleIssuesListLabelsForMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListLabelsForMilestone",
			ID:   "issues/list-labels-for-milestone",
		}
	)
	params, err := decodeIssuesListLabelsForMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListLabelsForMilestoneOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsForMilestone",
			OperationID:   "issues/list-labels-for-milestone",
			Body:          nil,
			Params: map[string]any{
				"owner":            params.Owner,
				"repo":             params.Repo,
				"milestone_number": params.MilestoneNumber,
				"per_page":         params.PerPage,
				"page":             params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForMilestoneParams
			Response = IssuesListLabelsForMilestoneOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForMilestoneParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListLabelsForMilestone(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsForRepoRequest handles issues/list-labels-for-repo operation.
//
// GET /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesListLabelsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListLabelsForRepo",
			ID:   "issues/list-labels-for-repo",
		}
	)
	params, err := decodeIssuesListLabelsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListLabelsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsForRepo",
			OperationID:   "issues/list-labels-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForRepoParams
			Response = IssuesListLabelsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListLabelsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsOnIssueRequest handles issues/list-labels-on-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesListLabelsOnIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsOnIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListLabelsOnIssue",
			ID:   "issues/list-labels-on-issue",
		}
	)
	params, err := decodeIssuesListLabelsOnIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListLabelsOnIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsOnIssue",
			OperationID:   "issues/list-labels-on-issue",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsOnIssueParams
			Response = IssuesListLabelsOnIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsOnIssueParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListLabelsOnIssue(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsOnIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListMilestonesRequest handles issues/list-milestones operation.
//
// GET /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesListMilestonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListMilestones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesListMilestones",
			ID:   "issues/list-milestones",
		}
	)
	params, err := decodeIssuesListMilestonesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListMilestonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListMilestones",
			OperationID:   "issues/list-milestones",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"state":     params.State,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListMilestonesParams
			Response = IssuesListMilestonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListMilestonesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesListMilestones(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesListMilestones(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesLockRequest handles issues/lock operation.
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesLockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesLock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesLock",
			ID:   "issues/lock",
		}
	)
	params, err := decodeIssuesLockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesLockRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesLockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesLock",
			OperationID:   "issues/lock",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilIssuesLockReq
			Params   = IssuesLockParams
			Response = IssuesLockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesLockParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesLock(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesLock(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesLockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveAllLabelsRequest handles issues/remove-all-labels operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesRemoveAllLabelsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAllLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesRemoveAllLabels",
			ID:   "issues/remove-all-labels",
		}
	)
	params, err := decodeIssuesRemoveAllLabelsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesRemoveAllLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveAllLabels",
			OperationID:   "issues/remove-all-labels",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveAllLabelsParams
			Response = IssuesRemoveAllLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAllLabelsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesRemoveAllLabels(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAllLabels(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveAssigneesRequest handles issues/remove-assignees operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesRemoveAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesRemoveAssignees",
			ID:   "issues/remove-assignees",
		}
	)
	params, err := decodeIssuesRemoveAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesRemoveAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveAssignees",
			OperationID:   "issues/remove-assignees",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesRemoveAssigneesReq
			Params   = IssuesRemoveAssigneesParams
			Response = IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAssigneesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesRemoveAssignees(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAssignees(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveLabelRequest handles issues/remove-label operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (s *Server) handleIssuesRemoveLabelRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesRemoveLabel",
			ID:   "issues/remove-label",
		}
	)
	params, err := decodeIssuesRemoveLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesRemoveLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveLabel",
			OperationID:   "issues/remove-label",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
				"name":         params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveLabelParams
			Response = IssuesRemoveLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveLabelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesRemoveLabel(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesRemoveLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUnlockRequest handles issues/unlock operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesUnlockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUnlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesUnlock",
			ID:   "issues/unlock",
		}
	)
	params, err := decodeIssuesUnlockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesUnlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUnlock",
			OperationID:   "issues/unlock",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesUnlockParams
			Response = IssuesUnlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUnlockParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesUnlock(ctx, params)
			},
		)
	} else {
		response, err = s.h.IssuesUnlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateRequest handles issues/update operation.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesUpdate",
			ID:   "issues/update",
		}
	)
	params, err := decodeIssuesUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdate",
			OperationID:   "issues/update",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateReq
			Params   = IssuesUpdateParams
			Response = IssuesUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesUpdate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateCommentRequest handles issues/update-comment operation.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesUpdateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesUpdateComment",
			ID:   "issues/update-comment",
		}
	)
	params, err := decodeIssuesUpdateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateComment",
			OperationID:   "issues/update-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = IssuesUpdateCommentReq
			Params   = IssuesUpdateCommentParams
			Response = IssuesUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesUpdateComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesUpdateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateLabelRequest handles issues/update-label operation.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesUpdateLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesUpdateLabel",
			ID:   "issues/update-label",
		}
	)
	params, err := decodeIssuesUpdateLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Label
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateLabel",
			OperationID:   "issues/update-label",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"name":  params.Name,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateLabelReq
			Params   = IssuesUpdateLabelParams
			Response = Label
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateLabelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesUpdateLabel(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesUpdateLabel(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateMilestoneRequest handles issues/update-milestone operation.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesUpdateMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "IssuesUpdateMilestone",
			ID:   "issues/update-milestone",
		}
	)
	params, err := decodeIssuesUpdateMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Milestone
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateMilestone",
			OperationID:   "issues/update-milestone",
			Body:          request,
			Params: map[string]any{
				"owner":            params.Owner,
				"repo":             params.Repo,
				"milestone_number": params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateMilestoneReq
			Params   = IssuesUpdateMilestoneParams
			Response = Milestone
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.IssuesUpdateMilestone(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.IssuesUpdateMilestone(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetRequest handles licenses/get operation.
//
// GET /licenses/{license}
func (s *Server) handleLicensesGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LicensesGet",
			ID:   "licenses/get",
		}
	)
	params, err := decodeLicensesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicensesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGet",
			OperationID:   "licenses/get",
			Body:          nil,
			Params: map[string]any{
				"license": params.License,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetParams
			Response = LicensesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.LicensesGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.LicensesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetAllCommonlyUsedRequest handles licenses/get-all-commonly-used operation.
//
// GET /licenses
func (s *Server) handleLicensesGetAllCommonlyUsedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetAllCommonlyUsed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LicensesGetAllCommonlyUsed",
			ID:   "licenses/get-all-commonly-used",
		}
	)
	params, err := decodeLicensesGetAllCommonlyUsedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicensesGetAllCommonlyUsedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGetAllCommonlyUsed",
			OperationID:   "licenses/get-all-commonly-used",
			Body:          nil,
			Params: map[string]any{
				"featured": params.Featured,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetAllCommonlyUsedParams
			Response = LicensesGetAllCommonlyUsedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetAllCommonlyUsedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.LicensesGetAllCommonlyUsed(ctx, params)
			},
		)
	} else {
		response, err = s.h.LicensesGetAllCommonlyUsed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetForRepoRequest handles licenses/get-for-repo operation.
//
// GET /repos/{owner}/{repo}/license
func (s *Server) handleLicensesGetForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LicensesGetForRepo",
			ID:   "licenses/get-for-repo",
		}
	)
	params, err := decodeLicensesGetForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicenseContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGetForRepo",
			OperationID:   "licenses/get-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetForRepoParams
			Response = LicenseContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.LicensesGetForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.LicensesGetForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaGetRequest handles meta/get operation.
//
// GET /meta
func (s *Server) handleMetaGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response MetaGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaGet",
			OperationID:   "meta/get",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MetaGet(ctx)
			},
		)
	} else {
		response, err = s.h.MetaGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaGetZenRequest handles meta/get-zen operation.
//
// GET /zen
func (s *Server) handleMetaGetZenRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-zen"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGetZen",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response MetaGetZenOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaGetZen",
			OperationID:   "meta/get-zen",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetZenOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MetaGetZen(ctx)
			},
		)
	} else {
		response, err = s.h.MetaGetZen(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetZenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaRootRequest handles meta/root operation.
//
// GET /
func (s *Server) handleMetaRootRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaRoot",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response MetaRootOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaRoot",
			OperationID:   "meta/root",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaRootOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MetaRoot(ctx)
			},
		)
	} else {
		response, err = s.h.MetaRoot(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaRootResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsCancelImportRequest handles migrations/cancel-import operation.
//
// DELETE /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsCancelImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsCancelImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsCancelImport",
			ID:   "migrations/cancel-import",
		}
	)
	params, err := decodeMigrationsCancelImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsCancelImportNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsCancelImport",
			OperationID:   "migrations/cancel-import",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsCancelImportParams
			Response = MigrationsCancelImportNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsCancelImportParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsCancelImport(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsCancelImport(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDeleteArchiveForAuthenticatedUserRequest handles migrations/delete-archive-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsDeleteArchiveForAuthenticatedUser",
			ID:   "migrations/delete-archive-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDeleteArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDeleteArchiveForAuthenticatedUser",
			OperationID:   "migrations/delete-archive-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"migration_id": params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForAuthenticatedUserParams
			Response = MigrationsDeleteArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDeleteArchiveForOrgRequest handles migrations/delete-archive-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsDeleteArchiveForOrg",
			ID:   "migrations/delete-archive-for-org",
		}
	)
	params, err := decodeMigrationsDeleteArchiveForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDeleteArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDeleteArchiveForOrg",
			OperationID:   "migrations/delete-archive-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"migration_id": params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForOrgParams
			Response = MigrationsDeleteArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsDeleteArchiveForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDownloadArchiveForOrgRequest handles migrations/download-archive-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDownloadArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDownloadArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsDownloadArchiveForOrg",
			ID:   "migrations/download-archive-for-org",
		}
	)
	params, err := decodeMigrationsDownloadArchiveForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDownloadArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDownloadArchiveForOrg",
			OperationID:   "migrations/download-archive-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"migration_id": params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDownloadArchiveForOrgParams
			Response = MigrationsDownloadArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDownloadArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsDownloadArchiveForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsDownloadArchiveForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetArchiveForAuthenticatedUserRequest handles migrations/get-archive-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsGetArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetArchiveForAuthenticatedUser",
			ID:   "migrations/get-archive-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetArchiveForAuthenticatedUser",
			OperationID:   "migrations/get-archive-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"migration_id": params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetArchiveForAuthenticatedUserParams
			Response = MigrationsGetArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetCommitAuthorsRequest handles migrations/get-commit-authors operation.
//
// GET /repos/{owner}/{repo}/import/authors
func (s *Server) handleMigrationsGetCommitAuthorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetCommitAuthors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetCommitAuthors",
			ID:   "migrations/get-commit-authors",
		}
	)
	params, err := decodeMigrationsGetCommitAuthorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetCommitAuthorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetCommitAuthors",
			OperationID:   "migrations/get-commit-authors",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"since": params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetCommitAuthorsParams
			Response = MigrationsGetCommitAuthorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetCommitAuthorsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetCommitAuthors(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetCommitAuthors(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetImportStatusRequest handles migrations/get-import-status operation.
//
// GET /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsGetImportStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetImportStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetImportStatus",
			ID:   "migrations/get-import-status",
		}
	)
	params, err := decodeMigrationsGetImportStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetImportStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetImportStatus",
			OperationID:   "migrations/get-import-status",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetImportStatusParams
			Response = MigrationsGetImportStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetImportStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetImportStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetImportStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetLargeFilesRequest handles migrations/get-large-files operation.
//
// GET /repos/{owner}/{repo}/import/large_files
func (s *Server) handleMigrationsGetLargeFilesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetLargeFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetLargeFiles",
			ID:   "migrations/get-large-files",
		}
	)
	params, err := decodeMigrationsGetLargeFilesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []PorterLargeFile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetLargeFiles",
			OperationID:   "migrations/get-large-files",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetLargeFilesParams
			Response = []PorterLargeFile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetLargeFilesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetLargeFiles(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetLargeFiles(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetStatusForAuthenticatedUserRequest handles migrations/get-status-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetStatusForAuthenticatedUser",
			ID:   "migrations/get-status-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetStatusForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetStatusForAuthenticatedUser",
			OperationID:   "migrations/get-status-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"migration_id": params.MigrationID,
				"exclude":      params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForAuthenticatedUserParams
			Response = MigrationsGetStatusForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetStatusForOrgRequest handles migrations/get-status-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsGetStatusForOrg",
			ID:   "migrations/get-status-for-org",
		}
	)
	params, err := decodeMigrationsGetStatusForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetStatusForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetStatusForOrg",
			OperationID:   "migrations/get-status-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"migration_id": params.MigrationID,
				"exclude":      params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForOrgParams
			Response = MigrationsGetStatusForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsGetStatusForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListForAuthenticatedUserRequest handles migrations/list-for-authenticated-user operation.
//
// GET /user/migrations
func (s *Server) handleMigrationsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsListForAuthenticatedUser",
			ID:   "migrations/list-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListForAuthenticatedUser",
			OperationID:   "migrations/list-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForAuthenticatedUserParams
			Response = MigrationsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsListForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListForOrgRequest handles migrations/list-for-org operation.
//
// GET /orgs/{org}/migrations
func (s *Server) handleMigrationsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsListForOrg",
			ID:   "migrations/list-for-org",
		}
	)
	params, err := decodeMigrationsListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListForOrg",
			OperationID:   "migrations/list-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
				"exclude":  params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForOrgParams
			Response = MigrationsListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsListForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListReposForOrgRequest handles migrations/list-repos-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsListReposForOrg",
			ID:   "migrations/list-repos-for-org",
		}
	)
	params, err := decodeMigrationsListReposForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListReposForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListReposForOrg",
			OperationID:   "migrations/list-repos-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"migration_id": params.MigrationID,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForOrgParams
			Response = MigrationsListReposForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsListReposForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListReposForUserRequest handles migrations/list-repos-for-user operation.
//
// GET /user/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsListReposForUser",
			ID:   "migrations/list-repos-for-user",
		}
	)
	params, err := decodeMigrationsListReposForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListReposForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListReposForUser",
			OperationID:   "migrations/list-repos-for-user",
			Body:          nil,
			Params: map[string]any{
				"migration_id": params.MigrationID,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForUserParams
			Response = MigrationsListReposForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsListReposForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsMapCommitAuthorRequest handles migrations/map-commit-author operation.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (s *Server) handleMigrationsMapCommitAuthorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsMapCommitAuthor",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsMapCommitAuthor",
			ID:   "migrations/map-commit-author",
		}
	)
	params, err := decodeMigrationsMapCommitAuthorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsMapCommitAuthorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsMapCommitAuthorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsMapCommitAuthor",
			OperationID:   "migrations/map-commit-author",
			Body:          request,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"author_id": params.AuthorID,
			},
			Raw: r,
		}

		type (
			Request  = OptMigrationsMapCommitAuthorReq
			Params   = MigrationsMapCommitAuthorParams
			Response = MigrationsMapCommitAuthorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsMapCommitAuthorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsMapCommitAuthor(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.MigrationsMapCommitAuthor(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsMapCommitAuthorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsSetLfsPreferenceRequest handles migrations/set-lfs-preference operation.
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (s *Server) handleMigrationsSetLfsPreferenceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsSetLfsPreference",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsSetLfsPreference",
			ID:   "migrations/set-lfs-preference",
		}
	)
	params, err := decodeMigrationsSetLfsPreferenceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsSetLfsPreferenceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsSetLfsPreferenceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsSetLfsPreference",
			OperationID:   "migrations/set-lfs-preference",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = MigrationsSetLfsPreferenceReq
			Params   = MigrationsSetLfsPreferenceParams
			Response = MigrationsSetLfsPreferenceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsSetLfsPreferenceParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsSetLfsPreference(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.MigrationsSetLfsPreference(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsSetLfsPreferenceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartForAuthenticatedUserRequest handles migrations/start-for-authenticated-user operation.
//
// POST /user/migrations
func (s *Server) handleMigrationsStartForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsStartForAuthenticatedUser",
			ID:   "migrations/start-for-authenticated-user",
		}
	)
	request, close, err := s.decodeMigrationsStartForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartForAuthenticatedUser",
			OperationID:   "migrations/start-for-authenticated-user",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = MigrationsStartForAuthenticatedUserReq
			Params   = struct{}
			Response = MigrationsStartForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsStartForAuthenticatedUser(ctx, request)
			},
		)
	} else {
		response, err = s.h.MigrationsStartForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartForOrgRequest handles migrations/start-for-org operation.
//
// POST /orgs/{org}/migrations
func (s *Server) handleMigrationsStartForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsStartForOrg",
			ID:   "migrations/start-for-org",
		}
	)
	params, err := decodeMigrationsStartForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsStartForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartForOrg",
			OperationID:   "migrations/start-for-org",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = MigrationsStartForOrgReq
			Params   = MigrationsStartForOrgParams
			Response = MigrationsStartForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsStartForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.MigrationsStartForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartImportRequest handles migrations/start-import operation.
//
// PUT /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsStartImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsStartImport",
			ID:   "migrations/start-import",
		}
	)
	params, err := decodeMigrationsStartImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsStartImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartImportRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartImport",
			OperationID:   "migrations/start-import",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = MigrationsStartImportReq
			Params   = MigrationsStartImportParams
			Response = MigrationsStartImportRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartImportParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsStartImport(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.MigrationsStartImport(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUnlockRepoForAuthenticatedUserRequest handles migrations/unlock-repo-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsUnlockRepoForAuthenticatedUser",
			ID:   "migrations/unlock-repo-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsUnlockRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUnlockRepoForAuthenticatedUser",
			OperationID:   "migrations/unlock-repo-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"migration_id": params.MigrationID,
				"repo_name":    params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForAuthenticatedUserParams
			Response = MigrationsUnlockRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUnlockRepoForOrgRequest handles migrations/unlock-repo-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsUnlockRepoForOrg",
			ID:   "migrations/unlock-repo-for-org",
		}
	)
	params, err := decodeMigrationsUnlockRepoForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsUnlockRepoForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUnlockRepoForOrg",
			OperationID:   "migrations/unlock-repo-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"migration_id": params.MigrationID,
				"repo_name":    params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForOrgParams
			Response = MigrationsUnlockRepoForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsUnlockRepoForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUpdateImportRequest handles migrations/update-import operation.
//
// PATCH /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsUpdateImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUpdateImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "MigrationsUpdateImport",
			ID:   "migrations/update-import",
		}
	)
	params, err := decodeMigrationsUpdateImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsUpdateImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Import
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUpdateImport",
			OperationID:   "migrations/update-import",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilMigrationsUpdateImportReq
			Params   = MigrationsUpdateImportParams
			Response = Import
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUpdateImportParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.MigrationsUpdateImport(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.MigrationsUpdateImport(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsCreateAuthorizationRequest handles oauth-authorizations/create-authorization operation.
//
// POST /authorizations
func (s *Server) handleOAuthAuthorizationsCreateAuthorizationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsCreateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsCreateAuthorization",
			ID:   "oauth-authorizations/create-authorization",
		}
	)
	request, close, err := s.decodeOAuthAuthorizationsCreateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsCreateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsCreateAuthorization",
			OperationID:   "oauth-authorizations/create-authorization",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptOAuthAuthorizationsCreateAuthorizationReq
			Params   = struct{}
			Response = OAuthAuthorizationsCreateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsCreateAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsDeleteAuthorizationRequest handles oauth-authorizations/delete-authorization operation.
//
// DELETE /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsDeleteAuthorization",
			ID:   "oauth-authorizations/delete-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsDeleteAuthorization",
			OperationID:   "oauth-authorizations/delete-authorization",
			Body:          nil,
			Params: map[string]any{
				"authorization_id": params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteAuthorizationParams
			Response = OAuthAuthorizationsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsDeleteGrantRequest handles oauth-authorizations/delete-grant operation.
//
// DELETE /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsDeleteGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsDeleteGrant",
			ID:   "oauth-authorizations/delete-grant",
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteGrantParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsDeleteGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsDeleteGrant",
			OperationID:   "oauth-authorizations/delete-grant",
			Body:          nil,
			Params: map[string]any{
				"grant_id": params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteGrantParams
			Response = OAuthAuthorizationsDeleteGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteGrantParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetAuthorizationRequest handles oauth-authorizations/get-authorization operation.
//
// GET /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsGetAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsGetAuthorization",
			ID:   "oauth-authorizations/get-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsGetAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsGetAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetAuthorization",
			OperationID:   "oauth-authorizations/get-authorization",
			Body:          nil,
			Params: map[string]any{
				"authorization_id": params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetAuthorizationParams
			Response = OAuthAuthorizationsGetAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetGrantRequest handles oauth-authorizations/get-grant operation.
//
// GET /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsGetGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsGetGrant",
			ID:   "oauth-authorizations/get-grant",
		}
	)
	params, err := decodeOAuthAuthorizationsGetGrantParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsGetGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetGrant",
			OperationID:   "oauth-authorizations/get-grant",
			Body:          nil,
			Params: map[string]any{
				"grant_id": params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetGrantParams
			Response = OAuthAuthorizationsGetGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetGrantParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsGetGrant(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetGrant(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest handles oauth-authorizations/get-or-create-authorization-for-app operation.
//
// PUT /authorizations/clients/{client_id}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
			ID:   "oauth-authorizations/get-or-create-authorization-for-app",
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
			OperationID:   "oauth-authorizations/get-or-create-authorization-for-app",
			Body:          request,
			Params: map[string]any{
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = OAuthAuthorizationsGetOrCreateAuthorizationForAppReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest handles oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
			ID:   "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
			OperationID:   "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
			Body:          request,
			Params: map[string]any{
				"client_id":   params.ClientID,
				"fingerprint": params.Fingerprint,
			},
			Raw: r,
		}

		type (
			Request  = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsListAuthorizationsRequest handles oauth-authorizations/list-authorizations operation.
//
// GET /authorizations
func (s *Server) handleOAuthAuthorizationsListAuthorizationsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsListAuthorizations",
			ID:   "oauth-authorizations/list-authorizations",
		}
	)
	params, err := decodeOAuthAuthorizationsListAuthorizationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsListAuthorizationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsListAuthorizations",
			OperationID:   "oauth-authorizations/list-authorizations",
			Body:          nil,
			Params: map[string]any{
				"per_page":  params.PerPage,
				"page":      params.Page,
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListAuthorizationsParams
			Response = OAuthAuthorizationsListAuthorizationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsListGrantsRequest handles oauth-authorizations/list-grants operation.
//
// GET /applications/grants
func (s *Server) handleOAuthAuthorizationsListGrantsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListGrants",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsListGrants",
			ID:   "oauth-authorizations/list-grants",
		}
	)
	params, err := decodeOAuthAuthorizationsListGrantsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsListGrantsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsListGrants",
			OperationID:   "oauth-authorizations/list-grants",
			Body:          nil,
			Params: map[string]any{
				"per_page":  params.PerPage,
				"page":      params.Page,
				"client_id": params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListGrantsParams
			Response = OAuthAuthorizationsListGrantsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListGrantsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsListGrants(ctx, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListGrants(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsUpdateAuthorizationRequest handles oauth-authorizations/update-authorization operation.
//
// PATCH /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsUpdateAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsUpdateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OAuthAuthorizationsUpdateAuthorization",
			ID:   "oauth-authorizations/update-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsUpdateAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsUpdateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsUpdateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsUpdateAuthorization",
			OperationID:   "oauth-authorizations/update-authorization",
			Body:          request,
			Params: map[string]any{
				"authorization_id": params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = OptOAuthAuthorizationsUpdateAuthorizationReq
			Params   = OAuthAuthorizationsUpdateAuthorizationParams
			Response = OAuthAuthorizationsUpdateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsUpdateAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsUpdateAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsBlockUserRequest handles orgs/block-user operation.
//
// PUT /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsBlockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsBlockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsBlockUser",
			ID:   "orgs/block-user",
		}
	)
	params, err := decodeOrgsBlockUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsBlockUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsBlockUser",
			OperationID:   "orgs/block-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsBlockUserParams
			Response = OrgsBlockUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsBlockUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsBlockUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsBlockUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsBlockUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCancelInvitationRequest handles orgs/cancel-invitation operation.
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (s *Server) handleOrgsCancelInvitationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCancelInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCancelInvitation",
			ID:   "orgs/cancel-invitation",
		}
	)
	params, err := decodeOrgsCancelInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCancelInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCancelInvitation",
			OperationID:   "orgs/cancel-invitation",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"invitation_id": params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCancelInvitationParams
			Response = OrgsCancelInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCancelInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCancelInvitation(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsCancelInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCancelInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckBlockedUserRequest handles orgs/check-blocked-user operation.
//
// GET /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsCheckBlockedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckBlockedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCheckBlockedUser",
			ID:   "orgs/check-blocked-user",
		}
	)
	params, err := decodeOrgsCheckBlockedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckBlockedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckBlockedUser",
			OperationID:   "orgs/check-blocked-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckBlockedUserParams
			Response = OrgsCheckBlockedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckBlockedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCheckBlockedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsCheckBlockedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckMembershipForUserRequest handles orgs/check-membership-for-user operation.
//
// GET /orgs/{org}/members/{username}
func (s *Server) handleOrgsCheckMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCheckMembershipForUser",
			ID:   "orgs/check-membership-for-user",
		}
	)
	params, err := decodeOrgsCheckMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckMembershipForUser",
			OperationID:   "orgs/check-membership-for-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckMembershipForUserParams
			Response = OrgsCheckMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCheckMembershipForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsCheckMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckPublicMembershipForUserRequest handles orgs/check-public-membership-for-user operation.
//
// GET /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsCheckPublicMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckPublicMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCheckPublicMembershipForUser",
			ID:   "orgs/check-public-membership-for-user",
		}
	)
	params, err := decodeOrgsCheckPublicMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckPublicMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckPublicMembershipForUser",
			OperationID:   "orgs/check-public-membership-for-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckPublicMembershipForUserParams
			Response = OrgsCheckPublicMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckPublicMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCheckPublicMembershipForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsCheckPublicMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsConvertMemberToOutsideCollaboratorRequest handles orgs/convert-member-to-outside-collaborator operation.
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsConvertMemberToOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsConvertMemberToOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsConvertMemberToOutsideCollaborator",
			ID:   "orgs/convert-member-to-outside-collaborator",
		}
	)
	params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsConvertMemberToOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsConvertMemberToOutsideCollaborator",
			OperationID:   "orgs/convert-member-to-outside-collaborator",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsConvertMemberToOutsideCollaboratorParams
			Response = OrgsConvertMemberToOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsConvertMemberToOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCreateInvitationRequest handles orgs/create-invitation operation.
//
// POST /orgs/{org}/invitations
func (s *Server) handleOrgsCreateInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCreateInvitation",
			ID:   "orgs/create-invitation",
		}
	)
	params, err := decodeOrgsCreateInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsCreateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCreateInvitation",
			OperationID:   "orgs/create-invitation",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsCreateInvitationReq
			Params   = OrgsCreateInvitationParams
			Response = OrgsCreateInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCreateInvitation(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsCreateInvitation(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCreateWebhookRequest handles orgs/create-webhook operation.
//
// POST /orgs/{org}/hooks
func (s *Server) handleOrgsCreateWebhookRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsCreateWebhook",
			ID:   "orgs/create-webhook",
		}
	)
	params, err := decodeOrgsCreateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCreateWebhook",
			OperationID:   "orgs/create-webhook",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OrgsCreateWebhookReq
			Params   = OrgsCreateWebhookParams
			Response = OrgsCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsCreateWebhook(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsCreateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsDeleteWebhookRequest handles orgs/delete-webhook operation.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsDeleteWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsDeleteWebhook",
			ID:   "orgs/delete-webhook",
		}
	)
	params, err := decodeOrgsDeleteWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsDeleteWebhook",
			OperationID:   "orgs/delete-webhook",
			Body:          nil,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsDeleteWebhookParams
			Response = OrgsDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsDeleteWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsDeleteWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetRequest handles orgs/get operation.
//
// GET /orgs/{org}
func (s *Server) handleOrgsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGet",
			ID:   "orgs/get",
		}
	)
	params, err := decodeOrgsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGet",
			OperationID:   "orgs/get",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetParams
			Response = OrgsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetAuditLogRequest handles orgs/get-audit-log operation.
//
// GET /orgs/{org}/audit-log
func (s *Server) handleOrgsGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetAuditLog",
			ID:   "orgs/get-audit-log",
		}
	)
	params, err := decodeOrgsGetAuditLogParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetAuditLog",
			OperationID:   "orgs/get-audit-log",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"phrase":   params.Phrase,
				"include":  params.Include,
				"after":    params.After,
				"before":   params.Before,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetAuditLog(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetAuditLog(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetMembershipForAuthenticatedUserRequest handles orgs/get-membership-for-authenticated-user operation.
//
// GET /user/memberships/orgs/{org}
func (s *Server) handleOrgsGetMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetMembershipForAuthenticatedUser",
			ID:   "orgs/get-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetMembershipForAuthenticatedUser",
			OperationID:   "orgs/get-membership-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForAuthenticatedUserParams
			Response = OrgsGetMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetMembershipForUserRequest handles orgs/get-membership-for-user operation.
//
// GET /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsGetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetMembershipForUser",
			ID:   "orgs/get-membership-for-user",
		}
	)
	params, err := decodeOrgsGetMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetMembershipForUser",
			OperationID:   "orgs/get-membership-for-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForUserParams
			Response = OrgsGetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetMembershipForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookRequest handles orgs/get-webhook operation.
//
// GET /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsGetWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetWebhook",
			ID:   "orgs/get-webhook",
		}
	)
	params, err := decodeOrgsGetWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhook",
			OperationID:   "orgs/get-webhook",
			Body:          nil,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookParams
			Response = OrgsGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookConfigForOrgRequest handles orgs/get-webhook-config-for-org operation.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsGetWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetWebhookConfigForOrg",
			ID:   "orgs/get-webhook-config-for-org",
		}
	)
	params, err := decodeOrgsGetWebhookConfigForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhookConfigForOrg",
			OperationID:   "orgs/get-webhook-config-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookConfigForOrgParams
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetWebhookConfigForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookConfigForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookDeliveryRequest handles orgs/get-webhook-delivery operation.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleOrgsGetWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsGetWebhookDelivery",
			ID:   "orgs/get-webhook-delivery",
		}
	)
	params, err := decodeOrgsGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhookDelivery",
			OperationID:   "orgs/get-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"hook_id":     params.HookID,
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookDeliveryParams
			Response = OrgsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsGetWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListRequest handles orgs/list operation.
//
// GET /organizations
func (s *Server) handleOrgsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsList",
			ID:   "orgs/list",
		}
	)
	params, err := decodeOrgsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsList",
			OperationID:   "orgs/list",
			Body:          nil,
			Params: map[string]any{
				"since":    params.Since,
				"per_page": params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListParams
			Response = OrgsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsList(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListBlockedUsersRequest handles orgs/list-blocked-users operation.
//
// GET /orgs/{org}/blocks
func (s *Server) handleOrgsListBlockedUsersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListBlockedUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListBlockedUsers",
			ID:   "orgs/list-blocked-users",
		}
	)
	params, err := decodeOrgsListBlockedUsersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListBlockedUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListBlockedUsers",
			OperationID:   "orgs/list-blocked-users",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListBlockedUsersParams
			Response = OrgsListBlockedUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListBlockedUsersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListBlockedUsers(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListBlockedUsers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListFailedInvitationsRequest handles orgs/list-failed-invitations operation.
//
// GET /orgs/{org}/failed_invitations
func (s *Server) handleOrgsListFailedInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListFailedInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListFailedInvitations",
			ID:   "orgs/list-failed-invitations",
		}
	)
	params, err := decodeOrgsListFailedInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListFailedInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListFailedInvitations",
			OperationID:   "orgs/list-failed-invitations",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListFailedInvitationsParams
			Response = OrgsListFailedInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListFailedInvitationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListFailedInvitations(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListFailedInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListForAuthenticatedUserRequest handles orgs/list-for-authenticated-user operation.
//
// GET /user/orgs
func (s *Server) handleOrgsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListForAuthenticatedUser",
			ID:   "orgs/list-for-authenticated-user",
		}
	)
	params, err := decodeOrgsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListForAuthenticatedUser",
			OperationID:   "orgs/list-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForAuthenticatedUserParams
			Response = OrgsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListForUserRequest handles orgs/list-for-user operation.
//
// GET /users/{username}/orgs
func (s *Server) handleOrgsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListForUser",
			ID:   "orgs/list-for-user",
		}
	)
	params, err := decodeOrgsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListForUser",
			OperationID:   "orgs/list-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForUserParams
			Response = OrgsListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListInvitationTeamsRequest handles orgs/list-invitation-teams operation.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (s *Server) handleOrgsListInvitationTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListInvitationTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListInvitationTeams",
			ID:   "orgs/list-invitation-teams",
		}
	)
	params, err := decodeOrgsListInvitationTeamsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListInvitationTeamsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListInvitationTeams",
			OperationID:   "orgs/list-invitation-teams",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"invitation_id": params.InvitationID,
				"per_page":      params.PerPage,
				"page":          params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListInvitationTeamsParams
			Response = OrgsListInvitationTeamsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListInvitationTeamsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListInvitationTeams(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListInvitationTeams(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListMembersRequest handles orgs/list-members operation.
//
// GET /orgs/{org}/members
func (s *Server) handleOrgsListMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListMembers",
			ID:   "orgs/list-members",
		}
	)
	params, err := decodeOrgsListMembersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListMembersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListMembers",
			OperationID:   "orgs/list-members",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"filter":   params.Filter,
				"role":     params.Role,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembersParams
			Response = OrgsListMembersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListMembers(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListMembers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListMembershipsForAuthenticatedUserRequest handles orgs/list-memberships-for-authenticated-user operation.
//
// GET /user/memberships/orgs
func (s *Server) handleOrgsListMembershipsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembershipsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListMembershipsForAuthenticatedUser",
			ID:   "orgs/list-memberships-for-authenticated-user",
		}
	)
	params, err := decodeOrgsListMembershipsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListMembershipsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListMembershipsForAuthenticatedUser",
			OperationID:   "orgs/list-memberships-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"state":    params.State,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembershipsForAuthenticatedUserParams
			Response = OrgsListMembershipsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembershipsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembershipsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListOutsideCollaboratorsRequest handles orgs/list-outside-collaborators operation.
//
// GET /orgs/{org}/outside_collaborators
func (s *Server) handleOrgsListOutsideCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListOutsideCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListOutsideCollaborators",
			ID:   "orgs/list-outside-collaborators",
		}
	)
	params, err := decodeOrgsListOutsideCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListOutsideCollaboratorsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListOutsideCollaborators",
			OperationID:   "orgs/list-outside-collaborators",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"filter":   params.Filter,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListOutsideCollaboratorsParams
			Response = OrgsListOutsideCollaboratorsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListOutsideCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListOutsideCollaborators(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListOutsideCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListPendingInvitationsRequest handles orgs/list-pending-invitations operation.
//
// GET /orgs/{org}/invitations
func (s *Server) handleOrgsListPendingInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPendingInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListPendingInvitations",
			ID:   "orgs/list-pending-invitations",
		}
	)
	params, err := decodeOrgsListPendingInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListPendingInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListPendingInvitations",
			OperationID:   "orgs/list-pending-invitations",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPendingInvitationsParams
			Response = OrgsListPendingInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPendingInvitationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListPendingInvitations(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListPendingInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListPublicMembersRequest handles orgs/list-public-members operation.
//
// GET /orgs/{org}/public_members
func (s *Server) handleOrgsListPublicMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPublicMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListPublicMembers",
			ID:   "orgs/list-public-members",
		}
	)
	params, err := decodeOrgsListPublicMembersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListPublicMembersOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListPublicMembers",
			OperationID:   "orgs/list-public-members",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPublicMembersParams
			Response = OrgsListPublicMembersOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPublicMembersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListPublicMembers(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListPublicMembers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListSamlSSOAuthorizationsRequest handles orgs/list-saml-sso-authorizations operation.
//
// GET /orgs/{org}/credential-authorizations
func (s *Server) handleOrgsListSamlSSOAuthorizationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListSamlSSOAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListSamlSSOAuthorizations",
			ID:   "orgs/list-saml-sso-authorizations",
		}
	)
	params, err := decodeOrgsListSamlSSOAuthorizationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []CredentialAuthorization
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListSamlSSOAuthorizations",
			OperationID:   "orgs/list-saml-sso-authorizations",
			Body:          nil,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListSamlSSOAuthorizationsParams
			Response = []CredentialAuthorization
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListSamlSSOAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListSamlSSOAuthorizations(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListSamlSSOAuthorizations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListWebhookDeliveriesRequest handles orgs/list-webhook-deliveries operation.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (s *Server) handleOrgsListWebhookDeliveriesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListWebhookDeliveries",
			ID:   "orgs/list-webhook-deliveries",
		}
	)
	params, err := decodeOrgsListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListWebhookDeliveries",
			OperationID:   "orgs/list-webhook-deliveries",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"hook_id":  params.HookID,
				"per_page": params.PerPage,
				"cursor":   params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhookDeliveriesParams
			Response = OrgsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListWebhookDeliveries(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListWebhooksRequest handles orgs/list-webhooks operation.
//
// GET /orgs/{org}/hooks
func (s *Server) handleOrgsListWebhooksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsListWebhooks",
			ID:   "orgs/list-webhooks",
		}
	)
	params, err := decodeOrgsListWebhooksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListWebhooks",
			OperationID:   "orgs/list-webhooks",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhooksParams
			Response = OrgsListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsListWebhooks(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsListWebhooks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsPingWebhookRequest handles orgs/ping-webhook operation.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (s *Server) handleOrgsPingWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsPingWebhook",
			ID:   "orgs/ping-webhook",
		}
	)
	params, err := decodeOrgsPingWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsPingWebhook",
			OperationID:   "orgs/ping-webhook",
			Body:          nil,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsPingWebhookParams
			Response = OrgsPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsPingWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsPingWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRedeliverWebhookDeliveryRequest handles orgs/redeliver-webhook-delivery operation.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleOrgsRedeliverWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRedeliverWebhookDelivery",
			ID:   "orgs/redeliver-webhook-delivery",
		}
	)
	params, err := decodeOrgsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRedeliverWebhookDelivery",
			OperationID:   "orgs/redeliver-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"hook_id":     params.HookID,
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRedeliverWebhookDeliveryParams
			Response = OrgsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRedeliverWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveMemberRequest handles orgs/remove-member operation.
//
// DELETE /orgs/{org}/members/{username}
func (s *Server) handleOrgsRemoveMemberRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRemoveMember",
			ID:   "orgs/remove-member",
		}
	)
	params, err := decodeOrgsRemoveMemberParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveMemberRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveMember",
			OperationID:   "orgs/remove-member",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMemberParams
			Response = OrgsRemoveMemberRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMemberParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRemoveMember(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMember(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveMembershipForUserRequest handles orgs/remove-membership-for-user operation.
//
// DELETE /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsRemoveMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRemoveMembershipForUser",
			ID:   "orgs/remove-membership-for-user",
		}
	)
	params, err := decodeOrgsRemoveMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveMembershipForUser",
			OperationID:   "orgs/remove-membership-for-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMembershipForUserParams
			Response = OrgsRemoveMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRemoveMembershipForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveOutsideCollaboratorRequest handles orgs/remove-outside-collaborator operation.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsRemoveOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRemoveOutsideCollaborator",
			ID:   "orgs/remove-outside-collaborator",
		}
	)
	params, err := decodeOrgsRemoveOutsideCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveOutsideCollaborator",
			OperationID:   "orgs/remove-outside-collaborator",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveOutsideCollaboratorParams
			Response = OrgsRemoveOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRemoveOutsideCollaborator(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRemoveOutsideCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemovePublicMembershipForAuthenticatedUserRequest handles orgs/remove-public-membership-for-authenticated-user operation.
//
// DELETE /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsRemovePublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemovePublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRemovePublicMembershipForAuthenticatedUser",
			ID:   "orgs/remove-public-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemovePublicMembershipForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemovePublicMembershipForAuthenticatedUser",
			OperationID:   "orgs/remove-public-membership-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemovePublicMembershipForAuthenticatedUserParams
			Response = OrgsRemovePublicMembershipForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemovePublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveSamlSSOAuthorizationRequest handles orgs/remove-saml-sso-authorization operation.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (s *Server) handleOrgsRemoveSamlSSOAuthorizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveSamlSSOAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsRemoveSamlSSOAuthorization",
			ID:   "orgs/remove-saml-sso-authorization",
		}
	)
	params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveSamlSSOAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveSamlSSOAuthorization",
			OperationID:   "orgs/remove-saml-sso-authorization",
			Body:          nil,
			Params: map[string]any{
				"org":           params.Org,
				"credential_id": params.CredentialID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveSamlSSOAuthorizationParams
			Response = OrgsRemoveSamlSSOAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveSamlSSOAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsSetMembershipForUserRequest handles orgs/set-membership-for-user operation.
//
// PUT /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsSetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsSetMembershipForUser",
			ID:   "orgs/set-membership-for-user",
		}
	)
	params, err := decodeOrgsSetMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsSetMembershipForUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsSetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsSetMembershipForUser",
			OperationID:   "orgs/set-membership-for-user",
			Body:          request,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsSetMembershipForUserReq
			Params   = OrgsSetMembershipForUserParams
			Response = OrgsSetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsSetMembershipForUser(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsSetMembershipForUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsSetPublicMembershipForAuthenticatedUserRequest handles orgs/set-public-membership-for-authenticated-user operation.
//
// PUT /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsSetPublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetPublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsSetPublicMembershipForAuthenticatedUser",
			ID:   "orgs/set-public-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsSetPublicMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsSetPublicMembershipForAuthenticatedUser",
			OperationID:   "orgs/set-public-membership-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsSetPublicMembershipForAuthenticatedUserParams
			Response = OrgsSetPublicMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetPublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUnblockUserRequest handles orgs/unblock-user operation.
//
// DELETE /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsUnblockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUnblockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsUnblockUser",
			ID:   "orgs/unblock-user",
		}
	)
	params, err := decodeOrgsUnblockUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsUnblockUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUnblockUser",
			OperationID:   "orgs/unblock-user",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsUnblockUserParams
			Response = OrgsUnblockUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUnblockUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsUnblockUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.OrgsUnblockUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateMembershipForAuthenticatedUserRequest handles orgs/update-membership-for-authenticated-user operation.
//
// PATCH /user/memberships/orgs/{org}
func (s *Server) handleOrgsUpdateMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsUpdateMembershipForAuthenticatedUser",
			ID:   "orgs/update-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsUpdateMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateMembershipForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateMembershipForAuthenticatedUser",
			OperationID:   "orgs/update-membership-for-authenticated-user",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OrgsUpdateMembershipForAuthenticatedUserReq
			Params   = OrgsUpdateMembershipForAuthenticatedUserParams
			Response = OrgsUpdateMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateWebhookRequest handles orgs/update-webhook operation.
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsUpdateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsUpdateWebhook",
			ID:   "orgs/update-webhook",
		}
	)
	params, err := decodeOrgsUpdateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateWebhook",
			OperationID:   "orgs/update-webhook",
			Body:          request,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookReq
			Params   = OrgsUpdateWebhookParams
			Response = OrgsUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsUpdateWebhook(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateWebhookConfigForOrgRequest handles orgs/update-webhook-config-for-org operation.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsUpdateWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OrgsUpdateWebhookConfigForOrg",
			ID:   "orgs/update-webhook-config-for-org",
		}
	)
	params, err := decodeOrgsUpdateWebhookConfigForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateWebhookConfigForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateWebhookConfigForOrg",
			OperationID:   "orgs/update-webhook-config-for-org",
			Body:          request,
			Params: map[string]any{
				"org":     params.Org,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookConfigForOrgReq
			Params   = OrgsUpdateWebhookConfigForOrgParams
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForAuthenticatedUserRequest handles packages/delete-package-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageForAuthenticatedUser",
			ID:   "packages/delete-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesDeletePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForAuthenticatedUser",
			OperationID:   "packages/delete-package-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForAuthenticatedUserParams
			Response = PackagesDeletePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForOrgRequest handles packages/delete-package-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageForOrg",
			ID:   "packages/delete-package-for-org",
		}
	)
	params, err := decodePackagesDeletePackageForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForOrg",
			OperationID:   "packages/delete-package-for-org",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"org":          params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForOrgParams
			Response = PackagesDeletePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForUserRequest handles packages/delete-package-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageForUser",
			ID:   "packages/delete-package-for-user",
		}
	)
	params, err := decodePackagesDeletePackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForUser",
			OperationID:   "packages/delete-package-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"username":     params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForUserParams
			Response = PackagesDeletePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForAuthenticatedUserRequest handles packages/delete-package-version-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageVersionForAuthenticatedUser",
			ID:   "packages/delete-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForAuthenticatedUser",
			OperationID:   "packages/delete-package-version-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForAuthenticatedUserParams
			Response = PackagesDeletePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForOrgRequest handles packages/delete-package-version-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageVersionForOrg",
			ID:   "packages/delete-package-version-for-org",
		}
	)
	params, err := decodePackagesDeletePackageVersionForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForOrg",
			OperationID:   "packages/delete-package-version-for-org",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"org":                params.Org,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForOrgParams
			Response = PackagesDeletePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageVersionForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForUserRequest handles packages/delete-package-version-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesDeletePackageVersionForUser",
			ID:   "packages/delete-package-version-for-user",
		}
	)
	params, err := decodePackagesDeletePackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForUser",
			OperationID:   "packages/delete-package-version-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"username":           params.Username,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForUserParams
			Response = PackagesDeletePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesDeletePackageVersionForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest handles packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
			ID:   "packages/get-all-package-versions-for-package-owned-by-authenticated-user",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"page":         params.Page,
				"per_page":     params.PerPage,
				"state":        params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest handles packages/get-all-package-versions-for-package-owned-by-org operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
			ID:   "packages/get-all-package-versions-for-package-owned-by-org",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-org",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"org":          params.Org,
				"page":         params.Page,
				"per_page":     params.PerPage,
				"state":        params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest handles packages/get-all-package-versions-for-package-owned-by-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetAllPackageVersionsForPackageOwnedByUser",
			ID:   "packages/get-all-package-versions-for-package-owned-by-user",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByUser",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"username":     params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForAuthenticatedUserRequest handles packages/get-package-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageForAuthenticatedUser",
			ID:   "packages/get-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesGetPackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForAuthenticatedUser",
			OperationID:   "packages/get-package-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForAuthenticatedUserParams
			Response = Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForOrganizationRequest handles packages/get-package-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForOrganizationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageForOrganization",
			ID:   "packages/get-package-for-organization",
		}
	)
	params, err := decodePackagesGetPackageForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForOrganization",
			OperationID:   "packages/get-package-for-organization",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"org":          params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForOrganizationParams
			Response = Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageForOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForUserRequest handles packages/get-package-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageForUser",
			ID:   "packages/get-package-for-user",
		}
	)
	params, err := decodePackagesGetPackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForUser",
			OperationID:   "packages/get-package-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"username":     params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForUserParams
			Response = Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForAuthenticatedUserRequest handles packages/get-package-version-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageVersionForAuthenticatedUser",
			ID:   "packages/get-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForAuthenticatedUser",
			OperationID:   "packages/get-package-version-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForAuthenticatedUserParams
			Response = PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForOrganizationRequest handles packages/get-package-version-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForOrganizationRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageVersionForOrganization",
			ID:   "packages/get-package-version-for-organization",
		}
	)
	params, err := decodePackagesGetPackageVersionForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForOrganization",
			OperationID:   "packages/get-package-version-for-organization",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"org":                params.Org,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForOrganizationParams
			Response = PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageVersionForOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForUserRequest handles packages/get-package-version-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesGetPackageVersionForUser",
			ID:   "packages/get-package-version-for-user",
		}
	)
	params, err := decodePackagesGetPackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForUser",
			OperationID:   "packages/get-package-version-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"package_version_id": params.PackageVersionID,
				"username":           params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForUserParams
			Response = PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesGetPackageVersionForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForAuthenticatedUserRequest handles packages/list-packages-for-authenticated-user operation.
//
// GET /user/packages
func (s *Server) handlePackagesListPackagesForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesListPackagesForAuthenticatedUser",
			ID:   "packages/list-packages-for-authenticated-user",
		}
	)
	params, err := decodePackagesListPackagesForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForAuthenticatedUser",
			OperationID:   "packages/list-packages-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"visibility":   params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForAuthenticatedUserParams
			Response = []Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForOrganizationRequest handles packages/list-packages-for-organization operation.
//
// GET /orgs/{org}/packages
func (s *Server) handlePackagesListPackagesForOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesListPackagesForOrganization",
			ID:   "packages/list-packages-for-organization",
		}
	)
	params, err := decodePackagesListPackagesForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesListPackagesForOrganizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForOrganization",
			OperationID:   "packages/list-packages-for-organization",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"org":          params.Org,
				"visibility":   params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForOrganizationParams
			Response = PackagesListPackagesForOrganizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesListPackagesForOrganization(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForUserRequest handles packages/list-packages-for-user operation.
//
// GET /users/{username}/packages
func (s *Server) handlePackagesListPackagesForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesListPackagesForUser",
			ID:   "packages/list-packages-for-user",
		}
	)
	params, err := decodePackagesListPackagesForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesListPackagesForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForUser",
			OperationID:   "packages/list-packages-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"visibility":   params.Visibility,
				"username":     params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForUserParams
			Response = PackagesListPackagesForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesListPackagesForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForAuthenticatedUserRequest handles packages/restore-package-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageForAuthenticatedUser",
			ID:   "packages/restore-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesRestorePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForAuthenticatedUser",
			OperationID:   "packages/restore-package-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"token":        params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForAuthenticatedUserParams
			Response = PackagesRestorePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForOrgRequest handles packages/restore-package-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageForOrg",
			ID:   "packages/restore-package-for-org",
		}
	)
	params, err := decodePackagesRestorePackageForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForOrg",
			OperationID:   "packages/restore-package-for-org",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"org":          params.Org,
				"token":        params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForOrgParams
			Response = PackagesRestorePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForUserRequest handles packages/restore-package-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageForUser",
			ID:   "packages/restore-package-for-user",
		}
	)
	params, err := decodePackagesRestorePackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForUser",
			OperationID:   "packages/restore-package-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type": params.PackageType,
				"package_name": params.PackageName,
				"username":     params.Username,
				"token":        params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForUserParams
			Response = PackagesRestorePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForAuthenticatedUserRequest handles packages/restore-package-version-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageVersionForAuthenticatedUser",
			ID:   "packages/restore-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForAuthenticatedUser",
			OperationID:   "packages/restore-package-version-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForAuthenticatedUserParams
			Response = PackagesRestorePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForOrgRequest handles packages/restore-package-version-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageVersionForOrg",
			ID:   "packages/restore-package-version-for-org",
		}
	)
	params, err := decodePackagesRestorePackageVersionForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForOrg",
			OperationID:   "packages/restore-package-version-for-org",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"org":                params.Org,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForOrgParams
			Response = PackagesRestorePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageVersionForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForUserRequest handles packages/restore-package-version-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PackagesRestorePackageVersionForUser",
			ID:   "packages/restore-package-version-for-user",
		}
	)
	params, err := decodePackagesRestorePackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForUser",
			OperationID:   "packages/restore-package-version-for-user",
			Body:          nil,
			Params: map[string]any{
				"package_type":       params.PackageType,
				"package_name":       params.PackageName,
				"username":           params.Username,
				"package_version_id": params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForUserParams
			Response = PackagesRestorePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PackagesRestorePackageVersionForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsAddCollaboratorRequest handles projects/add-collaborator operation.
//
// PUT /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsAddCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsAddCollaborator",
			ID:   "projects/add-collaborator",
		}
	)
	params, err := decodeProjectsAddCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsAddCollaborator",
			OperationID:   "projects/add-collaborator",
			Body:          request,
			Params: map[string]any{
				"project_id": params.ProjectID,
				"username":   params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptNilProjectsAddCollaboratorReq
			Params   = ProjectsAddCollaboratorParams
			Response = ProjectsAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsAddCollaborator(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsAddCollaborator(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsAddCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateColumnRequest handles projects/create-column operation.
//
// POST /projects/{project_id}/columns
func (s *Server) handleProjectsCreateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsCreateColumn",
			ID:   "projects/create-column",
		}
	)
	params, err := decodeProjectsCreateColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateColumn",
			OperationID:   "projects/create-column",
			Body:          request,
			Params: map[string]any{
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsCreateColumnReq
			Params   = ProjectsCreateColumnParams
			Response = ProjectsCreateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateColumnParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsCreateColumn(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsCreateColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForAuthenticatedUserRequest handles projects/create-for-authenticated-user operation.
//
// POST /user/projects
func (s *Server) handleProjectsCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsCreateForAuthenticatedUser",
			ID:   "projects/create-for-authenticated-user",
		}
	)
	request, close, err := s.decodeProjectsCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForAuthenticatedUser",
			OperationID:   "projects/create-for-authenticated-user",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = ProjectsCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ProjectsCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForOrgRequest handles projects/create-for-org operation.
//
// POST /orgs/{org}/projects
func (s *Server) handleProjectsCreateForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsCreateForOrg",
			ID:   "projects/create-for-org",
		}
	)
	params, err := decodeProjectsCreateForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForOrg",
			OperationID:   "projects/create-for-org",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsCreateForOrgReq
			Params   = ProjectsCreateForOrgParams
			Response = ProjectsCreateForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsCreateForOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForRepoRequest handles projects/create-for-repo operation.
//
// POST /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsCreateForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsCreateForRepo",
			ID:   "projects/create-for-repo",
		}
	)
	params, err := decodeProjectsCreateForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForRepo",
			OperationID:   "projects/create-for-repo",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsCreateForRepoReq
			Params   = ProjectsCreateForRepoParams
			Response = ProjectsCreateForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsCreateForRepo(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteRequest handles projects/delete operation.
//
// DELETE /projects/{project_id}
func (s *Server) handleProjectsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsDelete",
			ID:   "projects/delete",
		}
	)
	params, err := decodeProjectsDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDelete",
			OperationID:   "projects/delete",
			Body:          nil,
			Params: map[string]any{
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteParams
			Response = ProjectsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsDelete(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteCardRequest handles projects/delete-card operation.
//
// DELETE /projects/columns/cards/{card_id}
func (s *Server) handleProjectsDeleteCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsDeleteCard",
			ID:   "projects/delete-card",
		}
	)
	params, err := decodeProjectsDeleteCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDeleteCard",
			OperationID:   "projects/delete-card",
			Body:          nil,
			Params: map[string]any{
				"card_id": params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteCardParams
			Response = ProjectsDeleteCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteCardParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsDeleteCard(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteCard(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteColumnRequest handles projects/delete-column operation.
//
// DELETE /projects/columns/{column_id}
func (s *Server) handleProjectsDeleteColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsDeleteColumn",
			ID:   "projects/delete-column",
		}
	)
	params, err := decodeProjectsDeleteColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDeleteColumn",
			OperationID:   "projects/delete-column",
			Body:          nil,
			Params: map[string]any{
				"column_id": params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteColumnParams
			Response = ProjectsDeleteColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteColumnParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsDeleteColumn(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteColumn(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetRequest handles projects/get operation.
//
// GET /projects/{project_id}
func (s *Server) handleProjectsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsGet",
			ID:   "projects/get",
		}
	)
	params, err := decodeProjectsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGet",
			OperationID:   "projects/get",
			Body:          nil,
			Params: map[string]any{
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetParams
			Response = ProjectsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetCardRequest handles projects/get-card operation.
//
// GET /projects/columns/cards/{card_id}
func (s *Server) handleProjectsGetCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsGetCard",
			ID:   "projects/get-card",
		}
	)
	params, err := decodeProjectsGetCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetCard",
			OperationID:   "projects/get-card",
			Body:          nil,
			Params: map[string]any{
				"card_id": params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetCardParams
			Response = ProjectsGetCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetCardParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsGetCard(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsGetCard(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetColumnRequest handles projects/get-column operation.
//
// GET /projects/columns/{column_id}
func (s *Server) handleProjectsGetColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsGetColumn",
			ID:   "projects/get-column",
		}
	)
	params, err := decodeProjectsGetColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetColumn",
			OperationID:   "projects/get-column",
			Body:          nil,
			Params: map[string]any{
				"column_id": params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetColumnParams
			Response = ProjectsGetColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetColumnParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsGetColumn(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsGetColumn(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetPermissionForUserRequest handles projects/get-permission-for-user operation.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (s *Server) handleProjectsGetPermissionForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetPermissionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsGetPermissionForUser",
			ID:   "projects/get-permission-for-user",
		}
	)
	params, err := decodeProjectsGetPermissionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetPermissionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetPermissionForUser",
			OperationID:   "projects/get-permission-for-user",
			Body:          nil,
			Params: map[string]any{
				"project_id": params.ProjectID,
				"username":   params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetPermissionForUserParams
			Response = ProjectsGetPermissionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetPermissionForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsGetPermissionForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsGetPermissionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetPermissionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListCardsRequest handles projects/list-cards operation.
//
// GET /projects/columns/{column_id}/cards
func (s *Server) handleProjectsListCardsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCards",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListCards",
			ID:   "projects/list-cards",
		}
	)
	params, err := decodeProjectsListCardsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListCardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListCards",
			OperationID:   "projects/list-cards",
			Body:          nil,
			Params: map[string]any{
				"column_id":      params.ColumnID,
				"archived_state": params.ArchivedState,
				"per_page":       params.PerPage,
				"page":           params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCardsParams
			Response = ProjectsListCardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCardsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListCards(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListCards(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListCollaboratorsRequest handles projects/list-collaborators operation.
//
// GET /projects/{project_id}/collaborators
func (s *Server) handleProjectsListCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListCollaborators",
			ID:   "projects/list-collaborators",
		}
	)
	params, err := decodeProjectsListCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListCollaborators",
			OperationID:   "projects/list-collaborators",
			Body:          nil,
			Params: map[string]any{
				"project_id":  params.ProjectID,
				"affiliation": params.Affiliation,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCollaboratorsParams
			Response = ProjectsListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListCollaborators(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListColumnsRequest handles projects/list-columns operation.
//
// GET /projects/{project_id}/columns
func (s *Server) handleProjectsListColumnsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListColumns",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListColumns",
			ID:   "projects/list-columns",
		}
	)
	params, err := decodeProjectsListColumnsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListColumnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListColumns",
			OperationID:   "projects/list-columns",
			Body:          nil,
			Params: map[string]any{
				"project_id": params.ProjectID,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListColumnsParams
			Response = ProjectsListColumnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListColumnsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListColumns(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListColumns(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForOrgRequest handles projects/list-for-org operation.
//
// GET /orgs/{org}/projects
func (s *Server) handleProjectsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListForOrg",
			ID:   "projects/list-for-org",
		}
	)
	params, err := decodeProjectsListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForOrg",
			OperationID:   "projects/list-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"state":    params.State,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForOrgParams
			Response = ProjectsListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForRepoRequest handles projects/list-for-repo operation.
//
// GET /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListForRepo",
			ID:   "projects/list-for-repo",
		}
	)
	params, err := decodeProjectsListForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForRepo",
			OperationID:   "projects/list-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"state":    params.State,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForRepoParams
			Response = ProjectsListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForUserRequest handles projects/list-for-user operation.
//
// GET /users/{username}/projects
func (s *Server) handleProjectsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsListForUser",
			ID:   "projects/list-for-user",
		}
	)
	params, err := decodeProjectsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForUser",
			OperationID:   "projects/list-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"state":    params.State,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForUserParams
			Response = ProjectsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsListForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsMoveCardRequest handles projects/move-card operation.
//
// POST /projects/columns/cards/{card_id}/moves
func (s *Server) handleProjectsMoveCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsMoveCard",
			ID:   "projects/move-card",
		}
	)
	params, err := decodeProjectsMoveCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsMoveCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsMoveCard",
			OperationID:   "projects/move-card",
			Body:          request,
			Params: map[string]any{
				"card_id": params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsMoveCardReq
			Params   = ProjectsMoveCardParams
			Response = ProjectsMoveCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveCardParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsMoveCard(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsMoveCard(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsMoveColumnRequest handles projects/move-column operation.
//
// POST /projects/columns/{column_id}/moves
func (s *Server) handleProjectsMoveColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsMoveColumn",
			ID:   "projects/move-column",
		}
	)
	params, err := decodeProjectsMoveColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsMoveColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsMoveColumn",
			OperationID:   "projects/move-column",
			Body:          request,
			Params: map[string]any{
				"column_id": params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsMoveColumnReq
			Params   = ProjectsMoveColumnParams
			Response = ProjectsMoveColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveColumnParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsMoveColumn(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsMoveColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsRemoveCollaboratorRequest handles projects/remove-collaborator operation.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsRemoveCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsRemoveCollaborator",
			ID:   "projects/remove-collaborator",
		}
	)
	params, err := decodeProjectsRemoveCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsRemoveCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsRemoveCollaborator",
			OperationID:   "projects/remove-collaborator",
			Body:          nil,
			Params: map[string]any{
				"project_id": params.ProjectID,
				"username":   params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsRemoveCollaboratorParams
			Response = ProjectsRemoveCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsRemoveCollaborator(ctx, params)
			},
		)
	} else {
		response, err = s.h.ProjectsRemoveCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsRemoveCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateRequest handles projects/update operation.
//
// PATCH /projects/{project_id}
func (s *Server) handleProjectsUpdateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsUpdate",
			ID:   "projects/update",
		}
	)
	params, err := decodeProjectsUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdate",
			OperationID:   "projects/update",
			Body:          request,
			Params: map[string]any{
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateReq
			Params   = ProjectsUpdateParams
			Response = ProjectsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsUpdate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateCardRequest handles projects/update-card operation.
//
// PATCH /projects/columns/cards/{card_id}
func (s *Server) handleProjectsUpdateCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsUpdateCard",
			ID:   "projects/update-card",
		}
	)
	params, err := decodeProjectsUpdateCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdateCard",
			OperationID:   "projects/update-card",
			Body:          request,
			Params: map[string]any{
				"card_id": params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateCardReq
			Params   = ProjectsUpdateCardParams
			Response = ProjectsUpdateCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateCardParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsUpdateCard(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateCard(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateColumnRequest handles projects/update-column operation.
//
// PATCH /projects/columns/{column_id}
func (s *Server) handleProjectsUpdateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProjectsUpdateColumn",
			ID:   "projects/update-column",
		}
	)
	params, err := decodeProjectsUpdateColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdateColumn",
			OperationID:   "projects/update-column",
			Body:          request,
			Params: map[string]any{
				"column_id": params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = ProjectsUpdateColumnReq
			Params   = ProjectsUpdateColumnParams
			Response = ProjectsUpdateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateColumnParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ProjectsUpdateColumn(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCheckIfMergedRequest handles pulls/check-if-merged operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsCheckIfMergedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCheckIfMerged",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsCheckIfMerged",
			ID:   "pulls/check-if-merged",
		}
	)
	params, err := decodePullsCheckIfMergedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsCheckIfMergedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCheckIfMerged",
			OperationID:   "pulls/check-if-merged",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsCheckIfMergedParams
			Response = PullsCheckIfMergedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCheckIfMergedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsCheckIfMerged(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsCheckIfMerged(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateRequest handles pulls/create operation.
//
// POST /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsCreate",
			ID:   "pulls/create",
		}
	)
	params, err := decodePullsCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreate",
			OperationID:   "pulls/create",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = PullsCreateReq
			Params   = PullsCreateParams
			Response = PullsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsCreate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReplyForReviewCommentRequest handles pulls/create-reply-for-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (s *Server) handlePullsCreateReplyForReviewCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReplyForReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsCreateReplyForReviewComment",
			ID:   "pulls/create-reply-for-review-comment",
		}
	)
	params, err := decodePullsCreateReplyForReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReplyForReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReplyForReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReplyForReviewComment",
			OperationID:   "pulls/create-reply-for-review-comment",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"comment_id":  params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = PullsCreateReplyForReviewCommentReq
			Params   = PullsCreateReplyForReviewCommentParams
			Response = PullsCreateReplyForReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReplyForReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsCreateReplyForReviewComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsCreateReplyForReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReviewRequest handles pulls/create-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsCreateReviewRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsCreateReview",
			ID:   "pulls/create-review",
		}
	)
	params, err := decodePullsCreateReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReview",
			OperationID:   "pulls/create-review",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsCreateReviewReq
			Params   = PullsCreateReviewParams
			Response = PullsCreateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsCreateReview(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsCreateReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReviewCommentRequest handles pulls/create-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsCreateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsCreateReviewComment",
			ID:   "pulls/create-review-comment",
		}
	)
	params, err := decodePullsCreateReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReviewComment",
			OperationID:   "pulls/create-review-comment",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = PullsCreateReviewCommentReq
			Params   = PullsCreateReviewCommentParams
			Response = PullsCreateReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsCreateReviewComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsCreateReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDeletePendingReviewRequest handles pulls/delete-pending-review operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsDeletePendingReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeletePendingReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsDeletePendingReview",
			ID:   "pulls/delete-pending-review",
		}
	)
	params, err := decodePullsDeletePendingReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsDeletePendingReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDeletePendingReview",
			OperationID:   "pulls/delete-pending-review",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeletePendingReviewParams
			Response = PullsDeletePendingReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeletePendingReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsDeletePendingReview(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsDeletePendingReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDeleteReviewCommentRequest handles pulls/delete-review-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsDeleteReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeleteReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsDeleteReviewComment",
			ID:   "pulls/delete-review-comment",
		}
	)
	params, err := decodePullsDeleteReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsDeleteReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDeleteReviewComment",
			OperationID:   "pulls/delete-review-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeleteReviewCommentParams
			Response = PullsDeleteReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeleteReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsDeleteReviewComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsDeleteReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDismissReviewRequest handles pulls/dismiss-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (s *Server) handlePullsDismissReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDismissReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsDismissReview",
			ID:   "pulls/dismiss-review",
		}
	)
	params, err := decodePullsDismissReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsDismissReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsDismissReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDismissReview",
			OperationID:   "pulls/dismiss-review",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = PullsDismissReviewReq
			Params   = PullsDismissReviewParams
			Response = PullsDismissReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDismissReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsDismissReview(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsDismissReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetRequest handles pulls/get operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsGet",
			ID:   "pulls/get",
		}
	)
	params, err := decodePullsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGet",
			OperationID:   "pulls/get",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetParams
			Response = PullsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetReviewRequest handles pulls/get-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsGetReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsGetReview",
			ID:   "pulls/get-review",
		}
	)
	params, err := decodePullsGetReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGetReview",
			OperationID:   "pulls/get-review",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewParams
			Response = PullsGetReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsGetReview(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsGetReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetReviewCommentRequest handles pulls/get-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsGetReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsGetReviewComment",
			ID:   "pulls/get-review-comment",
		}
	)
	params, err := decodePullsGetReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGetReviewComment",
			OperationID:   "pulls/get-review-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewCommentParams
			Response = PullsGetReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsGetReviewComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsGetReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListRequest handles pulls/list operation.
//
// GET /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsListRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsList",
			ID:   "pulls/list",
		}
	)
	params, err := decodePullsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsList",
			OperationID:   "pulls/list",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"state":     params.State,
				"head":      params.Head,
				"base":      params.Base,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListParams
			Response = PullsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsList(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListCommentsForReviewRequest handles pulls/list-comments-for-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (s *Server) handlePullsListCommentsForReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommentsForReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListCommentsForReview",
			ID:   "pulls/list-comments-for-review",
		}
	)
	params, err := decodePullsListCommentsForReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListCommentsForReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListCommentsForReview",
			OperationID:   "pulls/list-comments-for-review",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommentsForReviewParams
			Response = PullsListCommentsForReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommentsForReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListCommentsForReview(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListCommentsForReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListCommitsRequest handles pulls/list-commits operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (s *Server) handlePullsListCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListCommits",
			ID:   "pulls/list-commits",
		}
	)
	params, err := decodePullsListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListCommitsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListCommits",
			OperationID:   "pulls/list-commits",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommitsParams
			Response = PullsListCommitsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListCommits(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListFilesRequest handles pulls/list-files operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (s *Server) handlePullsListFilesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListFiles",
			ID:   "pulls/list-files",
		}
	)
	params, err := decodePullsListFilesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListFilesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListFiles",
			OperationID:   "pulls/list-files",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListFilesParams
			Response = PullsListFilesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListFilesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListFiles(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListFiles(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListFilesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListRequestedReviewersRequest handles pulls/list-requested-reviewers operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsListRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListRequestedReviewers",
			ID:   "pulls/list-requested-reviewers",
		}
	)
	params, err := decodePullsListRequestedReviewersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullRequestReviewRequestHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListRequestedReviewers",
			OperationID:   "pulls/list-requested-reviewers",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListRequestedReviewersParams
			Response = PullRequestReviewRequestHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListRequestedReviewers(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListRequestedReviewers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewCommentsRequest handles pulls/list-review-comments operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsListReviewCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListReviewComments",
			ID:   "pulls/list-review-comments",
		}
	)
	params, err := decodePullsListReviewCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListReviewCommentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviewComments",
			OperationID:   "pulls/list-review-comments",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"sort":        params.Sort,
				"direction":   params.Direction,
				"since":       params.Since,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsParams
			Response = PullsListReviewCommentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListReviewComments(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListReviewComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewCommentsForRepoRequest handles pulls/list-review-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (s *Server) handlePullsListReviewCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListReviewCommentsForRepo",
			ID:   "pulls/list-review-comments-for-repo",
		}
	)
	params, err := decodePullsListReviewCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListReviewCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviewCommentsForRepo",
			OperationID:   "pulls/list-review-comments-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"sort":      params.Sort,
				"direction": params.Direction,
				"since":     params.Since,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsForRepoParams
			Response = PullsListReviewCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListReviewCommentsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListReviewCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewsRequest handles pulls/list-reviews operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsListReviewsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsListReviews",
			ID:   "pulls/list-reviews",
		}
	)
	params, err := decodePullsListReviewsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListReviewsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviews",
			OperationID:   "pulls/list-reviews",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewsParams
			Response = PullsListReviewsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsListReviews(ctx, params)
			},
		)
	} else {
		response, err = s.h.PullsListReviews(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsMergeRequest handles pulls/merge operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsMergeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsMerge",
			ID:   "pulls/merge",
		}
	)
	params, err := decodePullsMergeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsMerge",
			OperationID:   "pulls/merge",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsMergeReq
			Params   = PullsMergeParams
			Response = PullsMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsMergeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsMerge(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsMerge(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsMergeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsRemoveRequestedReviewersRequest handles pulls/remove-requested-reviewers operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsRemoveRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsRemoveRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsRemoveRequestedReviewers",
			ID:   "pulls/remove-requested-reviewers",
		}
	)
	params, err := decodePullsRemoveRequestedReviewersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsRemoveRequestedReviewersRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsRemoveRequestedReviewersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsRemoveRequestedReviewers",
			OperationID:   "pulls/remove-requested-reviewers",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = PullsRemoveRequestedReviewersReq
			Params   = PullsRemoveRequestedReviewersParams
			Response = PullsRemoveRequestedReviewersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsRemoveRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsRemoveRequestedReviewers(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsRemoveRequestedReviewers(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsRemoveRequestedReviewersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsSubmitReviewRequest handles pulls/submit-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (s *Server) handlePullsSubmitReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsSubmitReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsSubmitReview",
			ID:   "pulls/submit-review",
		}
	)
	params, err := decodePullsSubmitReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsSubmitReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsSubmitReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsSubmitReview",
			OperationID:   "pulls/submit-review",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = PullsSubmitReviewReq
			Params   = PullsSubmitReviewParams
			Response = PullsSubmitReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsSubmitReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsSubmitReview(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsSubmitReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateRequest handles pulls/update operation.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsUpdate",
			ID:   "pulls/update",
		}
	)
	params, err := decodePullsUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdate",
			OperationID:   "pulls/update",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsUpdateReq
			Params   = PullsUpdateParams
			Response = PullsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsUpdate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateBranchRequest handles pulls/update-branch operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (s *Server) handlePullsUpdateBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsUpdateBranch",
			ID:   "pulls/update-branch",
		}
	)
	params, err := decodePullsUpdateBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateBranch",
			OperationID:   "pulls/update-branch",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsUpdateBranchReq
			Params   = PullsUpdateBranchParams
			Response = PullsUpdateBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsUpdateBranch(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsUpdateBranch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateReviewRequest handles pulls/update-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsUpdateReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsUpdateReview",
			ID:   "pulls/update-review",
		}
	)
	params, err := decodePullsUpdateReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateReview",
			OperationID:   "pulls/update-review",
			Body:          request,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"pull_number": params.PullNumber,
				"review_id":   params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = PullsUpdateReviewReq
			Params   = PullsUpdateReviewParams
			Response = PullsUpdateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsUpdateReview(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsUpdateReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateReviewCommentRequest handles pulls/update-review-comment operation.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsUpdateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PullsUpdateReviewComment",
			ID:   "pulls/update-review-comment",
		}
	)
	params, err := decodePullsUpdateReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullRequestReviewComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateReviewComment",
			OperationID:   "pulls/update-review-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = PullsUpdateReviewCommentReq
			Params   = PullsUpdateReviewCommentParams
			Response = PullRequestReviewComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.PullsUpdateReviewComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PullsUpdateReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRateLimitGetRequest handles rate-limit/get operation.
//
// GET /rate_limit
func (s *Server) handleRateLimitGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RateLimitGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response RateLimitGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RateLimitGet",
			OperationID:   "rate-limit/get",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RateLimitGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.RateLimitGet(ctx)
			},
		)
	} else {
		response, err = s.h.RateLimitGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRateLimitGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForCommitCommentRequest handles reactions/create-for-commit-comment operation.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForCommitComment",
			ID:   "reactions/create-for-commit-comment",
		}
	)
	params, err := decodeReactionsCreateForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForCommitComment",
			OperationID:   "reactions/create-for-commit-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForCommitCommentReq
			Params   = ReactionsCreateForCommitCommentParams
			Response = ReactionsCreateForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForCommitComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForIssueRequest handles reactions/create-for-issue operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsCreateForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForIssue",
			ID:   "reactions/create-for-issue",
		}
	)
	params, err := decodeReactionsCreateForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForIssueRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForIssue",
			OperationID:   "reactions/create-for-issue",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForIssueReq
			Params   = ReactionsCreateForIssueParams
			Response = ReactionsCreateForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForIssue(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssue(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForIssueCommentRequest handles reactions/create-for-issue-comment operation.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForIssueComment",
			ID:   "reactions/create-for-issue-comment",
		}
	)
	params, err := decodeReactionsCreateForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForIssueCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForIssueComment",
			OperationID:   "reactions/create-for-issue-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForIssueCommentReq
			Params   = ReactionsCreateForIssueCommentParams
			Response = ReactionsCreateForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForIssueComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssueComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForPullRequestReviewCommentRequest handles reactions/create-for-pull-request-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForPullRequestReviewComment",
			ID:   "reactions/create-for-pull-request-review-comment",
		}
	)
	params, err := decodeReactionsCreateForPullRequestReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForPullRequestReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForPullRequestReviewComment",
			OperationID:   "reactions/create-for-pull-request-review-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForPullRequestReviewCommentReq
			Params   = ReactionsCreateForPullRequestReviewCommentParams
			Response = ReactionsCreateForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForPullRequestReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForReleaseRequest handles reactions/create-for-release operation.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (s *Server) handleReactionsCreateForReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForRelease",
			ID:   "reactions/create-for-release",
		}
	)
	params, err := decodeReactionsCreateForReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForRelease",
			OperationID:   "reactions/create-for-release",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"release_id": params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForReleaseReq
			Params   = ReactionsCreateForReleaseParams
			Response = ReactionsCreateForReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForRelease(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentInOrgRequest handles reactions/create-for-team-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForTeamDiscussionCommentInOrg",
			ID:   "reactions/create-for-team-discussion-comment-in-org",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionCommentInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionCommentInOrg",
			OperationID:   "reactions/create-for-team-discussion-comment-in-org",
			Body:          request,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForTeamDiscussionCommentInOrgReq
			Params   = ReactionsCreateForTeamDiscussionCommentInOrgParams
			Response = ReactionsCreateForTeamDiscussionCommentInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentLegacyRequest handles reactions/create-for-team-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForTeamDiscussionCommentLegacy",
			ID:   "reactions/create-for-team-discussion-comment-legacy",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionCommentLegacy",
			OperationID:   "reactions/create-for-team-discussion-comment-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForTeamDiscussionCommentLegacyReq
			Params   = ReactionsCreateForTeamDiscussionCommentLegacyParams
			Response = Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionInOrgRequest handles reactions/create-for-team-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForTeamDiscussionInOrg",
			ID:   "reactions/create-for-team-discussion-in-org",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionInOrg",
			OperationID:   "reactions/create-for-team-discussion-in-org",
			Body:          request,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForTeamDiscussionInOrgReq
			Params   = ReactionsCreateForTeamDiscussionInOrgParams
			Response = ReactionsCreateForTeamDiscussionInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionLegacyRequest handles reactions/create-for-team-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsCreateForTeamDiscussionLegacy",
			ID:   "reactions/create-for-team-discussion-legacy",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionLegacy",
			OperationID:   "reactions/create-for-team-discussion-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = ReactionsCreateForTeamDiscussionLegacyReq
			Params   = ReactionsCreateForTeamDiscussionLegacyParams
			Response = Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForCommitCommentRequest handles reactions/delete-for-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForCommitCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForCommitComment",
			ID:   "reactions/delete-for-commit-comment",
		}
	)
	params, err := decodeReactionsDeleteForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForCommitCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForCommitComment",
			OperationID:   "reactions/delete-for-commit-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"comment_id":  params.CommentID,
				"reaction_id": params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForCommitCommentParams
			Response = ReactionsDeleteForCommitCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForCommitComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForIssueRequest handles reactions/delete-for-issue operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForIssue",
			ID:   "reactions/delete-for-issue",
		}
	)
	params, err := decodeReactionsDeleteForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForIssueNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForIssue",
			OperationID:   "reactions/delete-for-issue",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
				"reaction_id":  params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueParams
			Response = ReactionsDeleteForIssueNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForIssue(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForIssueCommentRequest handles reactions/delete-for-issue-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForIssueComment",
			ID:   "reactions/delete-for-issue-comment",
		}
	)
	params, err := decodeReactionsDeleteForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForIssueCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForIssueComment",
			OperationID:   "reactions/delete-for-issue-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"comment_id":  params.CommentID,
				"reaction_id": params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueCommentParams
			Response = ReactionsDeleteForIssueCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForIssueComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForIssueComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForPullRequestCommentRequest handles reactions/delete-for-pull-request-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForPullRequestCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForPullRequestComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForPullRequestComment",
			ID:   "reactions/delete-for-pull-request-comment",
		}
	)
	params, err := decodeReactionsDeleteForPullRequestCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForPullRequestCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForPullRequestComment",
			OperationID:   "reactions/delete-for-pull-request-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"comment_id":  params.CommentID,
				"reaction_id": params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForPullRequestCommentParams
			Response = ReactionsDeleteForPullRequestCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForPullRequestCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForPullRequestComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForPullRequestComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForTeamDiscussionRequest handles reactions/delete-for-team-discussion operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForTeamDiscussion",
			ID:   "reactions/delete-for-team-discussion",
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForTeamDiscussionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForTeamDiscussion",
			OperationID:   "reactions/delete-for-team-discussion",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"reaction_id":       params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionParams
			Response = ReactionsDeleteForTeamDiscussionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForTeamDiscussionCommentRequest handles reactions/delete-for-team-discussion-comment operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionCommentRequest(args [5]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussionComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteForTeamDiscussionComment",
			ID:   "reactions/delete-for-team-discussion-comment",
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteForTeamDiscussionCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForTeamDiscussionComment",
			OperationID:   "reactions/delete-for-team-discussion-comment",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
				"reaction_id":       params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionCommentParams
			Response = ReactionsDeleteForTeamDiscussionCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteLegacyRequest handles reactions/delete-legacy operation.
//
// DELETE /reactions/{reaction_id}
func (s *Server) handleReactionsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsDeleteLegacy",
			ID:   "reactions/delete-legacy",
		}
	)
	params, err := decodeReactionsDeleteLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteLegacy",
			OperationID:   "reactions/delete-legacy",
			Body:          nil,
			Params: map[string]any{
				"reaction_id": params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteLegacyParams
			Response = ReactionsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsDeleteLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForCommitCommentRequest handles reactions/list-for-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForCommitComment",
			ID:   "reactions/list-for-commit-comment",
		}
	)
	params, err := decodeReactionsListForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForCommitComment",
			OperationID:   "reactions/list-for-commit-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
				"content":    params.Content,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForCommitCommentParams
			Response = ReactionsListForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForCommitComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForIssueRequest handles reactions/list-for-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsListForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForIssue",
			ID:   "reactions/list-for-issue",
		}
	)
	params, err := decodeReactionsListForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForIssue",
			OperationID:   "reactions/list-for-issue",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"issue_number": params.IssueNumber,
				"content":      params.Content,
				"per_page":     params.PerPage,
				"page":         params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueParams
			Response = ReactionsListForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForIssue(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForIssueCommentRequest handles reactions/list-for-issue-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForIssueComment",
			ID:   "reactions/list-for-issue-comment",
		}
	)
	params, err := decodeReactionsListForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForIssueComment",
			OperationID:   "reactions/list-for-issue-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
				"content":    params.Content,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueCommentParams
			Response = ReactionsListForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForIssueComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssueComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForPullRequestReviewCommentRequest handles reactions/list-for-pull-request-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForPullRequestReviewComment",
			ID:   "reactions/list-for-pull-request-review-comment",
		}
	)
	params, err := decodeReactionsListForPullRequestReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForPullRequestReviewComment",
			OperationID:   "reactions/list-for-pull-request-review-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
				"content":    params.Content,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForPullRequestReviewCommentParams
			Response = ReactionsListForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForPullRequestReviewComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForPullRequestReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionCommentInOrgRequest handles reactions/list-for-team-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForTeamDiscussionCommentInOrg",
			ID:   "reactions/list-for-team-discussion-comment-in-org",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForTeamDiscussionCommentInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionCommentInOrg",
			OperationID:   "reactions/list-for-team-discussion-comment-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
				"content":           params.Content,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentInOrgParams
			Response = ReactionsListForTeamDiscussionCommentInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionCommentLegacyRequest handles reactions/list-for-team-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForTeamDiscussionCommentLegacy",
			ID:   "reactions/list-for-team-discussion-comment-legacy",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForTeamDiscussionCommentLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionCommentLegacy",
			OperationID:   "reactions/list-for-team-discussion-comment-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
				"content":           params.Content,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentLegacyParams
			Response = ReactionsListForTeamDiscussionCommentLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionInOrgRequest handles reactions/list-for-team-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForTeamDiscussionInOrg",
			ID:   "reactions/list-for-team-discussion-in-org",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForTeamDiscussionInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionInOrg",
			OperationID:   "reactions/list-for-team-discussion-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"content":           params.Content,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionInOrgParams
			Response = ReactionsListForTeamDiscussionInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionLegacyRequest handles reactions/list-for-team-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReactionsListForTeamDiscussionLegacy",
			ID:   "reactions/list-for-team-discussion-legacy",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForTeamDiscussionLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionLegacy",
			OperationID:   "reactions/list-for-team-discussion-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"content":           params.Content,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionLegacyParams
			Response = ReactionsListForTeamDiscussionLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAcceptInvitationRequest handles repos/accept-invitation operation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (s *Server) handleReposAcceptInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAcceptInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAcceptInvitation",
			ID:   "repos/accept-invitation",
		}
	)
	params, err := decodeReposAcceptInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposAcceptInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAcceptInvitation",
			OperationID:   "repos/accept-invitation",
			Body:          nil,
			Params: map[string]any{
				"invitation_id": params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposAcceptInvitationParams
			Response = ReposAcceptInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAcceptInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAcceptInvitation(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposAcceptInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddAppAccessRestrictionsRequest handles repos/add-app-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposAddAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAddAppAccessRestrictions",
			ID:   "repos/add-app-access-restrictions",
		}
	)
	params, err := decodeReposAddAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddAppAccessRestrictions",
			OperationID:   "repos/add-app-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddAppAccessRestrictionsReq
			Params   = ReposAddAppAccessRestrictionsParams
			Response = ReposAddAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAddAppAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposAddAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddCollaboratorRequest handles repos/add-collaborator operation.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposAddCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAddCollaborator",
			ID:   "repos/add-collaborator",
		}
	)
	params, err := decodeReposAddCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddCollaborator",
			OperationID:   "repos/add-collaborator",
			Body:          request,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddCollaboratorReq
			Params   = ReposAddCollaboratorParams
			Response = ReposAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAddCollaborator(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposAddCollaborator(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddStatusCheckContextsRequest handles repos/add-status-check-contexts operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposAddStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAddStatusCheckContexts",
			ID:   "repos/add-status-check-contexts",
		}
	)
	params, err := decodeReposAddStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddStatusCheckContexts",
			OperationID:   "repos/add-status-check-contexts",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddStatusCheckContextsReq
			Params   = ReposAddStatusCheckContextsParams
			Response = ReposAddStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAddStatusCheckContexts(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposAddStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddTeamAccessRestrictionsRequest handles repos/add-team-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposAddTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAddTeamAccessRestrictions",
			ID:   "repos/add-team-access-restrictions",
		}
	)
	params, err := decodeReposAddTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddTeamAccessRestrictions",
			OperationID:   "repos/add-team-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddTeamAccessRestrictionsReq
			Params   = ReposAddTeamAccessRestrictionsParams
			Response = ReposAddTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddUserAccessRestrictionsRequest handles repos/add-user-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposAddUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposAddUserAccessRestrictions",
			ID:   "repos/add-user-access-restrictions",
		}
	)
	params, err := decodeReposAddUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddUserAccessRestrictions",
			OperationID:   "repos/add-user-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddUserAccessRestrictionsReq
			Params   = ReposAddUserAccessRestrictionsParams
			Response = ReposAddUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposAddUserAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposAddUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCheckCollaboratorRequest handles repos/check-collaborator operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposCheckCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCheckCollaborator",
			ID:   "repos/check-collaborator",
		}
	)
	params, err := decodeReposCheckCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCheckCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCheckCollaborator",
			OperationID:   "repos/check-collaborator",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckCollaboratorParams
			Response = ReposCheckCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCheckCollaborator(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposCheckCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCheckVulnerabilityAlertsRequest handles repos/check-vulnerability-alerts operation.
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposCheckVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCheckVulnerabilityAlerts",
			ID:   "repos/check-vulnerability-alerts",
		}
	)
	params, err := decodeReposCheckVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCheckVulnerabilityAlertsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCheckVulnerabilityAlerts",
			OperationID:   "repos/check-vulnerability-alerts",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckVulnerabilityAlertsParams
			Response = ReposCheckVulnerabilityAlertsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCheckVulnerabilityAlerts(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposCheckVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCompareCommitsRequest handles repos/compare-commits operation.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (s *Server) handleReposCompareCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCompareCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCompareCommits",
			ID:   "repos/compare-commits",
		}
	)
	params, err := decodeReposCompareCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCompareCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCompareCommits",
			OperationID:   "repos/compare-commits",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"page":     params.Page,
				"per_page": params.PerPage,
				"basehead": params.Basehead,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCompareCommitsParams
			Response = ReposCompareCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCompareCommitsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCompareCommits(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposCompareCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateAutolinkRequest handles repos/create-autolink operation.
//
// POST /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposCreateAutolinkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateAutolink",
			ID:   "repos/create-autolink",
		}
	)
	params, err := decodeReposCreateAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateAutolinkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateAutolink",
			OperationID:   "repos/create-autolink",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateAutolinkReq
			Params   = ReposCreateAutolinkParams
			Response = ReposCreateAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateAutolinkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateAutolink(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateAutolink(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitCommentRequest handles repos/create-commit-comment operation.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposCreateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateCommitComment",
			ID:   "repos/create-commit-comment",
		}
	)
	params, err := decodeReposCreateCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitComment",
			OperationID:   "repos/create-commit-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"commit_sha": params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateCommitCommentReq
			Params   = ReposCreateCommitCommentParams
			Response = ReposCreateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateCommitComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitSignatureProtectionRequest handles repos/create-commit-signature-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposCreateCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateCommitSignatureProtection",
			ID:   "repos/create-commit-signature-protection",
		}
	)
	params, err := decodeReposCreateCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCreateCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitSignatureProtection",
			OperationID:   "repos/create-commit-signature-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCreateCommitSignatureProtectionParams
			Response = ReposCreateCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateCommitSignatureProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitStatusRequest handles repos/create-commit-status operation.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (s *Server) handleReposCreateCommitStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateCommitStatus",
			ID:   "repos/create-commit-status",
		}
	)
	params, err := decodeReposCreateCommitStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateCommitStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response StatusHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitStatus",
			OperationID:   "repos/create-commit-status",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"sha":   params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateCommitStatusReq
			Params   = ReposCreateCommitStatusParams
			Response = StatusHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateCommitStatus(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitStatus(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeployKeyRequest handles repos/create-deploy-key operation.
//
// POST /repos/{owner}/{repo}/keys
func (s *Server) handleReposCreateDeployKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateDeployKey",
			ID:   "repos/create-deploy-key",
		}
	)
	params, err := decodeReposCreateDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeployKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeployKey",
			OperationID:   "repos/create-deploy-key",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateDeployKeyReq
			Params   = ReposCreateDeployKeyParams
			Response = ReposCreateDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateDeployKey(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployKey(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeploymentRequest handles repos/create-deployment operation.
//
// POST /repos/{owner}/{repo}/deployments
func (s *Server) handleReposCreateDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateDeployment",
			ID:   "repos/create-deployment",
		}
	)
	params, err := decodeReposCreateDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeploymentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeployment",
			OperationID:   "repos/create-deployment",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateDeploymentReq
			Params   = ReposCreateDeploymentParams
			Response = ReposCreateDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateDeployment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeploymentStatusRequest handles repos/create-deployment-status operation.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposCreateDeploymentStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateDeploymentStatus",
			ID:   "repos/create-deployment-status",
		}
	)
	params, err := decodeReposCreateDeploymentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeploymentStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeploymentStatus",
			OperationID:   "repos/create-deployment-status",
			Body:          request,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"deployment_id": params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateDeploymentStatusReq
			Params   = ReposCreateDeploymentStatusParams
			Response = ReposCreateDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateDeploymentStatus(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateDeploymentStatus(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDispatchEventRequest handles repos/create-dispatch-event operation.
//
// POST /repos/{owner}/{repo}/dispatches
func (s *Server) handleReposCreateDispatchEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDispatchEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateDispatchEvent",
			ID:   "repos/create-dispatch-event",
		}
	)
	params, err := decodeReposCreateDispatchEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDispatchEventRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDispatchEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDispatchEvent",
			OperationID:   "repos/create-dispatch-event",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateDispatchEventReq
			Params   = ReposCreateDispatchEventParams
			Response = ReposCreateDispatchEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDispatchEventParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateDispatchEvent(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateDispatchEvent(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDispatchEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateForAuthenticatedUserRequest handles repos/create-for-authenticated-user operation.
//
// POST /user/repos
func (s *Server) handleReposCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateForAuthenticatedUser",
			ID:   "repos/create-for-authenticated-user",
		}
	)
	request, close, err := s.decodeReposCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateForAuthenticatedUser",
			OperationID:   "repos/create-for-authenticated-user",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = ReposCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ReposCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateForAuthenticatedUser(ctx, request)
			},
		)
	} else {
		response, err = s.h.ReposCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateForkRequest handles repos/create-fork operation.
//
// POST /repos/{owner}/{repo}/forks
func (s *Server) handleReposCreateForkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateFork",
			ID:   "repos/create-fork",
		}
	)
	params, err := decodeReposCreateForkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateForkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateFork",
			OperationID:   "repos/create-fork",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateForkReq
			Params   = ReposCreateForkParams
			Response = ReposCreateForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateForkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateFork(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateFork(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateInOrgRequest handles repos/create-in-org operation.
//
// POST /orgs/{org}/repos
func (s *Server) handleReposCreateInOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateInOrg",
			ID:   "repos/create-in-org",
		}
	)
	params, err := decodeReposCreateInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateInOrg",
			OperationID:   "repos/create-in-org",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateInOrgReq
			Params   = ReposCreateInOrgParams
			Response = ReposCreateInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateOrUpdateFileContentsRequest handles repos/create-or-update-file-contents operation.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposCreateOrUpdateFileContentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateOrUpdateFileContents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateOrUpdateFileContents",
			ID:   "repos/create-or-update-file-contents",
		}
	)
	params, err := decodeReposCreateOrUpdateFileContentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateOrUpdateFileContentsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateOrUpdateFileContentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateOrUpdateFileContents",
			OperationID:   "repos/create-or-update-file-contents",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"path":  params.Path,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateOrUpdateFileContentsReq
			Params   = ReposCreateOrUpdateFileContentsParams
			Response = ReposCreateOrUpdateFileContentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateOrUpdateFileContentsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateOrUpdateFileContentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreatePagesSiteRequest handles repos/create-pages-site operation.
//
// POST /repos/{owner}/{repo}/pages
func (s *Server) handleReposCreatePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreatePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreatePagesSite",
			ID:   "repos/create-pages-site",
		}
	)
	params, err := decodeReposCreatePagesSiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreatePagesSiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreatePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreatePagesSite",
			OperationID:   "repos/create-pages-site",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = NilReposCreatePagesSiteReq
			Params   = ReposCreatePagesSiteParams
			Response = ReposCreatePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreatePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreatePagesSite(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreatePagesSite(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreatePagesSiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateReleaseRequest handles repos/create-release operation.
//
// POST /repos/{owner}/{repo}/releases
func (s *Server) handleReposCreateReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateRelease",
			ID:   "repos/create-release",
		}
	)
	params, err := decodeReposCreateReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateRelease",
			OperationID:   "repos/create-release",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateReleaseReq
			Params   = ReposCreateReleaseParams
			Response = ReposCreateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateRelease(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateUsingTemplateRequest handles repos/create-using-template operation.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (s *Server) handleReposCreateUsingTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateUsingTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateUsingTemplate",
			ID:   "repos/create-using-template",
		}
	)
	params, err := decodeReposCreateUsingTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateUsingTemplateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RepositoryHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateUsingTemplate",
			OperationID:   "repos/create-using-template",
			Body:          request,
			Params: map[string]any{
				"template_owner": params.TemplateOwner,
				"template_repo":  params.TemplateRepo,
			},
			Raw: r,
		}

		type (
			Request  = ReposCreateUsingTemplateReq
			Params   = ReposCreateUsingTemplateParams
			Response = RepositoryHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateUsingTemplateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateUsingTemplate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateUsingTemplate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateWebhookRequest handles repos/create-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks
func (s *Server) handleReposCreateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposCreateWebhook",
			ID:   "repos/create-webhook",
		}
	)
	params, err := decodeReposCreateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateWebhook",
			OperationID:   "repos/create-webhook",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateWebhookReq
			Params   = ReposCreateWebhookParams
			Response = ReposCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposCreateWebhook(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposCreateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeclineInvitationRequest handles repos/decline-invitation operation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (s *Server) handleReposDeclineInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeclineInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeclineInvitation",
			ID:   "repos/decline-invitation",
		}
	)
	params, err := decodeReposDeclineInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeclineInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeclineInvitation",
			OperationID:   "repos/decline-invitation",
			Body:          nil,
			Params: map[string]any{
				"invitation_id": params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeclineInvitationParams
			Response = ReposDeclineInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeclineInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeclineInvitation(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeclineInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteRequest handles repos/delete operation.
//
// DELETE /repos/{owner}/{repo}
func (s *Server) handleReposDeleteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDelete",
			ID:   "repos/delete",
		}
	)
	params, err := decodeReposDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDelete",
			OperationID:   "repos/delete",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteParams
			Response = ReposDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDelete(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAccessRestrictionsRequest handles repos/delete-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposDeleteAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteAccessRestrictions",
			ID:   "repos/delete-access-restrictions",
		}
	)
	params, err := decodeReposDeleteAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAccessRestrictionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAccessRestrictions",
			OperationID:   "repos/delete-access-restrictions",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAccessRestrictionsParams
			Response = ReposDeleteAccessRestrictionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteAccessRestrictions(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteAccessRestrictions(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAdminBranchProtectionRequest handles repos/delete-admin-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposDeleteAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteAdminBranchProtection",
			ID:   "repos/delete-admin-branch-protection",
		}
	)
	params, err := decodeReposDeleteAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAdminBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAdminBranchProtection",
			OperationID:   "repos/delete-admin-branch-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAdminBranchProtectionParams
			Response = ReposDeleteAdminBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteAdminBranchProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAnEnvironmentRequest handles repos/delete-an-environment operation.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (s *Server) handleReposDeleteAnEnvironmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAnEnvironment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteAnEnvironment",
			ID:   "repos/delete-an-environment",
		}
	)
	params, err := decodeReposDeleteAnEnvironmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAnEnvironmentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAnEnvironment",
			OperationID:   "repos/delete-an-environment",
			Body:          nil,
			Params: map[string]any{
				"owner":            params.Owner,
				"repo":             params.Repo,
				"environment_name": params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAnEnvironmentParams
			Response = ReposDeleteAnEnvironmentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAnEnvironmentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteAnEnvironment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteAnEnvironment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAutolinkRequest handles repos/delete-autolink operation.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposDeleteAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteAutolink",
			ID:   "repos/delete-autolink",
		}
	)
	params, err := decodeReposDeleteAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAutolink",
			OperationID:   "repos/delete-autolink",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"autolink_id": params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAutolinkParams
			Response = ReposDeleteAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAutolinkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteAutolink(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteAutolink(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteBranchProtectionRequest handles repos/delete-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposDeleteBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteBranchProtection",
			ID:   "repos/delete-branch-protection",
		}
	)
	params, err := decodeReposDeleteBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteBranchProtection",
			OperationID:   "repos/delete-branch-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteBranchProtectionParams
			Response = ReposDeleteBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteBranchProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteCommitCommentRequest handles repos/delete-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposDeleteCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteCommitComment",
			ID:   "repos/delete-commit-comment",
		}
	)
	params, err := decodeReposDeleteCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteCommitComment",
			OperationID:   "repos/delete-commit-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitCommentParams
			Response = ReposDeleteCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteCommitComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteCommitSignatureProtectionRequest handles repos/delete-commit-signature-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposDeleteCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteCommitSignatureProtection",
			ID:   "repos/delete-commit-signature-protection",
		}
	)
	params, err := decodeReposDeleteCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteCommitSignatureProtection",
			OperationID:   "repos/delete-commit-signature-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitSignatureProtectionParams
			Response = ReposDeleteCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteCommitSignatureProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteDeployKeyRequest handles repos/delete-deploy-key operation.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposDeleteDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteDeployKey",
			ID:   "repos/delete-deploy-key",
		}
	)
	params, err := decodeReposDeleteDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteDeployKeyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteDeployKey",
			OperationID:   "repos/delete-deploy-key",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"key_id": params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeployKeyParams
			Response = ReposDeleteDeployKeyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteDeployKey(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteDeployKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteDeploymentRequest handles repos/delete-deployment operation.
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposDeleteDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteDeployment",
			ID:   "repos/delete-deployment",
		}
	)
	params, err := decodeReposDeleteDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteDeployment",
			OperationID:   "repos/delete-deployment",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"deployment_id": params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeploymentParams
			Response = ReposDeleteDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteDeployment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteFileRequest handles repos/delete-file operation.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposDeleteFileRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteFile",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteFile",
			ID:   "repos/delete-file",
		}
	)
	params, err := decodeReposDeleteFileParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposDeleteFileRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposDeleteFileRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteFile",
			OperationID:   "repos/delete-file",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"path":  params.Path,
			},
			Raw: r,
		}

		type (
			Request  = ReposDeleteFileReq
			Params   = ReposDeleteFileParams
			Response = ReposDeleteFileRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteFileParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteFile(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteFile(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteFileResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteInvitationRequest handles repos/delete-invitation operation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposDeleteInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteInvitation",
			ID:   "repos/delete-invitation",
		}
	)
	params, err := decodeReposDeleteInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteInvitationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteInvitation",
			OperationID:   "repos/delete-invitation",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"invitation_id": params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteInvitationParams
			Response = ReposDeleteInvitationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteInvitation(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeletePagesSiteRequest handles repos/delete-pages-site operation.
//
// DELETE /repos/{owner}/{repo}/pages
func (s *Server) handleReposDeletePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeletePagesSite",
			ID:   "repos/delete-pages-site",
		}
	)
	params, err := decodeReposDeletePagesSiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeletePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeletePagesSite",
			OperationID:   "repos/delete-pages-site",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePagesSiteParams
			Response = ReposDeletePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeletePagesSite(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeletePagesSite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePagesSiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeletePullRequestReviewProtectionRequest handles repos/delete-pull-request-review-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposDeletePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeletePullRequestReviewProtection",
			ID:   "repos/delete-pull-request-review-protection",
		}
	)
	params, err := decodeReposDeletePullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeletePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeletePullRequestReviewProtection",
			OperationID:   "repos/delete-pull-request-review-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePullRequestReviewProtectionParams
			Response = ReposDeletePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeletePullRequestReviewProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeletePullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteReleaseRequest handles repos/delete-release operation.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposDeleteReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteRelease",
			ID:   "repos/delete-release",
		}
	)
	params, err := decodeReposDeleteReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteReleaseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteRelease",
			OperationID:   "repos/delete-release",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"release_id": params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseParams
			Response = ReposDeleteReleaseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteRelease(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteReleaseAssetRequest handles repos/delete-release-asset operation.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposDeleteReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteReleaseAsset",
			ID:   "repos/delete-release-asset",
		}
	)
	params, err := decodeReposDeleteReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteReleaseAssetNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteReleaseAsset",
			OperationID:   "repos/delete-release-asset",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"asset_id": params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseAssetParams
			Response = ReposDeleteReleaseAssetNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteReleaseAsset(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteReleaseAsset(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteWebhookRequest handles repos/delete-webhook operation.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposDeleteWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDeleteWebhook",
			ID:   "repos/delete-webhook",
		}
	)
	params, err := decodeReposDeleteWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteWebhook",
			OperationID:   "repos/delete-webhook",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteWebhookParams
			Response = ReposDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDeleteWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDeleteWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableAutomatedSecurityFixesRequest handles repos/disable-automated-security-fixes operation.
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposDisableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDisableAutomatedSecurityFixes",
			ID:   "repos/disable-automated-security-fixes",
		}
	)
	params, err := decodeReposDisableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDisableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableAutomatedSecurityFixes",
			OperationID:   "repos/disable-automated-security-fixes",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableAutomatedSecurityFixesParams
			Response = ReposDisableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableLfsForRepoRequest handles repos/disable-lfs-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/lfs
func (s *Server) handleReposDisableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDisableLfsForRepo",
			ID:   "repos/disable-lfs-for-repo",
		}
	)
	params, err := decodeReposDisableLfsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDisableLfsForRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableLfsForRepo",
			OperationID:   "repos/disable-lfs-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableLfsForRepoParams
			Response = ReposDisableLfsForRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDisableLfsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDisableLfsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableVulnerabilityAlertsRequest handles repos/disable-vulnerability-alerts operation.
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposDisableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDisableVulnerabilityAlerts",
			ID:   "repos/disable-vulnerability-alerts",
		}
	)
	params, err := decodeReposDisableVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDisableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableVulnerabilityAlerts",
			OperationID:   "repos/disable-vulnerability-alerts",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableVulnerabilityAlertsParams
			Response = ReposDisableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDisableVulnerabilityAlerts(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDisableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDownloadTarballArchiveRequest handles repos/download-tarball-archive operation.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (s *Server) handleReposDownloadTarballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadTarballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDownloadTarballArchive",
			ID:   "repos/download-tarball-archive",
		}
	)
	params, err := decodeReposDownloadTarballArchiveParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDownloadTarballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDownloadTarballArchive",
			OperationID:   "repos/download-tarball-archive",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadTarballArchiveParams
			Response = ReposDownloadTarballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadTarballArchiveParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDownloadTarballArchive(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDownloadTarballArchive(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDownloadZipballArchiveRequest handles repos/download-zipball-archive operation.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (s *Server) handleReposDownloadZipballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadZipballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposDownloadZipballArchive",
			ID:   "repos/download-zipball-archive",
		}
	)
	params, err := decodeReposDownloadZipballArchiveParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDownloadZipballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDownloadZipballArchive",
			OperationID:   "repos/download-zipball-archive",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadZipballArchiveParams
			Response = ReposDownloadZipballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadZipballArchiveParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposDownloadZipballArchive(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposDownloadZipballArchive(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableAutomatedSecurityFixesRequest handles repos/enable-automated-security-fixes operation.
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposEnableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposEnableAutomatedSecurityFixes",
			ID:   "repos/enable-automated-security-fixes",
		}
	)
	params, err := decodeReposEnableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposEnableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableAutomatedSecurityFixes",
			OperationID:   "repos/enable-automated-security-fixes",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableAutomatedSecurityFixesParams
			Response = ReposEnableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableLfsForRepoRequest handles repos/enable-lfs-for-repo operation.
//
// PUT /repos/{owner}/{repo}/lfs
func (s *Server) handleReposEnableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposEnableLfsForRepo",
			ID:   "repos/enable-lfs-for-repo",
		}
	)
	params, err := decodeReposEnableLfsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposEnableLfsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableLfsForRepo",
			OperationID:   "repos/enable-lfs-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableLfsForRepoParams
			Response = ReposEnableLfsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposEnableLfsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposEnableLfsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableVulnerabilityAlertsRequest handles repos/enable-vulnerability-alerts operation.
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposEnableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposEnableVulnerabilityAlerts",
			ID:   "repos/enable-vulnerability-alerts",
		}
	)
	params, err := decodeReposEnableVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposEnableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableVulnerabilityAlerts",
			OperationID:   "repos/enable-vulnerability-alerts",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableVulnerabilityAlertsParams
			Response = ReposEnableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposEnableVulnerabilityAlerts(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposEnableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetRequest handles repos/get operation.
//
// GET /repos/{owner}/{repo}
func (s *Server) handleReposGetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGet",
			ID:   "repos/get",
		}
	)
	params, err := decodeReposGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGet",
			OperationID:   "repos/get",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParams
			Response = ReposGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAccessRestrictionsRequest handles repos/get-access-restrictions operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposGetAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAccessRestrictions",
			ID:   "repos/get-access-restrictions",
		}
	)
	params, err := decodeReposGetAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAccessRestrictions",
			OperationID:   "repos/get-access-restrictions",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAccessRestrictionsParams
			Response = ReposGetAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAccessRestrictions(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAccessRestrictions(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAdminBranchProtectionRequest handles repos/get-admin-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposGetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAdminBranchProtection",
			ID:   "repos/get-admin-branch-protection",
		}
	)
	params, err := decodeReposGetAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAdminBranchProtection",
			OperationID:   "repos/get-admin-branch-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAdminBranchProtectionParams
			Response = ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAdminBranchProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAllStatusCheckContextsRequest handles repos/get-all-status-check-contexts operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposGetAllStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAllStatusCheckContexts",
			ID:   "repos/get-all-status-check-contexts",
		}
	)
	params, err := decodeReposGetAllStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAllStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAllStatusCheckContexts",
			OperationID:   "repos/get-all-status-check-contexts",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllStatusCheckContextsParams
			Response = ReposGetAllStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAllStatusCheckContexts(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAllStatusCheckContexts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAllTopicsRequest handles repos/get-all-topics operation.
//
// GET /repos/{owner}/{repo}/topics
func (s *Server) handleReposGetAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAllTopics",
			ID:   "repos/get-all-topics",
		}
	)
	params, err := decodeReposGetAllTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAllTopics",
			OperationID:   "repos/get-all-topics",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"page":     params.Page,
				"per_page": params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllTopicsParams
			Response = ReposGetAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAllTopics(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAllTopics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAppsWithAccessToProtectedBranchRequest handles repos/get-apps-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposGetAppsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAppsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAppsWithAccessToProtectedBranch",
			ID:   "repos/get-apps-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAppsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAppsWithAccessToProtectedBranch",
			OperationID:   "repos/get-apps-with-access-to-protected-branch",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAppsWithAccessToProtectedBranchParams
			Response = ReposGetAppsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAppsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAutolinkRequest handles repos/get-autolink operation.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposGetAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetAutolink",
			ID:   "repos/get-autolink",
		}
	)
	params, err := decodeReposGetAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAutolink",
			OperationID:   "repos/get-autolink",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"autolink_id": params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAutolinkParams
			Response = ReposGetAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAutolinkParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetAutolink(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetAutolink(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetBranchRequest handles repos/get-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (s *Server) handleReposGetBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetBranch",
			ID:   "repos/get-branch",
		}
	)
	params, err := decodeReposGetBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetBranch",
			OperationID:   "repos/get-branch",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchParams
			Response = ReposGetBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetBranch(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetBranchProtectionRequest handles repos/get-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposGetBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetBranchProtection",
			ID:   "repos/get-branch-protection",
		}
	)
	params, err := decodeReposGetBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetBranchProtection",
			OperationID:   "repos/get-branch-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchProtectionParams
			Response = ReposGetBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetBranchProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetClonesRequest handles repos/get-clones operation.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (s *Server) handleReposGetClonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetClones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetClones",
			ID:   "repos/get-clones",
		}
	)
	params, err := decodeReposGetClonesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetClonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetClones",
			OperationID:   "repos/get-clones",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"per":   params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetClonesParams
			Response = ReposGetClonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetClonesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetClones(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetClones(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetClonesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCodeFrequencyStatsRequest handles repos/get-code-frequency-stats operation.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (s *Server) handleReposGetCodeFrequencyStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCodeFrequencyStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCodeFrequencyStats",
			ID:   "repos/get-code-frequency-stats",
		}
	)
	params, err := decodeReposGetCodeFrequencyStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCodeFrequencyStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCodeFrequencyStats",
			OperationID:   "repos/get-code-frequency-stats",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCodeFrequencyStatsParams
			Response = ReposGetCodeFrequencyStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCodeFrequencyStatsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCodeFrequencyStats(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCodeFrequencyStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCollaboratorPermissionLevelRequest handles repos/get-collaborator-permission-level operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (s *Server) handleReposGetCollaboratorPermissionLevelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCollaboratorPermissionLevel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCollaboratorPermissionLevel",
			ID:   "repos/get-collaborator-permission-level",
		}
	)
	params, err := decodeReposGetCollaboratorPermissionLevelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCollaboratorPermissionLevelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCollaboratorPermissionLevel",
			OperationID:   "repos/get-collaborator-permission-level",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCollaboratorPermissionLevelParams
			Response = ReposGetCollaboratorPermissionLevelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCollaboratorPermissionLevelParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCombinedStatusForRefRequest handles repos/get-combined-status-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (s *Server) handleReposGetCombinedStatusForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCombinedStatusForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCombinedStatusForRef",
			ID:   "repos/get-combined-status-for-ref",
		}
	)
	params, err := decodeReposGetCombinedStatusForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCombinedStatusForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCombinedStatusForRef",
			OperationID:   "repos/get-combined-status-for-ref",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"ref":      params.Ref,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCombinedStatusForRefParams
			Response = ReposGetCombinedStatusForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCombinedStatusForRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCombinedStatusForRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCombinedStatusForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitRequest handles repos/get-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (s *Server) handleReposGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCommit",
			ID:   "repos/get-commit",
		}
	)
	params, err := decodeReposGetCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommit",
			OperationID:   "repos/get-commit",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"page":     params.Page,
				"per_page": params.PerPage,
				"ref":      params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitParams
			Response = ReposGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCommit(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitActivityStatsRequest handles repos/get-commit-activity-stats operation.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (s *Server) handleReposGetCommitActivityStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitActivityStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCommitActivityStats",
			ID:   "repos/get-commit-activity-stats",
		}
	)
	params, err := decodeReposGetCommitActivityStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitActivityStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitActivityStats",
			OperationID:   "repos/get-commit-activity-stats",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitActivityStatsParams
			Response = ReposGetCommitActivityStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitActivityStatsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCommitActivityStats(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCommitActivityStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitCommentRequest handles repos/get-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposGetCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCommitComment",
			ID:   "repos/get-commit-comment",
		}
	)
	params, err := decodeReposGetCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitComment",
			OperationID:   "repos/get-commit-comment",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitCommentParams
			Response = ReposGetCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCommitComment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitSignatureProtectionRequest handles repos/get-commit-signature-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposGetCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCommitSignatureProtection",
			ID:   "repos/get-commit-signature-protection",
		}
	)
	params, err := decodeReposGetCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitSignatureProtection",
			OperationID:   "repos/get-commit-signature-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitSignatureProtectionParams
			Response = ReposGetCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCommitSignatureProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommunityProfileMetricsRequest handles repos/get-community-profile-metrics operation.
//
// GET /repos/{owner}/{repo}/community/profile
func (s *Server) handleReposGetCommunityProfileMetricsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommunityProfileMetrics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetCommunityProfileMetrics",
			ID:   "repos/get-community-profile-metrics",
		}
	)
	params, err := decodeReposGetCommunityProfileMetricsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CommunityProfile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommunityProfileMetrics",
			OperationID:   "repos/get-community-profile-metrics",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommunityProfileMetricsParams
			Response = CommunityProfile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommunityProfileMetricsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetCommunityProfileMetrics(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetCommunityProfileMetrics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetContributorsStatsRequest handles repos/get-contributors-stats operation.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (s *Server) handleReposGetContributorsStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetContributorsStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetContributorsStats",
			ID:   "repos/get-contributors-stats",
		}
	)
	params, err := decodeReposGetContributorsStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetContributorsStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetContributorsStats",
			OperationID:   "repos/get-contributors-stats",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetContributorsStatsParams
			Response = ReposGetContributorsStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetContributorsStatsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetContributorsStats(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetContributorsStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeployKeyRequest handles repos/get-deploy-key operation.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposGetDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetDeployKey",
			ID:   "repos/get-deploy-key",
		}
	)
	params, err := decodeReposGetDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeployKey",
			OperationID:   "repos/get-deploy-key",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"key_id": params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeployKeyParams
			Response = ReposGetDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetDeployKey(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetDeployKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeploymentRequest handles repos/get-deployment operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposGetDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetDeployment",
			ID:   "repos/get-deployment",
		}
	)
	params, err := decodeReposGetDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeployment",
			OperationID:   "repos/get-deployment",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"deployment_id": params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentParams
			Response = ReposGetDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetDeployment(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeploymentStatusRequest handles repos/get-deployment-status operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (s *Server) handleReposGetDeploymentStatusRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetDeploymentStatus",
			ID:   "repos/get-deployment-status",
		}
	)
	params, err := decodeReposGetDeploymentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeploymentStatus",
			OperationID:   "repos/get-deployment-status",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"deployment_id": params.DeploymentID,
				"status_id":     params.StatusID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentStatusParams
			Response = ReposGetDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetDeploymentStatus(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetDeploymentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetLatestPagesBuildRequest handles repos/get-latest-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (s *Server) handleReposGetLatestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetLatestPagesBuild",
			ID:   "repos/get-latest-pages-build",
		}
	)
	params, err := decodeReposGetLatestPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetLatestPagesBuild",
			OperationID:   "repos/get-latest-pages-build",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestPagesBuildParams
			Response = PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetLatestPagesBuild(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetLatestPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetLatestReleaseRequest handles repos/get-latest-release operation.
//
// GET /repos/{owner}/{repo}/releases/latest
func (s *Server) handleReposGetLatestReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetLatestRelease",
			ID:   "repos/get-latest-release",
		}
	)
	params, err := decodeReposGetLatestReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Release
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetLatestRelease",
			OperationID:   "repos/get-latest-release",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestReleaseParams
			Response = Release
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetLatestRelease(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetLatestRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesRequest handles repos/get-pages operation.
//
// GET /repos/{owner}/{repo}/pages
func (s *Server) handleReposGetPagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetPages",
			ID:   "repos/get-pages",
		}
	)
	params, err := decodeReposGetPagesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPagesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPages",
			OperationID:   "repos/get-pages",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesParams
			Response = ReposGetPagesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetPages(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetPages(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesBuildRequest handles repos/get-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (s *Server) handleReposGetPagesBuildRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetPagesBuild",
			ID:   "repos/get-pages-build",
		}
	)
	params, err := decodeReposGetPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPagesBuild",
			OperationID:   "repos/get-pages-build",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"build_id": params.BuildID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesBuildParams
			Response = PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetPagesBuild(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesHealthCheckRequest handles repos/get-pages-health-check operation.
//
// GET /repos/{owner}/{repo}/pages/health
func (s *Server) handleReposGetPagesHealthCheckRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesHealthCheck",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetPagesHealthCheck",
			ID:   "repos/get-pages-health-check",
		}
	)
	params, err := decodeReposGetPagesHealthCheckParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPagesHealthCheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPagesHealthCheck",
			OperationID:   "repos/get-pages-health-check",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesHealthCheckParams
			Response = ReposGetPagesHealthCheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesHealthCheckParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetPagesHealthCheck(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetPagesHealthCheck(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetParticipationStatsRequest handles repos/get-participation-stats operation.
//
// GET /repos/{owner}/{repo}/stats/participation
func (s *Server) handleReposGetParticipationStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetParticipationStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetParticipationStats",
			ID:   "repos/get-participation-stats",
		}
	)
	params, err := decodeReposGetParticipationStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetParticipationStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetParticipationStats",
			OperationID:   "repos/get-participation-stats",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParticipationStatsParams
			Response = ReposGetParticipationStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParticipationStatsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetParticipationStats(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetParticipationStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPullRequestReviewProtectionRequest handles repos/get-pull-request-review-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposGetPullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetPullRequestReviewProtection",
			ID:   "repos/get-pull-request-review-protection",
		}
	)
	params, err := decodeReposGetPullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProtectedBranchPullRequestReview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPullRequestReviewProtection",
			OperationID:   "repos/get-pull-request-review-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPullRequestReviewProtectionParams
			Response = ProtectedBranchPullRequestReview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetPullRequestReviewProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetPullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPunchCardStatsRequest handles repos/get-punch-card-stats operation.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (s *Server) handleReposGetPunchCardStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPunchCardStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetPunchCardStats",
			ID:   "repos/get-punch-card-stats",
		}
	)
	params, err := decodeReposGetPunchCardStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPunchCardStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPunchCardStats",
			OperationID:   "repos/get-punch-card-stats",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPunchCardStatsParams
			Response = ReposGetPunchCardStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPunchCardStatsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetPunchCardStats(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetPunchCardStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReadmeRequest handles repos/get-readme operation.
//
// GET /repos/{owner}/{repo}/readme
func (s *Server) handleReposGetReadmeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadme",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetReadme",
			ID:   "repos/get-readme",
		}
	)
	params, err := decodeReposGetReadmeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReadmeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReadme",
			OperationID:   "repos/get-readme",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeParams
			Response = ReposGetReadmeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetReadme(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetReadme(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReadmeInDirectoryRequest handles repos/get-readme-in-directory operation.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (s *Server) handleReposGetReadmeInDirectoryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadmeInDirectory",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetReadmeInDirectory",
			ID:   "repos/get-readme-in-directory",
		}
	)
	params, err := decodeReposGetReadmeInDirectoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReadmeInDirectoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReadmeInDirectory",
			OperationID:   "repos/get-readme-in-directory",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"dir":   params.Dir,
				"ref":   params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeInDirectoryParams
			Response = ReposGetReadmeInDirectoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeInDirectoryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetReadmeInDirectory(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetReadmeInDirectory(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeInDirectoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseRequest handles repos/get-release operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposGetReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetRelease",
			ID:   "repos/get-release",
		}
	)
	params, err := decodeReposGetReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetRelease",
			OperationID:   "repos/get-release",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"release_id": params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseParams
			Response = ReposGetReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetRelease(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseAssetRequest handles repos/get-release-asset operation.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposGetReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetReleaseAsset",
			ID:   "repos/get-release-asset",
		}
	)
	params, err := decodeReposGetReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseAssetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReleaseAsset",
			OperationID:   "repos/get-release-asset",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"asset_id": params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseAssetParams
			Response = ReposGetReleaseAssetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetReleaseAsset(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseAsset(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseByTagRequest handles repos/get-release-by-tag operation.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (s *Server) handleReposGetReleaseByTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseByTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetReleaseByTag",
			ID:   "repos/get-release-by-tag",
		}
	)
	params, err := decodeReposGetReleaseByTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseByTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReleaseByTag",
			OperationID:   "repos/get-release-by-tag",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"tag":   params.Tag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseByTagParams
			Response = ReposGetReleaseByTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseByTagParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetReleaseByTag(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseByTag(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetStatusChecksProtectionRequest handles repos/get-status-checks-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposGetStatusChecksProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetStatusChecksProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetStatusChecksProtection",
			ID:   "repos/get-status-checks-protection",
		}
	)
	params, err := decodeReposGetStatusChecksProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetStatusChecksProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetStatusChecksProtection",
			OperationID:   "repos/get-status-checks-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetStatusChecksProtectionParams
			Response = ReposGetStatusChecksProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetStatusChecksProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetStatusChecksProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetStatusChecksProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTeamsWithAccessToProtectedBranchRequest handles repos/get-teams-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposGetTeamsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTeamsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetTeamsWithAccessToProtectedBranch",
			ID:   "repos/get-teams-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTeamsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTeamsWithAccessToProtectedBranch",
			OperationID:   "repos/get-teams-with-access-to-protected-branch",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTeamsWithAccessToProtectedBranchParams
			Response = ReposGetTeamsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTeamsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTopPathsRequest handles repos/get-top-paths operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (s *Server) handleReposGetTopPathsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopPaths",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetTopPaths",
			ID:   "repos/get-top-paths",
		}
	)
	params, err := decodeReposGetTopPathsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTopPathsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTopPaths",
			OperationID:   "repos/get-top-paths",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopPathsParams
			Response = ReposGetTopPathsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopPathsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetTopPaths(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetTopPaths(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTopReferrersRequest handles repos/get-top-referrers operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (s *Server) handleReposGetTopReferrersRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopReferrers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetTopReferrers",
			ID:   "repos/get-top-referrers",
		}
	)
	params, err := decodeReposGetTopReferrersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTopReferrersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTopReferrers",
			OperationID:   "repos/get-top-referrers",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopReferrersParams
			Response = ReposGetTopReferrersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopReferrersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetTopReferrers(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetTopReferrers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetUsersWithAccessToProtectedBranchRequest handles repos/get-users-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposGetUsersWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetUsersWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetUsersWithAccessToProtectedBranch",
			ID:   "repos/get-users-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetUsersWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetUsersWithAccessToProtectedBranch",
			OperationID:   "repos/get-users-with-access-to-protected-branch",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetUsersWithAccessToProtectedBranchParams
			Response = ReposGetUsersWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetUsersWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetViewsRequest handles repos/get-views operation.
//
// GET /repos/{owner}/{repo}/traffic/views
func (s *Server) handleReposGetViewsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetViews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetViews",
			ID:   "repos/get-views",
		}
	)
	params, err := decodeReposGetViewsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetViewsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetViews",
			OperationID:   "repos/get-views",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"per":   params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetViewsParams
			Response = ReposGetViewsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetViewsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetViews(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetViews(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetViewsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookRequest handles repos/get-webhook operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposGetWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetWebhook",
			ID:   "repos/get-webhook",
		}
	)
	params, err := decodeReposGetWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhook",
			OperationID:   "repos/get-webhook",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookParams
			Response = ReposGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookConfigForRepoRequest handles repos/get-webhook-config-for-repo operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposGetWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetWebhookConfigForRepo",
			ID:   "repos/get-webhook-config-for-repo",
		}
	)
	params, err := decodeReposGetWebhookConfigForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhookConfigForRepo",
			OperationID:   "repos/get-webhook-config-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookConfigForRepoParams
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetWebhookConfigForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookConfigForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookDeliveryRequest handles repos/get-webhook-delivery operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleReposGetWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposGetWebhookDelivery",
			ID:   "repos/get-webhook-delivery",
		}
	)
	params, err := decodeReposGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhookDelivery",
			OperationID:   "repos/get-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"hook_id":     params.HookID,
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookDeliveryParams
			Response = ReposGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposGetWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListAutolinksRequest handles repos/list-autolinks operation.
//
// GET /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposListAutolinksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListAutolinks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListAutolinks",
			ID:   "repos/list-autolinks",
		}
	)
	params, err := decodeReposListAutolinksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Autolink
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListAutolinks",
			OperationID:   "repos/list-autolinks",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
				"page":  params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListAutolinksParams
			Response = []Autolink
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListAutolinksParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListAutolinks(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListAutolinks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListBranchesRequest handles repos/list-branches operation.
//
// GET /repos/{owner}/{repo}/branches
func (s *Server) handleReposListBranchesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranches",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListBranches",
			ID:   "repos/list-branches",
		}
	)
	params, err := decodeReposListBranchesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListBranchesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListBranches",
			OperationID:   "repos/list-branches",
			Body:          nil,
			Params: map[string]any{
				"owner":     params.Owner,
				"repo":      params.Repo,
				"protected": params.Protected,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesParams
			Response = ReposListBranchesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListBranches(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListBranches(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListBranchesForHeadCommitRequest handles repos/list-branches-for-head-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (s *Server) handleReposListBranchesForHeadCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranchesForHeadCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListBranchesForHeadCommit",
			ID:   "repos/list-branches-for-head-commit",
		}
	)
	params, err := decodeReposListBranchesForHeadCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListBranchesForHeadCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListBranchesForHeadCommit",
			OperationID:   "repos/list-branches-for-head-commit",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"commit_sha": params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesForHeadCommitParams
			Response = ReposListBranchesForHeadCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesForHeadCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListBranchesForHeadCommit(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListBranchesForHeadCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesForHeadCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCollaboratorsRequest handles repos/list-collaborators operation.
//
// GET /repos/{owner}/{repo}/collaborators
func (s *Server) handleReposListCollaboratorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListCollaborators",
			ID:   "repos/list-collaborators",
		}
	)
	params, err := decodeReposListCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCollaborators",
			OperationID:   "repos/list-collaborators",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"affiliation": params.Affiliation,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCollaboratorsParams
			Response = ReposListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListCollaborators(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommentsForCommitRequest handles repos/list-comments-for-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposListCommentsForCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommentsForCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListCommentsForCommit",
			ID:   "repos/list-comments-for-commit",
		}
	)
	params, err := decodeReposListCommentsForCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommentsForCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommentsForCommit",
			OperationID:   "repos/list-comments-for-commit",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"commit_sha": params.CommitSha,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommentsForCommitParams
			Response = ReposListCommentsForCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommentsForCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListCommentsForCommit(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListCommentsForCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitCommentsForRepoRequest handles repos/list-commit-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/comments
func (s *Server) handleReposListCommitCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListCommitCommentsForRepo",
			ID:   "repos/list-commit-comments-for-repo",
		}
	)
	params, err := decodeReposListCommitCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommitCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommitCommentsForRepo",
			OperationID:   "repos/list-commit-comments-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitCommentsForRepoParams
			Response = ReposListCommitCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListCommitCommentsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListCommitCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitStatusesForRefRequest handles repos/list-commit-statuses-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (s *Server) handleReposListCommitStatusesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitStatusesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListCommitStatusesForRef",
			ID:   "repos/list-commit-statuses-for-ref",
		}
	)
	params, err := decodeReposListCommitStatusesForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommitStatusesForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommitStatusesForRef",
			OperationID:   "repos/list-commit-statuses-for-ref",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"ref":      params.Ref,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitStatusesForRefParams
			Response = ReposListCommitStatusesForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitStatusesForRefParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListCommitStatusesForRef(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListCommitStatusesForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitsRequest handles repos/list-commits operation.
//
// GET /repos/{owner}/{repo}/commits
func (s *Server) handleReposListCommitsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListCommits",
			ID:   "repos/list-commits",
		}
	)
	params, err := decodeReposListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommits",
			OperationID:   "repos/list-commits",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"sha":      params.Sha,
				"path":     params.Path,
				"author":   params.Author,
				"since":    params.Since,
				"until":    params.Until,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitsParams
			Response = ReposListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListCommits(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListContributorsRequest handles repos/list-contributors operation.
//
// GET /repos/{owner}/{repo}/contributors
func (s *Server) handleReposListContributorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListContributors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListContributors",
			ID:   "repos/list-contributors",
		}
	)
	params, err := decodeReposListContributorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListContributorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListContributors",
			OperationID:   "repos/list-contributors",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"anon":     params.Anon,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListContributorsParams
			Response = ReposListContributorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListContributorsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListContributors(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListContributors(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListContributorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeployKeysRequest handles repos/list-deploy-keys operation.
//
// GET /repos/{owner}/{repo}/keys
func (s *Server) handleReposListDeployKeysRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployKeys",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListDeployKeys",
			ID:   "repos/list-deploy-keys",
		}
	)
	params, err := decodeReposListDeployKeysParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListDeployKeysOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeployKeys",
			OperationID:   "repos/list-deploy-keys",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeployKeysParams
			Response = ReposListDeployKeysOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeployKeysParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListDeployKeys(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListDeployKeys(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeploymentStatusesRequest handles repos/list-deployment-statuses operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposListDeploymentStatusesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeploymentStatuses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListDeploymentStatuses",
			ID:   "repos/list-deployment-statuses",
		}
	)
	params, err := decodeReposListDeploymentStatusesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListDeploymentStatusesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeploymentStatuses",
			OperationID:   "repos/list-deployment-statuses",
			Body:          nil,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"deployment_id": params.DeploymentID,
				"per_page":      params.PerPage,
				"page":          params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentStatusesParams
			Response = ReposListDeploymentStatusesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentStatusesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListDeploymentStatuses(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListDeploymentStatuses(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeploymentsRequest handles repos/list-deployments operation.
//
// GET /repos/{owner}/{repo}/deployments
func (s *Server) handleReposListDeploymentsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListDeployments",
			ID:   "repos/list-deployments",
		}
	)
	params, err := decodeReposListDeploymentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListDeploymentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeployments",
			OperationID:   "repos/list-deployments",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"sha":         params.Sha,
				"ref":         params.Ref,
				"task":        params.Task,
				"environment": params.Environment,
				"per_page":    params.PerPage,
				"page":        params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentsParams
			Response = ReposListDeploymentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListDeployments(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListDeployments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForAuthenticatedUserRequest handles repos/list-for-authenticated-user operation.
//
// GET /user/repos
func (s *Server) handleReposListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListForAuthenticatedUser",
			ID:   "repos/list-for-authenticated-user",
		}
	)
	params, err := decodeReposListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForAuthenticatedUser",
			OperationID:   "repos/list-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"visibility":  params.Visibility,
				"affiliation": params.Affiliation,
				"type":        params.Type,
				"sort":        params.Sort,
				"direction":   params.Direction,
				"per_page":    params.PerPage,
				"page":        params.Page,
				"since":       params.Since,
				"before":      params.Before,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForAuthenticatedUserParams
			Response = ReposListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForOrgRequest handles repos/list-for-org operation.
//
// GET /orgs/{org}/repos
func (s *Server) handleReposListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListForOrg",
			ID:   "repos/list-for-org",
		}
	)
	params, err := decodeReposListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForOrg",
			OperationID:   "repos/list-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"type":      params.Type,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForOrgParams
			Response = ReposListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForUserRequest handles repos/list-for-user operation.
//
// GET /users/{username}/repos
func (s *Server) handleReposListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListForUser",
			ID:   "repos/list-for-user",
		}
	)
	params, err := decodeReposListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForUser",
			OperationID:   "repos/list-for-user",
			Body:          nil,
			Params: map[string]any{
				"username":  params.Username,
				"type":      params.Type,
				"sort":      params.Sort,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForUserParams
			Response = ReposListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForksRequest handles repos/list-forks operation.
//
// GET /repos/{owner}/{repo}/forks
func (s *Server) handleReposListForksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListForks",
			ID:   "repos/list-forks",
		}
	)
	params, err := decodeReposListForksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForks",
			OperationID:   "repos/list-forks",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"sort":     params.Sort,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForksParams
			Response = ReposListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForksParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListForks(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListForks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListInvitationsRequest handles repos/list-invitations operation.
//
// GET /repos/{owner}/{repo}/invitations
func (s *Server) handleReposListInvitationsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListInvitations",
			ID:   "repos/list-invitations",
		}
	)
	params, err := decodeReposListInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListInvitationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListInvitations",
			OperationID:   "repos/list-invitations",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsParams
			Response = ReposListInvitationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListInvitations(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListInvitationsForAuthenticatedUserRequest handles repos/list-invitations-for-authenticated-user operation.
//
// GET /user/repository_invitations
func (s *Server) handleReposListInvitationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListInvitationsForAuthenticatedUser",
			ID:   "repos/list-invitations-for-authenticated-user",
		}
	)
	params, err := decodeReposListInvitationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListInvitationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListInvitationsForAuthenticatedUser",
			OperationID:   "repos/list-invitations-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsForAuthenticatedUserParams
			Response = ReposListInvitationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListLanguagesRequest handles repos/list-languages operation.
//
// GET /repos/{owner}/{repo}/languages
func (s *Server) handleReposListLanguagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListLanguages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListLanguages",
			ID:   "repos/list-languages",
		}
	)
	params, err := decodeReposListLanguagesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Language
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListLanguages",
			OperationID:   "repos/list-languages",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListLanguagesParams
			Response = Language
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListLanguagesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListLanguages(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListLanguages(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPagesBuildsRequest handles repos/list-pages-builds operation.
//
// GET /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposListPagesBuildsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPagesBuilds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListPagesBuilds",
			ID:   "repos/list-pages-builds",
		}
	)
	params, err := decodeReposListPagesBuildsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListPagesBuildsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPagesBuilds",
			OperationID:   "repos/list-pages-builds",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPagesBuildsParams
			Response = ReposListPagesBuildsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPagesBuildsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListPagesBuilds(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListPagesBuilds(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPublicRequest handles repos/list-public operation.
//
// GET /repositories
func (s *Server) handleReposListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListPublic",
			ID:   "repos/list-public",
		}
	)
	params, err := decodeReposListPublicParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPublic",
			OperationID:   "repos/list-public",
			Body:          nil,
			Params: map[string]any{
				"since": params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPublicParams
			Response = ReposListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPublicParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListPublic(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListPublic(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPublicResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPullRequestsAssociatedWithCommitRequest handles repos/list-pull-requests-associated-with-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (s *Server) handleReposListPullRequestsAssociatedWithCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPullRequestsAssociatedWithCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListPullRequestsAssociatedWithCommit",
			ID:   "repos/list-pull-requests-associated-with-commit",
		}
	)
	params, err := decodeReposListPullRequestsAssociatedWithCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListPullRequestsAssociatedWithCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPullRequestsAssociatedWithCommit",
			OperationID:   "repos/list-pull-requests-associated-with-commit",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"commit_sha": params.CommitSha,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPullRequestsAssociatedWithCommitParams
			Response = ReposListPullRequestsAssociatedWithCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPullRequestsAssociatedWithCommitParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListReleaseAssetsRequest handles repos/list-release-assets operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposListReleaseAssetsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleaseAssets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListReleaseAssets",
			ID:   "repos/list-release-assets",
		}
	)
	params, err := decodeReposListReleaseAssetsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListReleaseAssetsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListReleaseAssets",
			OperationID:   "repos/list-release-assets",
			Body:          nil,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"release_id": params.ReleaseID,
				"per_page":   params.PerPage,
				"page":       params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleaseAssetsParams
			Response = ReposListReleaseAssetsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleaseAssetsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListReleaseAssets(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListReleaseAssets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListReleasesRequest handles repos/list-releases operation.
//
// GET /repos/{owner}/{repo}/releases
func (s *Server) handleReposListReleasesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleases",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListReleases",
			ID:   "repos/list-releases",
		}
	)
	params, err := decodeReposListReleasesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListReleasesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListReleases",
			OperationID:   "repos/list-releases",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleasesParams
			Response = ReposListReleasesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleasesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListReleases(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListReleases(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleasesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListTagsRequest handles repos/list-tags operation.
//
// GET /repos/{owner}/{repo}/tags
func (s *Server) handleReposListTagsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTags",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListTags",
			ID:   "repos/list-tags",
		}
	)
	params, err := decodeReposListTagsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListTagsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListTags",
			OperationID:   "repos/list-tags",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTagsParams
			Response = ReposListTagsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTagsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListTags(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListTags(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTagsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListTeamsRequest handles repos/list-teams operation.
//
// GET /repos/{owner}/{repo}/teams
func (s *Server) handleReposListTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListTeams",
			ID:   "repos/list-teams",
		}
	)
	params, err := decodeReposListTeamsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListTeamsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListTeams",
			OperationID:   "repos/list-teams",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTeamsParams
			Response = ReposListTeamsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTeamsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListTeams(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListTeams(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTeamsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListWebhookDeliveriesRequest handles repos/list-webhook-deliveries operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (s *Server) handleReposListWebhookDeliveriesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListWebhookDeliveries",
			ID:   "repos/list-webhook-deliveries",
		}
	)
	params, err := decodeReposListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListWebhookDeliveries",
			OperationID:   "repos/list-webhook-deliveries",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"hook_id":  params.HookID,
				"per_page": params.PerPage,
				"cursor":   params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhookDeliveriesParams
			Response = ReposListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListWebhookDeliveries(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListWebhooksRequest handles repos/list-webhooks operation.
//
// GET /repos/{owner}/{repo}/hooks
func (s *Server) handleReposListWebhooksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposListWebhooks",
			ID:   "repos/list-webhooks",
		}
	)
	params, err := decodeReposListWebhooksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListWebhooks",
			OperationID:   "repos/list-webhooks",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhooksParams
			Response = ReposListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposListWebhooks(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposListWebhooks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposMergeRequest handles repos/merge operation.
//
// POST /repos/{owner}/{repo}/merges
func (s *Server) handleReposMergeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposMerge",
			ID:   "repos/merge",
		}
	)
	params, err := decodeReposMergeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposMerge",
			OperationID:   "repos/merge",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposMergeReq
			Params   = ReposMergeParams
			Response = ReposMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposMerge(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposMerge(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposMergeUpstreamRequest handles repos/merge-upstream operation.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (s *Server) handleReposMergeUpstreamRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMergeUpstream",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposMergeUpstream",
			ID:   "repos/merge-upstream",
		}
	)
	params, err := decodeReposMergeUpstreamParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposMergeUpstreamRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeUpstreamRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposMergeUpstream",
			OperationID:   "repos/merge-upstream",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposMergeUpstreamReq
			Params   = ReposMergeUpstreamParams
			Response = ReposMergeUpstreamRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeUpstreamParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposMergeUpstream(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposMergeUpstream(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposPingWebhookRequest handles repos/ping-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (s *Server) handleReposPingWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposPingWebhook",
			ID:   "repos/ping-webhook",
		}
	)
	params, err := decodeReposPingWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposPingWebhook",
			OperationID:   "repos/ping-webhook",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposPingWebhookParams
			Response = ReposPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposPingWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposPingWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRedeliverWebhookDeliveryRequest handles repos/redeliver-webhook-delivery operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleReposRedeliverWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRedeliverWebhookDelivery",
			ID:   "repos/redeliver-webhook-delivery",
		}
	)
	params, err := decodeReposRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRedeliverWebhookDelivery",
			OperationID:   "repos/redeliver-webhook-delivery",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"hook_id":     params.HookID,
				"delivery_id": params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRedeliverWebhookDeliveryParams
			Response = ReposRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRedeliverWebhookDelivery(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveAppAccessRestrictionsRequest handles repos/remove-app-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposRemoveAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveAppAccessRestrictions",
			ID:   "repos/remove-app-access-restrictions",
		}
	)
	params, err := decodeReposRemoveAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveAppAccessRestrictions",
			OperationID:   "repos/remove-app-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveAppAccessRestrictionsReq
			Params   = ReposRemoveAppAccessRestrictionsParams
			Response = ReposRemoveAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveCollaboratorRequest handles repos/remove-collaborator operation.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposRemoveCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveCollaborator",
			ID:   "repos/remove-collaborator",
		}
	)
	params, err := decodeReposRemoveCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposRemoveCollaboratorNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveCollaborator",
			OperationID:   "repos/remove-collaborator",
			Body:          nil,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveCollaboratorParams
			Response = ReposRemoveCollaboratorNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveCollaborator(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveStatusCheckContextsRequest handles repos/remove-status-check-contexts operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposRemoveStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveStatusCheckContexts",
			ID:   "repos/remove-status-check-contexts",
		}
	)
	params, err := decodeReposRemoveStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveStatusCheckContexts",
			OperationID:   "repos/remove-status-check-contexts",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveStatusCheckContextsReq
			Params   = ReposRemoveStatusCheckContextsParams
			Response = ReposRemoveStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveStatusCheckProtectionRequest handles repos/remove-status-check-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposRemoveStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveStatusCheckProtection",
			ID:   "repos/remove-status-check-protection",
		}
	)
	params, err := decodeReposRemoveStatusCheckProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposRemoveStatusCheckProtectionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveStatusCheckProtection",
			OperationID:   "repos/remove-status-check-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveStatusCheckProtectionParams
			Response = ReposRemoveStatusCheckProtectionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveStatusCheckProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveStatusCheckProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveTeamAccessRestrictionsRequest handles repos/remove-team-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposRemoveTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveTeamAccessRestrictions",
			ID:   "repos/remove-team-access-restrictions",
		}
	)
	params, err := decodeReposRemoveTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveTeamAccessRestrictions",
			OperationID:   "repos/remove-team-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveTeamAccessRestrictionsReq
			Params   = ReposRemoveTeamAccessRestrictionsParams
			Response = ReposRemoveTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveUserAccessRestrictionsRequest handles repos/remove-user-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposRemoveUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRemoveUserAccessRestrictions",
			ID:   "repos/remove-user-access-restrictions",
		}
	)
	params, err := decodeReposRemoveUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveUserAccessRestrictions",
			OperationID:   "repos/remove-user-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveUserAccessRestrictionsReq
			Params   = ReposRemoveUserAccessRestrictionsParams
			Response = ReposRemoveUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRenameBranchRequest handles repos/rename-branch operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (s *Server) handleReposRenameBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRenameBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRenameBranch",
			ID:   "repos/rename-branch",
		}
	)
	params, err := decodeReposRenameBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRenameBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRenameBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRenameBranch",
			OperationID:   "repos/rename-branch",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRenameBranchReq
			Params   = ReposRenameBranchParams
			Response = ReposRenameBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRenameBranchParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRenameBranch(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposRenameBranch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRenameBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposReplaceAllTopicsRequest handles repos/replace-all-topics operation.
//
// PUT /repos/{owner}/{repo}/topics
func (s *Server) handleReposReplaceAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposReplaceAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposReplaceAllTopics",
			ID:   "repos/replace-all-topics",
		}
	)
	params, err := decodeReposReplaceAllTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposReplaceAllTopicsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposReplaceAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposReplaceAllTopics",
			OperationID:   "repos/replace-all-topics",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposReplaceAllTopicsReq
			Params   = ReposReplaceAllTopicsParams
			Response = ReposReplaceAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposReplaceAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposReplaceAllTopics(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposReplaceAllTopics(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRequestPagesBuildRequest handles repos/request-pages-build operation.
//
// POST /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposRequestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRequestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposRequestPagesBuild",
			ID:   "repos/request-pages-build",
		}
	)
	params, err := decodeReposRequestPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PageBuildStatus
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRequestPagesBuild",
			OperationID:   "repos/request-pages-build",
			Body:          nil,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRequestPagesBuildParams
			Response = PageBuildStatus
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRequestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposRequestPagesBuild(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposRequestPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetAdminBranchProtectionRequest handles repos/set-admin-branch-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposSetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposSetAdminBranchProtection",
			ID:   "repos/set-admin-branch-protection",
		}
	)
	params, err := decodeReposSetAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetAdminBranchProtection",
			OperationID:   "repos/set-admin-branch-protection",
			Body:          nil,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposSetAdminBranchProtectionParams
			Response = ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposSetAdminBranchProtection(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposSetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetAppAccessRestrictionsRequest handles repos/set-app-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposSetAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposSetAppAccessRestrictions",
			ID:   "repos/set-app-access-restrictions",
		}
	)
	params, err := decodeReposSetAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetAppAccessRestrictions",
			OperationID:   "repos/set-app-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetAppAccessRestrictionsReq
			Params   = ReposSetAppAccessRestrictionsParams
			Response = ReposSetAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposSetAppAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposSetAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetStatusCheckContextsRequest handles repos/set-status-check-contexts operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposSetStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposSetStatusCheckContexts",
			ID:   "repos/set-status-check-contexts",
		}
	)
	params, err := decodeReposSetStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetStatusCheckContexts",
			OperationID:   "repos/set-status-check-contexts",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetStatusCheckContextsReq
			Params   = ReposSetStatusCheckContextsParams
			Response = ReposSetStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposSetStatusCheckContexts(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposSetStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetTeamAccessRestrictionsRequest handles repos/set-team-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposSetTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposSetTeamAccessRestrictions",
			ID:   "repos/set-team-access-restrictions",
		}
	)
	params, err := decodeReposSetTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetTeamAccessRestrictions",
			OperationID:   "repos/set-team-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetTeamAccessRestrictionsReq
			Params   = ReposSetTeamAccessRestrictionsParams
			Response = ReposSetTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetUserAccessRestrictionsRequest handles repos/set-user-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposSetUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposSetUserAccessRestrictions",
			ID:   "repos/set-user-access-restrictions",
		}
	)
	params, err := decodeReposSetUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetUserAccessRestrictions",
			OperationID:   "repos/set-user-access-restrictions",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetUserAccessRestrictionsReq
			Params   = ReposSetUserAccessRestrictionsParams
			Response = ReposSetUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposSetUserAccessRestrictions(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposSetUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposTestPushWebhookRequest handles repos/test-push-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (s *Server) handleReposTestPushWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTestPushWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposTestPushWebhook",
			ID:   "repos/test-push-webhook",
		}
	)
	params, err := decodeReposTestPushWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposTestPushWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposTestPushWebhook",
			OperationID:   "repos/test-push-webhook",
			Body:          nil,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposTestPushWebhookParams
			Response = ReposTestPushWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTestPushWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposTestPushWebhook(ctx, params)
			},
		)
	} else {
		response, err = s.h.ReposTestPushWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposTransferRequest handles repos/transfer operation.
//
// POST /repos/{owner}/{repo}/transfer
func (s *Server) handleReposTransferRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTransfer",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposTransfer",
			ID:   "repos/transfer",
		}
	)
	params, err := decodeReposTransferParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposTransferRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MinimalRepository
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposTransfer",
			OperationID:   "repos/transfer",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = ReposTransferReq
			Params   = ReposTransferParams
			Response = MinimalRepository
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTransferParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposTransfer(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposTransfer(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTransferResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateRequest handles repos/update operation.
//
// PATCH /repos/{owner}/{repo}
func (s *Server) handleReposUpdateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdate",
			ID:   "repos/update",
		}
	)
	params, err := decodeReposUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdate",
			OperationID:   "repos/update",
			Body:          request,
			Params: map[string]any{
				"owner": params.Owner,
				"repo":  params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReq
			Params   = ReposUpdateParams
			Response = ReposUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateBranchProtectionRequest handles repos/update-branch-protection operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposUpdateBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateBranchProtection",
			ID:   "repos/update-branch-protection",
		}
	)
	params, err := decodeReposUpdateBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateBranchProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateBranchProtection",
			OperationID:   "repos/update-branch-protection",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = ReposUpdateBranchProtectionReq
			Params   = ReposUpdateBranchProtectionParams
			Response = ReposUpdateBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateBranchProtection(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateBranchProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateCommitCommentRequest handles repos/update-commit-comment operation.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposUpdateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateCommitComment",
			ID:   "repos/update-commit-comment",
		}
	)
	params, err := decodeReposUpdateCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateCommitComment",
			OperationID:   "repos/update-commit-comment",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"comment_id": params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = ReposUpdateCommitCommentReq
			Params   = ReposUpdateCommitCommentParams
			Response = ReposUpdateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateCommitComment(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateInvitationRequest handles repos/update-invitation operation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposUpdateInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateInvitation",
			ID:   "repos/update-invitation",
		}
	)
	params, err := decodeReposUpdateInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RepositoryInvitation
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateInvitation",
			OperationID:   "repos/update-invitation",
			Body:          request,
			Params: map[string]any{
				"owner":         params.Owner,
				"repo":          params.Repo,
				"invitation_id": params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateInvitationReq
			Params   = ReposUpdateInvitationParams
			Response = RepositoryInvitation
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateInvitationParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateInvitation(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateInvitation(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdatePullRequestReviewProtectionRequest handles repos/update-pull-request-review-protection operation.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposUpdatePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdatePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdatePullRequestReviewProtection",
			ID:   "repos/update-pull-request-review-protection",
		}
	)
	params, err := decodeReposUpdatePullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdatePullRequestReviewProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdatePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdatePullRequestReviewProtection",
			OperationID:   "repos/update-pull-request-review-protection",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdatePullRequestReviewProtectionReq
			Params   = ReposUpdatePullRequestReviewProtectionParams
			Response = ReposUpdatePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdatePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdatePullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateReleaseRequest handles repos/update-release operation.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposUpdateReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateRelease",
			ID:   "repos/update-release",
		}
	)
	params, err := decodeReposUpdateReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateRelease",
			OperationID:   "repos/update-release",
			Body:          request,
			Params: map[string]any{
				"owner":      params.Owner,
				"repo":       params.Repo,
				"release_id": params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseReq
			Params   = ReposUpdateReleaseParams
			Response = ReposUpdateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateRelease(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateReleaseAssetRequest handles repos/update-release-asset operation.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposUpdateReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateReleaseAsset",
			ID:   "repos/update-release-asset",
		}
	)
	params, err := decodeReposUpdateReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateReleaseAssetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReleaseAsset
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateReleaseAsset",
			OperationID:   "repos/update-release-asset",
			Body:          request,
			Params: map[string]any{
				"owner":    params.Owner,
				"repo":     params.Repo,
				"asset_id": params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseAssetReq
			Params   = ReposUpdateReleaseAssetParams
			Response = ReleaseAsset
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateReleaseAsset(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateReleaseAsset(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateStatusCheckProtectionRequest handles repos/update-status-check-protection operation.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposUpdateStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateStatusCheckProtection",
			ID:   "repos/update-status-check-protection",
		}
	)
	params, err := decodeReposUpdateStatusCheckProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateStatusCheckProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateStatusCheckProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateStatusCheckProtection",
			OperationID:   "repos/update-status-check-protection",
			Body:          request,
			Params: map[string]any{
				"owner":  params.Owner,
				"repo":   params.Repo,
				"branch": params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateStatusCheckProtectionReq
			Params   = ReposUpdateStatusCheckProtectionParams
			Response = ReposUpdateStatusCheckProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateStatusCheckProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateWebhookRequest handles repos/update-webhook operation.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposUpdateWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateWebhook",
			ID:   "repos/update-webhook",
		}
	)
	params, err := decodeReposUpdateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateWebhook",
			OperationID:   "repos/update-webhook",
			Body:          request,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookReq
			Params   = ReposUpdateWebhookParams
			Response = ReposUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateWebhook(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateWebhookConfigForRepoRequest handles repos/update-webhook-config-for-repo operation.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposUpdateWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReposUpdateWebhookConfigForRepo",
			ID:   "repos/update-webhook-config-for-repo",
		}
	)
	params, err := decodeReposUpdateWebhookConfigForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateWebhookConfigForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateWebhookConfigForRepo",
			OperationID:   "repos/update-webhook-config-for-repo",
			Body:          request,
			Params: map[string]any{
				"owner":   params.Owner,
				"repo":    params.Repo,
				"hook_id": params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookConfigForRepoReq
			Params   = ReposUpdateWebhookConfigForRepoParams
			Response = WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleScimDeleteUserFromOrgRequest handles scim/delete-user-from-org operation.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (s *Server) handleScimDeleteUserFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ScimDeleteUserFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ScimDeleteUserFromOrg",
			ID:   "scim/delete-user-from-org",
		}
	)
	params, err := decodeScimDeleteUserFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimDeleteUserFromOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ScimDeleteUserFromOrg",
			OperationID:   "scim/delete-user-from-org",
			Body:          nil,
			Params: map[string]any{
				"org":          params.Org,
				"scim_user_id": params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ScimDeleteUserFromOrgParams
			Response = ScimDeleteUserFromOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackScimDeleteUserFromOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.ScimDeleteUserFromOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.ScimDeleteUserFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchCodeRequest handles search/code operation.
//
// GET /search/code
func (s *Server) handleSearchCodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchCode",
			ID:   "search/code",
		}
	)
	params, err := decodeSearchCodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchCode",
			OperationID:   "search/code",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"sort":     params.Sort,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCodeParams
			Response = SearchCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCodeParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchCode(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchCode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchCommitsRequest handles search/commits operation.
//
// GET /search/commits
func (s *Server) handleSearchCommitsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchCommits",
			ID:   "search/commits",
		}
	)
	params, err := decodeSearchCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchCommits",
			OperationID:   "search/commits",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"sort":     params.Sort,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCommitsParams
			Response = SearchCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCommitsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchCommits(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchIssuesAndPullRequestsRequest handles search/issues-and-pull-requests operation.
//
// GET /search/issues
func (s *Server) handleSearchIssuesAndPullRequestsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchIssuesAndPullRequests",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchIssuesAndPullRequests",
			ID:   "search/issues-and-pull-requests",
		}
	)
	params, err := decodeSearchIssuesAndPullRequestsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchIssuesAndPullRequestsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchIssuesAndPullRequests",
			OperationID:   "search/issues-and-pull-requests",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"sort":     params.Sort,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchIssuesAndPullRequestsParams
			Response = SearchIssuesAndPullRequestsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchIssuesAndPullRequestsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchIssuesAndPullRequests(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchIssuesAndPullRequests(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchIssuesAndPullRequestsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchLabelsRequest handles search/labels operation.
//
// GET /search/labels
func (s *Server) handleSearchLabelsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchLabels",
			ID:   "search/labels",
		}
	)
	params, err := decodeSearchLabelsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchLabels",
			OperationID:   "search/labels",
			Body:          nil,
			Params: map[string]any{
				"repository_id": params.RepositoryID,
				"q":             params.Q,
				"sort":          params.Sort,
				"order":         params.Order,
				"per_page":      params.PerPage,
				"page":          params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchLabelsParams
			Response = SearchLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchLabelsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchLabels(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchLabels(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchLabelsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchReposRequest handles search/repos operation.
//
// GET /search/repositories
func (s *Server) handleSearchReposRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchRepos",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchRepos",
			ID:   "search/repos",
		}
	)
	params, err := decodeSearchReposParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchReposRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchRepos",
			OperationID:   "search/repos",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"sort":     params.Sort,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchReposParams
			Response = SearchReposRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchReposParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchRepos(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchRepos(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchReposResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchTopicsRequest handles search/topics operation.
//
// GET /search/topics
func (s *Server) handleSearchTopicsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchTopics",
			ID:   "search/topics",
		}
	)
	params, err := decodeSearchTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchTopics",
			OperationID:   "search/topics",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchTopicsParams
			Response = SearchTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchTopicsParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchTopics(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchTopics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchUsersRequest handles search/users operation.
//
// GET /search/users
func (s *Server) handleSearchUsersRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchUsers",
			ID:   "search/users",
		}
	)
	params, err := decodeSearchUsersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchUsers",
			OperationID:   "search/users",
			Body:          nil,
			Params: map[string]any{
				"q":        params.Q,
				"sort":     params.Sort,
				"order":    params.Order,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchUsersParams
			Response = SearchUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchUsersParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SearchUsers(ctx, params)
			},
		)
	} else {
		response, err = s.h.SearchUsers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchUsersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningGetAlertRequest handles secret-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SecretScanningGetAlert",
			ID:   "secret-scanning/get-alert",
		}
	)
	params, err := decodeSecretScanningGetAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningGetAlert",
			OperationID:   "secret-scanning/get-alert",
			Body:          nil,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"alert_number": params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningGetAlertParams
			Response = SecretScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SecretScanningGetAlert(ctx, params)
			},
		)
	} else {
		response, err = s.h.SecretScanningGetAlert(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningListAlertsForOrgRequest handles secret-scanning/list-alerts-for-org operation.
//
// GET /orgs/{org}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SecretScanningListAlertsForOrg",
			ID:   "secret-scanning/list-alerts-for-org",
		}
	)
	params, err := decodeSecretScanningListAlertsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningListAlertsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningListAlertsForOrg",
			OperationID:   "secret-scanning/list-alerts-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":         params.Org,
				"state":       params.State,
				"secret_type": params.SecretType,
				"page":        params.Page,
				"per_page":    params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForOrgParams
			Response = SecretScanningListAlertsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SecretScanningListAlertsForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningListAlertsForRepoRequest handles secret-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SecretScanningListAlertsForRepo",
			ID:   "secret-scanning/list-alerts-for-repo",
		}
	)
	params, err := decodeSecretScanningListAlertsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningListAlertsForRepo",
			OperationID:   "secret-scanning/list-alerts-for-repo",
			Body:          nil,
			Params: map[string]any{
				"owner":       params.Owner,
				"repo":        params.Repo,
				"state":       params.State,
				"secret_type": params.SecretType,
				"page":        params.Page,
				"per_page":    params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForRepoParams
			Response = SecretScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SecretScanningListAlertsForRepo(ctx, params)
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningUpdateAlertRequest handles secret-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SecretScanningUpdateAlert",
			ID:   "secret-scanning/update-alert",
		}
	)
	params, err := decodeSecretScanningUpdateAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeSecretScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SecretScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningUpdateAlert",
			OperationID:   "secret-scanning/update-alert",
			Body:          request,
			Params: map[string]any{
				"owner":        params.Owner,
				"repo":         params.Repo,
				"alert_number": params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = SecretScanningUpdateAlertReq
			Params   = SecretScanningUpdateAlertParams
			Response = SecretScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.SecretScanningUpdateAlert(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.SecretScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddMemberLegacyRequest handles teams/add-member-legacy operation.
//
// PUT /teams/{team_id}/members/{username}
func (s *Server) handleTeamsAddMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddMemberLegacy",
			ID:   "teams/add-member-legacy",
		}
	)
	params, err := decodeTeamsAddMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsAddMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddMemberLegacy",
			OperationID:   "teams/add-member-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsAddMemberLegacyParams
			Response = TeamsAddMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddMemberLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserInOrgRequest handles teams/add-or-update-membership-for-user-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateMembershipForUserInOrg",
			ID:   "teams/add-or-update-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateMembershipForUserInOrg",
			OperationID:   "teams/add-or-update-membership-for-user-in-org",
			Body:          request,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"username":  params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserInOrgReq
			Params   = TeamsAddOrUpdateMembershipForUserInOrgParams
			Response = TeamsAddOrUpdateMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserLegacyRequest handles teams/add-or-update-membership-for-user-legacy operation.
//
// PUT /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateMembershipForUserLegacy",
			ID:   "teams/add-or-update-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateMembershipForUserLegacy",
			OperationID:   "teams/add-or-update-membership-for-user-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserLegacyReq
			Params   = TeamsAddOrUpdateMembershipForUserLegacyParams
			Response = TeamsAddOrUpdateMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsInOrgRequest handles teams/add-or-update-project-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateProjectPermissionsInOrg",
			ID:   "teams/add-or-update-project-permissions-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateProjectPermissionsInOrg",
			OperationID:   "teams/add-or-update-project-permissions-in-org",
			Body:          request,
			Params: map[string]any{
				"org":        params.Org,
				"team_slug":  params.TeamSlug,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq
			Params   = TeamsAddOrUpdateProjectPermissionsInOrgParams
			Response = TeamsAddOrUpdateProjectPermissionsInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsLegacyRequest handles teams/add-or-update-project-permissions-legacy operation.
//
// PUT /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateProjectPermissionsLegacy",
			ID:   "teams/add-or-update-project-permissions-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateProjectPermissionsLegacy",
			OperationID:   "teams/add-or-update-project-permissions-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":    params.TeamID,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateProjectPermissionsLegacyReq
			Params   = TeamsAddOrUpdateProjectPermissionsLegacyParams
			Response = TeamsAddOrUpdateProjectPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsInOrgRequest handles teams/add-or-update-repo-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateRepoPermissionsInOrg",
			ID:   "teams/add-or-update-repo-permissions-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateRepoPermissionsInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateRepoPermissionsInOrg",
			OperationID:   "teams/add-or-update-repo-permissions-in-org",
			Body:          request,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"owner":     params.Owner,
				"repo":      params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsInOrgReq
			Params   = TeamsAddOrUpdateRepoPermissionsInOrgParams
			Response = TeamsAddOrUpdateRepoPermissionsInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsLegacyRequest handles teams/add-or-update-repo-permissions-legacy operation.
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsAddOrUpdateRepoPermissionsLegacy",
			ID:   "teams/add-or-update-repo-permissions-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateRepoPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateRepoPermissionsLegacy",
			OperationID:   "teams/add-or-update-repo-permissions-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id": params.TeamID,
				"owner":   params.Owner,
				"repo":    params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsLegacyReq
			Params   = TeamsAddOrUpdateRepoPermissionsLegacyParams
			Response = TeamsAddOrUpdateRepoPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForProjectInOrgRequest handles teams/check-permissions-for-project-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCheckPermissionsForProjectInOrg",
			ID:   "teams/check-permissions-for-project-in-org",
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForProjectInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForProjectInOrg",
			OperationID:   "teams/check-permissions-for-project-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":        params.Org,
				"team_slug":  params.TeamSlug,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectInOrgParams
			Response = TeamsCheckPermissionsForProjectInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForProjectLegacyRequest handles teams/check-permissions-for-project-legacy operation.
//
// GET /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCheckPermissionsForProjectLegacy",
			ID:   "teams/check-permissions-for-project-legacy",
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForProjectLegacy",
			OperationID:   "teams/check-permissions-for-project-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":    params.TeamID,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectLegacyParams
			Response = TeamsCheckPermissionsForProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForRepoInOrgRequest handles teams/check-permissions-for-repo-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCheckPermissionsForRepoInOrg",
			ID:   "teams/check-permissions-for-repo-in-org",
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForRepoInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForRepoInOrg",
			OperationID:   "teams/check-permissions-for-repo-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"owner":     params.Owner,
				"repo":      params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoInOrgParams
			Response = TeamsCheckPermissionsForRepoInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForRepoLegacyRequest handles teams/check-permissions-for-repo-legacy operation.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCheckPermissionsForRepoLegacy",
			ID:   "teams/check-permissions-for-repo-legacy",
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForRepoLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForRepoLegacy",
			OperationID:   "teams/check-permissions-for-repo-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id": params.TeamID,
				"owner":   params.Owner,
				"repo":    params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoLegacyParams
			Response = TeamsCheckPermissionsForRepoLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateRequest handles teams/create operation.
//
// POST /orgs/{org}/teams
func (s *Server) handleTeamsCreateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreate",
			ID:   "teams/create",
		}
	)
	params, err := decodeTeamsCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreate",
			OperationID:   "teams/create",
			Body:          request,
			Params: map[string]any{
				"org": params.Org,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateReq
			Params   = TeamsCreateParams
			Response = TeamsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreate(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionCommentInOrgRequest handles teams/create-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateDiscussionCommentInOrg",
			ID:   "teams/create-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionCommentInOrg",
			OperationID:   "teams/create-discussion-comment-in-org",
			Body:          request,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateDiscussionCommentInOrgReq
			Params   = TeamsCreateDiscussionCommentInOrgParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionCommentLegacyRequest handles teams/create-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateDiscussionCommentLegacy",
			ID:   "teams/create-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionCommentLegacy",
			OperationID:   "teams/create-discussion-comment-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateDiscussionCommentLegacyReq
			Params   = TeamsCreateDiscussionCommentLegacyParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionInOrgRequest handles teams/create-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsCreateDiscussionInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateDiscussionInOrg",
			ID:   "teams/create-discussion-in-org",
		}
	)
	params, err := decodeTeamsCreateDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionInOrg",
			OperationID:   "teams/create-discussion-in-org",
			Body:          request,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateDiscussionInOrgReq
			Params   = TeamsCreateDiscussionInOrgParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionLegacyRequest handles teams/create-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions
func (s *Server) handleTeamsCreateDiscussionLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateDiscussionLegacy",
			ID:   "teams/create-discussion-legacy",
		}
	)
	params, err := decodeTeamsCreateDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionLegacy",
			OperationID:   "teams/create-discussion-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateDiscussionLegacyReq
			Params   = TeamsCreateDiscussionLegacyParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest handles teams/create-or-update-idp-group-connections-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
			ID:   "teams/create-or-update-idp-group-connections-in-org",
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
			OperationID:   "teams/create-or-update-idp-group-connections-in-org",
			Body:          request,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
			Response = GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest handles teams/create-or-update-idp-group-connections-legacy operation.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
			ID:   "teams/create-or-update-idp-group-connections-legacy",
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
			OperationID:   "teams/create-or-update-idp-group-connections-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams
			Response = TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionCommentInOrgRequest handles teams/delete-discussion-comment-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteDiscussionCommentInOrg",
			ID:   "teams/delete-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteDiscussionCommentInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionCommentInOrg",
			OperationID:   "teams/delete-discussion-comment-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentInOrgParams
			Response = TeamsDeleteDiscussionCommentInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionCommentLegacyRequest handles teams/delete-discussion-comment-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteDiscussionCommentLegacy",
			ID:   "teams/delete-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteDiscussionCommentLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionCommentLegacy",
			OperationID:   "teams/delete-discussion-comment-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentLegacyParams
			Response = TeamsDeleteDiscussionCommentLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionInOrgRequest handles teams/delete-discussion-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteDiscussionInOrg",
			ID:   "teams/delete-discussion-in-org",
		}
	)
	params, err := decodeTeamsDeleteDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteDiscussionInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionInOrg",
			OperationID:   "teams/delete-discussion-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionInOrgParams
			Response = TeamsDeleteDiscussionInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteDiscussionInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionLegacyRequest handles teams/delete-discussion-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteDiscussionLegacy",
			ID:   "teams/delete-discussion-legacy",
		}
	)
	params, err := decodeTeamsDeleteDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteDiscussionLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionLegacy",
			OperationID:   "teams/delete-discussion-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionLegacyParams
			Response = TeamsDeleteDiscussionLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteDiscussionLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteInOrgRequest handles teams/delete-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsDeleteInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteInOrg",
			ID:   "teams/delete-in-org",
		}
	)
	params, err := decodeTeamsDeleteInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteInOrg",
			OperationID:   "teams/delete-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteInOrgParams
			Response = TeamsDeleteInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteLegacyRequest handles teams/delete-legacy operation.
//
// DELETE /teams/{team_id}
func (s *Server) handleTeamsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsDeleteLegacy",
			ID:   "teams/delete-legacy",
		}
	)
	params, err := decodeTeamsDeleteLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteLegacy",
			OperationID:   "teams/delete-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteLegacyParams
			Response = TeamsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsDeleteLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsDeleteLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetByNameRequest handles teams/get-by-name operation.
//
// GET /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsGetByNameRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetByName",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetByName",
			ID:   "teams/get-by-name",
		}
	)
	params, err := decodeTeamsGetByNameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetByNameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetByName",
			OperationID:   "teams/get-by-name",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetByNameParams
			Response = TeamsGetByNameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetByNameParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetByName(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetByName(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionCommentInOrgRequest handles teams/get-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetDiscussionCommentInOrg",
			ID:   "teams/get-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsGetDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionCommentInOrg",
			OperationID:   "teams/get-discussion-comment-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentInOrgParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionCommentLegacyRequest handles teams/get-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetDiscussionCommentLegacy",
			ID:   "teams/get-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsGetDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionCommentLegacy",
			OperationID:   "teams/get-discussion-comment-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentLegacyParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionInOrgRequest handles teams/get-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetDiscussionInOrg",
			ID:   "teams/get-discussion-in-org",
		}
	)
	params, err := decodeTeamsGetDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionInOrg",
			OperationID:   "teams/get-discussion-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionInOrgParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetDiscussionInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionLegacyRequest handles teams/get-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetDiscussionLegacy",
			ID:   "teams/get-discussion-legacy",
		}
	)
	params, err := decodeTeamsGetDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionLegacy",
			OperationID:   "teams/get-discussion-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionLegacyParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetDiscussionLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetLegacyRequest handles teams/get-legacy operation.
//
// GET /teams/{team_id}
func (s *Server) handleTeamsGetLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetLegacy",
			ID:   "teams/get-legacy",
		}
	)
	params, err := decodeTeamsGetLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetLegacy",
			OperationID:   "teams/get-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetLegacyParams
			Response = TeamsGetLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMemberLegacyRequest handles teams/get-member-legacy operation.
//
// GET /teams/{team_id}/members/{username}
func (s *Server) handleTeamsGetMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetMemberLegacy",
			ID:   "teams/get-member-legacy",
		}
	)
	params, err := decodeTeamsGetMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMemberLegacy",
			OperationID:   "teams/get-member-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMemberLegacyParams
			Response = TeamsGetMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetMemberLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMembershipForUserInOrgRequest handles teams/get-membership-for-user-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetMembershipForUserInOrg",
			ID:   "teams/get-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsGetMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMembershipForUserInOrg",
			OperationID:   "teams/get-membership-for-user-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"username":  params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserInOrgParams
			Response = TeamsGetMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetMembershipForUserInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMembershipForUserLegacyRequest handles teams/get-membership-for-user-legacy operation.
//
// GET /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsGetMembershipForUserLegacy",
			ID:   "teams/get-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsGetMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMembershipForUserLegacy",
			OperationID:   "teams/get-membership-for-user-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserLegacyParams
			Response = TeamsGetMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsGetMembershipForUserLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListRequest handles teams/list operation.
//
// GET /orgs/{org}/teams
func (s *Server) handleTeamsListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsList",
			ID:   "teams/list",
		}
	)
	params, err := decodeTeamsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsList",
			OperationID:   "teams/list",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListParams
			Response = TeamsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsList(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListChildInOrgRequest handles teams/list-child-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (s *Server) handleTeamsListChildInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListChildInOrg",
			ID:   "teams/list-child-in-org",
		}
	)
	params, err := decodeTeamsListChildInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListChildInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListChildInOrg",
			OperationID:   "teams/list-child-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildInOrgParams
			Response = TeamsListChildInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListChildInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListChildInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListChildLegacyRequest handles teams/list-child-legacy operation.
//
// GET /teams/{team_id}/teams
func (s *Server) handleTeamsListChildLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListChildLegacy",
			ID:   "teams/list-child-legacy",
		}
	)
	params, err := decodeTeamsListChildLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListChildLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListChildLegacy",
			OperationID:   "teams/list-child-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildLegacyParams
			Response = TeamsListChildLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListChildLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListChildLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionCommentsInOrgRequest handles teams/list-discussion-comments-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListDiscussionCommentsInOrg",
			ID:   "teams/list-discussion-comments-in-org",
		}
	)
	params, err := decodeTeamsListDiscussionCommentsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListDiscussionCommentsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionCommentsInOrg",
			OperationID:   "teams/list-discussion-comments-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"direction":         params.Direction,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsInOrgParams
			Response = TeamsListDiscussionCommentsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionCommentsLegacyRequest handles teams/list-discussion-comments-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListDiscussionCommentsLegacy",
			ID:   "teams/list-discussion-comments-legacy",
		}
	)
	params, err := decodeTeamsListDiscussionCommentsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListDiscussionCommentsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionCommentsLegacy",
			OperationID:   "teams/list-discussion-comments-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"direction":         params.Direction,
				"per_page":          params.PerPage,
				"page":              params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsLegacyParams
			Response = TeamsListDiscussionCommentsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionsInOrgRequest handles teams/list-discussions-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsListDiscussionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListDiscussionsInOrg",
			ID:   "teams/list-discussions-in-org",
		}
	)
	params, err := decodeTeamsListDiscussionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListDiscussionsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionsInOrg",
			OperationID:   "teams/list-discussions-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
				"pinned":    params.Pinned,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsInOrgParams
			Response = TeamsListDiscussionsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListDiscussionsInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionsLegacyRequest handles teams/list-discussions-legacy operation.
//
// GET /teams/{team_id}/discussions
func (s *Server) handleTeamsListDiscussionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListDiscussionsLegacy",
			ID:   "teams/list-discussions-legacy",
		}
	)
	params, err := decodeTeamsListDiscussionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListDiscussionsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionsLegacy",
			OperationID:   "teams/list-discussions-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":   params.TeamID,
				"direction": params.Direction,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsLegacyParams
			Response = TeamsListDiscussionsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListDiscussionsLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListForAuthenticatedUserRequest handles teams/list-for-authenticated-user operation.
//
// GET /user/teams
func (s *Server) handleTeamsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListForAuthenticatedUser",
			ID:   "teams/list-for-authenticated-user",
		}
	)
	params, err := decodeTeamsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListForAuthenticatedUser",
			OperationID:   "teams/list-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListForAuthenticatedUserParams
			Response = TeamsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsForLegacyRequest handles teams/list-idp-groups-for-legacy operation.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsForLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListIdpGroupsForLegacy",
			ID:   "teams/list-idp-groups-for-legacy",
		}
	)
	params, err := decodeTeamsListIdpGroupsForLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListIdpGroupsForLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsForLegacy",
			OperationID:   "teams/list-idp-groups-for-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForLegacyParams
			Response = TeamsListIdpGroupsForLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListIdpGroupsForLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsForOrgRequest handles teams/list-idp-groups-for-org operation.
//
// GET /orgs/{org}/team-sync/groups
func (s *Server) handleTeamsListIdpGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListIdpGroupsForOrg",
			ID:   "teams/list-idp-groups-for-org",
		}
	)
	params, err := decodeTeamsListIdpGroupsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GroupMappingHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsForOrg",
			OperationID:   "teams/list-idp-groups-for-org",
			Body:          nil,
			Params: map[string]any{
				"org":      params.Org,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForOrgParams
			Response = GroupMappingHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListIdpGroupsForOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsInOrgRequest handles teams/list-idp-groups-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListIdpGroupsInOrg",
			ID:   "teams/list-idp-groups-in-org",
		}
	)
	params, err := decodeTeamsListIdpGroupsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsInOrg",
			OperationID:   "teams/list-idp-groups-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsInOrgParams
			Response = GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListIdpGroupsInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListMembersInOrgRequest handles teams/list-members-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (s *Server) handleTeamsListMembersInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListMembersInOrg",
			ID:   "teams/list-members-in-org",
		}
	)
	params, err := decodeTeamsListMembersInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListMembersInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListMembersInOrg",
			OperationID:   "teams/list-members-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"role":      params.Role,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersInOrgParams
			Response = TeamsListMembersInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListMembersInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListMembersInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListMembersLegacyRequest handles teams/list-members-legacy operation.
//
// GET /teams/{team_id}/members
func (s *Server) handleTeamsListMembersLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListMembersLegacy",
			ID:   "teams/list-members-legacy",
		}
	)
	params, err := decodeTeamsListMembersLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListMembersLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListMembersLegacy",
			OperationID:   "teams/list-members-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"role":     params.Role,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersLegacyParams
			Response = TeamsListMembersLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListMembersLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListMembersLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListPendingInvitationsInOrgRequest handles teams/list-pending-invitations-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (s *Server) handleTeamsListPendingInvitationsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListPendingInvitationsInOrg",
			ID:   "teams/list-pending-invitations-in-org",
		}
	)
	params, err := decodeTeamsListPendingInvitationsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListPendingInvitationsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListPendingInvitationsInOrg",
			OperationID:   "teams/list-pending-invitations-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsInOrgParams
			Response = TeamsListPendingInvitationsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListPendingInvitationsInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListPendingInvitationsLegacyRequest handles teams/list-pending-invitations-legacy operation.
//
// GET /teams/{team_id}/invitations
func (s *Server) handleTeamsListPendingInvitationsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListPendingInvitationsLegacy",
			ID:   "teams/list-pending-invitations-legacy",
		}
	)
	params, err := decodeTeamsListPendingInvitationsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListPendingInvitationsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListPendingInvitationsLegacy",
			OperationID:   "teams/list-pending-invitations-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsLegacyParams
			Response = TeamsListPendingInvitationsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListPendingInvitationsLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListProjectsInOrgRequest handles teams/list-projects-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (s *Server) handleTeamsListProjectsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListProjectsInOrg",
			ID:   "teams/list-projects-in-org",
		}
	)
	params, err := decodeTeamsListProjectsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListProjectsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListProjectsInOrg",
			OperationID:   "teams/list-projects-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsInOrgParams
			Response = TeamsListProjectsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListProjectsInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListProjectsLegacyRequest handles teams/list-projects-legacy operation.
//
// GET /teams/{team_id}/projects
func (s *Server) handleTeamsListProjectsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListProjectsLegacy",
			ID:   "teams/list-projects-legacy",
		}
	)
	params, err := decodeTeamsListProjectsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListProjectsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListProjectsLegacy",
			OperationID:   "teams/list-projects-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsLegacyParams
			Response = TeamsListProjectsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListProjectsLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListReposInOrgRequest handles teams/list-repos-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (s *Server) handleTeamsListReposInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListReposInOrg",
			ID:   "teams/list-repos-in-org",
		}
	)
	params, err := decodeTeamsListReposInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListReposInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListReposInOrg",
			OperationID:   "teams/list-repos-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"per_page":  params.PerPage,
				"page":      params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposInOrgParams
			Response = TeamsListReposInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListReposInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListReposInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListReposLegacyRequest handles teams/list-repos-legacy operation.
//
// GET /teams/{team_id}/repos
func (s *Server) handleTeamsListReposLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsListReposLegacy",
			ID:   "teams/list-repos-legacy",
		}
	)
	params, err := decodeTeamsListReposLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListReposLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListReposLegacy",
			OperationID:   "teams/list-repos-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposLegacyParams
			Response = TeamsListReposLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsListReposLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsListReposLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMemberLegacyRequest handles teams/remove-member-legacy operation.
//
// DELETE /teams/{team_id}/members/{username}
func (s *Server) handleTeamsRemoveMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveMemberLegacy",
			ID:   "teams/remove-member-legacy",
		}
	)
	params, err := decodeTeamsRemoveMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMemberLegacy",
			OperationID:   "teams/remove-member-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMemberLegacyParams
			Response = TeamsRemoveMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveMemberLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMembershipForUserInOrgRequest handles teams/remove-membership-for-user-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveMembershipForUserInOrg",
			ID:   "teams/remove-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMembershipForUserInOrg",
			OperationID:   "teams/remove-membership-for-user-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"username":  params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserInOrgParams
			Response = TeamsRemoveMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMembershipForUserLegacyRequest handles teams/remove-membership-for-user-legacy operation.
//
// DELETE /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveMembershipForUserLegacy",
			ID:   "teams/remove-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMembershipForUserLegacy",
			OperationID:   "teams/remove-membership-for-user-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":  params.TeamID,
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserLegacyParams
			Response = TeamsRemoveMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveProjectInOrgRequest handles teams/remove-project-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveProjectInOrg",
			ID:   "teams/remove-project-in-org",
		}
	)
	params, err := decodeTeamsRemoveProjectInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveProjectInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveProjectInOrg",
			OperationID:   "teams/remove-project-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":        params.Org,
				"team_slug":  params.TeamSlug,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectInOrgParams
			Response = TeamsRemoveProjectInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveProjectInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveProjectInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveProjectLegacyRequest handles teams/remove-project-legacy operation.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveProjectLegacy",
			ID:   "teams/remove-project-legacy",
		}
	)
	params, err := decodeTeamsRemoveProjectLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveProjectLegacy",
			OperationID:   "teams/remove-project-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id":    params.TeamID,
				"project_id": params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectLegacyParams
			Response = TeamsRemoveProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveProjectLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveProjectLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveRepoInOrgRequest handles teams/remove-repo-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveRepoInOrg",
			ID:   "teams/remove-repo-in-org",
		}
	)
	params, err := decodeTeamsRemoveRepoInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveRepoInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveRepoInOrg",
			OperationID:   "teams/remove-repo-in-org",
			Body:          nil,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
				"owner":     params.Owner,
				"repo":      params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoInOrgParams
			Response = TeamsRemoveRepoInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveRepoInOrg(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveRepoInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveRepoLegacyRequest handles teams/remove-repo-legacy operation.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsRemoveRepoLegacy",
			ID:   "teams/remove-repo-legacy",
		}
	)
	params, err := decodeTeamsRemoveRepoLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveRepoLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveRepoLegacy",
			OperationID:   "teams/remove-repo-legacy",
			Body:          nil,
			Params: map[string]any{
				"team_id": params.TeamID,
				"owner":   params.Owner,
				"repo":    params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoLegacyParams
			Response = TeamsRemoveRepoLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsRemoveRepoLegacy(ctx, params)
			},
		)
	} else {
		response, err = s.h.TeamsRemoveRepoLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionCommentInOrgRequest handles teams/update-discussion-comment-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateDiscussionCommentInOrg",
			ID:   "teams/update-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionCommentInOrg",
			OperationID:   "teams/update-discussion-comment-in-org",
			Body:          request,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = TeamsUpdateDiscussionCommentInOrgReq
			Params   = TeamsUpdateDiscussionCommentInOrgParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionCommentLegacyRequest handles teams/update-discussion-comment-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateDiscussionCommentLegacy",
			ID:   "teams/update-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionCommentLegacy",
			OperationID:   "teams/update-discussion-comment-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
				"comment_number":    params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = TeamsUpdateDiscussionCommentLegacyReq
			Params   = TeamsUpdateDiscussionCommentLegacyParams
			Response = TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionInOrgRequest handles teams/update-discussion-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateDiscussionInOrg",
			ID:   "teams/update-discussion-in-org",
		}
	)
	params, err := decodeTeamsUpdateDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionInOrg",
			OperationID:   "teams/update-discussion-in-org",
			Body:          request,
			Params: map[string]any{
				"org":               params.Org,
				"team_slug":         params.TeamSlug,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionInOrgReq
			Params   = TeamsUpdateDiscussionInOrgParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionLegacyRequest handles teams/update-discussion-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateDiscussionLegacy",
			ID:   "teams/update-discussion-legacy",
		}
	)
	params, err := decodeTeamsUpdateDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionLegacy",
			OperationID:   "teams/update-discussion-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id":           params.TeamID,
				"discussion_number": params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionLegacyReq
			Params   = TeamsUpdateDiscussionLegacyParams
			Response = TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateInOrgRequest handles teams/update-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsUpdateInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateInOrg",
			ID:   "teams/update-in-org",
		}
	)
	params, err := decodeTeamsUpdateInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamFull
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateInOrg",
			OperationID:   "teams/update-in-org",
			Body:          request,
			Params: map[string]any{
				"org":       params.Org,
				"team_slug": params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateInOrgReq
			Params   = TeamsUpdateInOrgParams
			Response = TeamFull
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateInOrgParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateInOrg(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateLegacyRequest handles teams/update-legacy operation.
//
// PATCH /teams/{team_id}
func (s *Server) handleTeamsUpdateLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TeamsUpdateLegacy",
			ID:   "teams/update-legacy",
		}
	)
	params, err := decodeTeamsUpdateLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsUpdateLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateLegacy",
			OperationID:   "teams/update-legacy",
			Body:          request,
			Params: map[string]any{
				"team_id": params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = TeamsUpdateLegacyReq
			Params   = TeamsUpdateLegacyParams
			Response = TeamsUpdateLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateLegacyParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.TeamsUpdateLegacy(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.TeamsUpdateLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersAddEmailForAuthenticatedRequest handles users/add-email-for-authenticated operation.
//
// POST /user/emails
func (s *Server) handleUsersAddEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersAddEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersAddEmailForAuthenticated",
			ID:   "users/add-email-for-authenticated",
		}
	)
	request, close, err := s.decodeUsersAddEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersAddEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersAddEmailForAuthenticated",
			OperationID:   "users/add-email-for-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptUsersAddEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersAddEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersAddEmailForAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersAddEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersAddEmailForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersBlockRequest handles users/block operation.
//
// PUT /user/blocks/{username}
func (s *Server) handleUsersBlockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersBlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersBlock",
			ID:   "users/block",
		}
	)
	params, err := decodeUsersBlockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersBlock",
			OperationID:   "users/block",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersBlockParams
			Response = UsersBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersBlockParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersBlock(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersBlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckBlockedRequest handles users/check-blocked operation.
//
// GET /user/blocks/{username}
func (s *Server) handleUsersCheckBlockedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckBlocked",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersCheckBlocked",
			ID:   "users/check-blocked",
		}
	)
	params, err := decodeUsersCheckBlockedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckBlockedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckBlocked",
			OperationID:   "users/check-blocked",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckBlockedParams
			Response = UsersCheckBlockedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckBlockedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersCheckBlocked(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersCheckBlocked(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckFollowingForUserRequest handles users/check-following-for-user operation.
//
// GET /users/{username}/following/{target_user}
func (s *Server) handleUsersCheckFollowingForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersCheckFollowingForUser",
			ID:   "users/check-following-for-user",
		}
	)
	params, err := decodeUsersCheckFollowingForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckFollowingForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckFollowingForUser",
			OperationID:   "users/check-following-for-user",
			Body:          nil,
			Params: map[string]any{
				"username":    params.Username,
				"target_user": params.TargetUser,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckFollowingForUserParams
			Response = UsersCheckFollowingForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersCheckFollowingForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersCheckFollowingForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckPersonIsFollowedByAuthenticatedRequest handles users/check-person-is-followed-by-authenticated operation.
//
// GET /user/following/{username}
func (s *Server) handleUsersCheckPersonIsFollowedByAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckPersonIsFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersCheckPersonIsFollowedByAuthenticated",
			ID:   "users/check-person-is-followed-by-authenticated",
		}
	)
	params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckPersonIsFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckPersonIsFollowedByAuthenticated",
			OperationID:   "users/check-person-is-followed-by-authenticated",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckPersonIsFollowedByAuthenticatedParams
			Response = UsersCheckPersonIsFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckPersonIsFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCreateGpgKeyForAuthenticatedRequest handles users/create-gpg-key-for-authenticated operation.
//
// POST /user/gpg_keys
func (s *Server) handleUsersCreateGpgKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreateGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersCreateGpgKeyForAuthenticated",
			ID:   "users/create-gpg-key-for-authenticated",
		}
	)
	request, close, err := s.decodeUsersCreateGpgKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreateGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCreateGpgKeyForAuthenticated",
			OperationID:   "users/create-gpg-key-for-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = UsersCreateGpgKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreateGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreateGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCreatePublicSSHKeyForAuthenticatedRequest handles users/create-public-ssh-key-for-authenticated operation.
//
// POST /user/keys
func (s *Server) handleUsersCreatePublicSSHKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreatePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersCreatePublicSSHKeyForAuthenticated",
			ID:   "users/create-public-ssh-key-for-authenticated",
		}
	)
	request, close, err := s.decodeUsersCreatePublicSSHKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreatePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCreatePublicSSHKeyForAuthenticated",
			OperationID:   "users/create-public-ssh-key-for-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = UsersCreatePublicSSHKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreatePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreatePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeleteEmailForAuthenticatedRequest handles users/delete-email-for-authenticated operation.
//
// DELETE /user/emails
func (s *Server) handleUsersDeleteEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersDeleteEmailForAuthenticated",
			ID:   "users/delete-email-for-authenticated",
		}
	)
	request, close, err := s.decodeUsersDeleteEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersDeleteEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeleteEmailForAuthenticated",
			OperationID:   "users/delete-email-for-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptUsersDeleteEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersDeleteEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersDeleteEmailForAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersDeleteEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteEmailForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeleteGpgKeyForAuthenticatedRequest handles users/delete-gpg-key-for-authenticated operation.
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersDeleteGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersDeleteGpgKeyForAuthenticated",
			ID:   "users/delete-gpg-key-for-authenticated",
		}
	)
	params, err := decodeUsersDeleteGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersDeleteGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeleteGpgKeyForAuthenticated",
			OperationID:   "users/delete-gpg-key-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"gpg_key_id": params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeleteGpgKeyForAuthenticatedParams
			Response = UsersDeleteGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeleteGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeletePublicSSHKeyForAuthenticatedRequest handles users/delete-public-ssh-key-for-authenticated operation.
//
// DELETE /user/keys/{key_id}
func (s *Server) handleUsersDeletePublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeletePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersDeletePublicSSHKeyForAuthenticated",
			ID:   "users/delete-public-ssh-key-for-authenticated",
		}
	)
	params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersDeletePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeletePublicSSHKeyForAuthenticated",
			OperationID:   "users/delete-public-ssh-key-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"key_id": params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeletePublicSSHKeyForAuthenticatedParams
			Response = UsersDeletePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeletePublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersFollowRequest handles users/follow operation.
//
// PUT /user/following/{username}
func (s *Server) handleUsersFollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersFollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersFollow",
			ID:   "users/follow",
		}
	)
	params, err := decodeUsersFollowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersFollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersFollow",
			OperationID:   "users/follow",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersFollowParams
			Response = UsersFollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersFollowParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersFollow(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersFollow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersFollowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetAuthenticatedRequest handles users/get-authenticated operation.
//
// GET /user
func (s *Server) handleUsersGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response UsersGetAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetAuthenticated",
			OperationID:   "users/get-authenticated",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersGetAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersGetAuthenticated(ctx)
			},
		)
	} else {
		response, err = s.h.UsersGetAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetByUsernameRequest handles users/get-by-username operation.
//
// GET /users/{username}
func (s *Server) handleUsersGetByUsernameRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetByUsername",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersGetByUsername",
			ID:   "users/get-by-username",
		}
	)
	params, err := decodeUsersGetByUsernameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetByUsernameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetByUsername",
			OperationID:   "users/get-by-username",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetByUsernameParams
			Response = UsersGetByUsernameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetByUsernameParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersGetByUsername(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersGetByUsername(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetContextForUserRequest handles users/get-context-for-user operation.
//
// GET /users/{username}/hovercard
func (s *Server) handleUsersGetContextForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetContextForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersGetContextForUser",
			ID:   "users/get-context-for-user",
		}
	)
	params, err := decodeUsersGetContextForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetContextForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetContextForUser",
			OperationID:   "users/get-context-for-user",
			Body:          nil,
			Params: map[string]any{
				"username":     params.Username,
				"subject_type": params.SubjectType,
				"subject_id":   params.SubjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetContextForUserParams
			Response = UsersGetContextForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetContextForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersGetContextForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersGetContextForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetContextForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetGpgKeyForAuthenticatedRequest handles users/get-gpg-key-for-authenticated operation.
//
// GET /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersGetGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersGetGpgKeyForAuthenticated",
			ID:   "users/get-gpg-key-for-authenticated",
		}
	)
	params, err := decodeUsersGetGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetGpgKeyForAuthenticated",
			OperationID:   "users/get-gpg-key-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"gpg_key_id": params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetGpgKeyForAuthenticatedParams
			Response = UsersGetGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetPublicSSHKeyForAuthenticatedRequest handles users/get-public-ssh-key-for-authenticated operation.
//
// GET /user/keys/{key_id}
func (s *Server) handleUsersGetPublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetPublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersGetPublicSSHKeyForAuthenticated",
			ID:   "users/get-public-ssh-key-for-authenticated",
		}
	)
	params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetPublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetPublicSSHKeyForAuthenticated",
			OperationID:   "users/get-public-ssh-key-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"key_id": params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetPublicSSHKeyForAuthenticatedParams
			Response = UsersGetPublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetPublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListRequest handles users/list operation.
//
// GET /users
func (s *Server) handleUsersListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersList",
			ID:   "users/list",
		}
	)
	params, err := decodeUsersListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersList",
			OperationID:   "users/list",
			Body:          nil,
			Params: map[string]any{
				"since":    params.Since,
				"per_page": params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListParams
			Response = UsersListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersList(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListBlockedByAuthenticatedRequest handles users/list-blocked-by-authenticated operation.
//
// GET /user/blocks
func (s *Server) handleUsersListBlockedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListBlockedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response UsersListBlockedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListBlockedByAuthenticated",
			OperationID:   "users/list-blocked-by-authenticated",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersListBlockedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListBlockedByAuthenticated(ctx)
			},
		)
	} else {
		response, err = s.h.UsersListBlockedByAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListEmailsForAuthenticatedRequest handles users/list-emails-for-authenticated operation.
//
// GET /user/emails
func (s *Server) handleUsersListEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListEmailsForAuthenticated",
			ID:   "users/list-emails-for-authenticated",
		}
	)
	params, err := decodeUsersListEmailsForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListEmailsForAuthenticated",
			OperationID:   "users/list-emails-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListEmailsForAuthenticatedParams
			Response = UsersListEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListEmailsForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowedByAuthenticatedRequest handles users/list-followed-by-authenticated operation.
//
// GET /user/following
func (s *Server) handleUsersListFollowedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListFollowedByAuthenticated",
			ID:   "users/list-followed-by-authenticated",
		}
	)
	params, err := decodeUsersListFollowedByAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowedByAuthenticated",
			OperationID:   "users/list-followed-by-authenticated",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowedByAuthenticatedParams
			Response = UsersListFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListFollowedByAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowersForAuthenticatedUserRequest handles users/list-followers-for-authenticated-user operation.
//
// GET /user/followers
func (s *Server) handleUsersListFollowersForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListFollowersForAuthenticatedUser",
			ID:   "users/list-followers-for-authenticated-user",
		}
	)
	params, err := decodeUsersListFollowersForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowersForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowersForAuthenticatedUser",
			OperationID:   "users/list-followers-for-authenticated-user",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForAuthenticatedUserParams
			Response = UsersListFollowersForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowersForUserRequest handles users/list-followers-for-user operation.
//
// GET /users/{username}/followers
func (s *Server) handleUsersListFollowersForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListFollowersForUser",
			ID:   "users/list-followers-for-user",
		}
	)
	params, err := decodeUsersListFollowersForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowersForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowersForUser",
			OperationID:   "users/list-followers-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForUserParams
			Response = UsersListFollowersForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListFollowersForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowingForUserRequest handles users/list-following-for-user operation.
//
// GET /users/{username}/following
func (s *Server) handleUsersListFollowingForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListFollowingForUser",
			ID:   "users/list-following-for-user",
		}
	)
	params, err := decodeUsersListFollowingForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowingForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowingForUser",
			OperationID:   "users/list-following-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowingForUserParams
			Response = UsersListFollowingForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListFollowingForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListFollowingForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListGpgKeysForAuthenticatedRequest handles users/list-gpg-keys-for-authenticated operation.
//
// GET /user/gpg_keys
func (s *Server) handleUsersListGpgKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListGpgKeysForAuthenticated",
			ID:   "users/list-gpg-keys-for-authenticated",
		}
	)
	params, err := decodeUsersListGpgKeysForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListGpgKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListGpgKeysForAuthenticated",
			OperationID:   "users/list-gpg-keys-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForAuthenticatedParams
			Response = UsersListGpgKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListGpgKeysForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListGpgKeysForUserRequest handles users/list-gpg-keys-for-user operation.
//
// GET /users/{username}/gpg_keys
func (s *Server) handleUsersListGpgKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListGpgKeysForUser",
			ID:   "users/list-gpg-keys-for-user",
		}
	)
	params, err := decodeUsersListGpgKeysForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListGpgKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListGpgKeysForUser",
			OperationID:   "users/list-gpg-keys-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForUserParams
			Response = UsersListGpgKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListGpgKeysForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicEmailsForAuthenticatedRequest handles users/list-public-emails-for-authenticated operation.
//
// GET /user/public_emails
func (s *Server) handleUsersListPublicEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListPublicEmailsForAuthenticated",
			ID:   "users/list-public-emails-for-authenticated",
		}
	)
	params, err := decodeUsersListPublicEmailsForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListPublicEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicEmailsForAuthenticated",
			OperationID:   "users/list-public-emails-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicEmailsForAuthenticatedParams
			Response = UsersListPublicEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicKeysForUserRequest handles users/list-public-keys-for-user operation.
//
// GET /users/{username}/keys
func (s *Server) handleUsersListPublicKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListPublicKeysForUser",
			ID:   "users/list-public-keys-for-user",
		}
	)
	params, err := decodeUsersListPublicKeysForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListPublicKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicKeysForUser",
			OperationID:   "users/list-public-keys-for-user",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicKeysForUserParams
			Response = UsersListPublicKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListPublicKeysForUser(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListPublicKeysForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicSSHKeysForAuthenticatedRequest handles users/list-public-ssh-keys-for-authenticated operation.
//
// GET /user/keys
func (s *Server) handleUsersListPublicSSHKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicSSHKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersListPublicSSHKeysForAuthenticated",
			ID:   "users/list-public-ssh-keys-for-authenticated",
		}
	)
	params, err := decodeUsersListPublicSSHKeysForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListPublicSSHKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicSSHKeysForAuthenticated",
			OperationID:   "users/list-public-ssh-keys-for-authenticated",
			Body:          nil,
			Params: map[string]any{
				"per_page": params.PerPage,
				"page":     params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicSSHKeysForAuthenticatedParams
			Response = UsersListPublicSSHKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicSSHKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest handles users/set-primary-email-visibility-for-authenticated operation.
//
// PATCH /user/email/visibility
func (s *Server) handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersSetPrimaryEmailVisibilityForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersSetPrimaryEmailVisibilityForAuthenticated",
			ID:   "users/set-primary-email-visibility-for-authenticated",
		}
	)
	request, close, err := s.decodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersSetPrimaryEmailVisibilityForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersSetPrimaryEmailVisibilityForAuthenticated",
			OperationID:   "users/set-primary-email-visibility-for-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = UsersSetPrimaryEmailVisibilityForAuthenticatedReq
			Params   = struct{}
			Response = UsersSetPrimaryEmailVisibilityForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUnblockRequest handles users/unblock operation.
//
// DELETE /user/blocks/{username}
func (s *Server) handleUsersUnblockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnblock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersUnblock",
			ID:   "users/unblock",
		}
	)
	params, err := decodeUsersUnblockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersUnblockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUnblock",
			OperationID:   "users/unblock",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnblockParams
			Response = UsersUnblockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnblockParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersUnblock(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersUnblock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnblockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUnfollowRequest handles users/unfollow operation.
//
// DELETE /user/following/{username}
func (s *Server) handleUsersUnfollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnfollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersUnfollow",
			ID:   "users/unfollow",
		}
	)
	params, err := decodeUsersUnfollowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersUnfollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUnfollow",
			OperationID:   "users/unfollow",
			Body:          nil,
			Params: map[string]any{
				"username": params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnfollowParams
			Response = UsersUnfollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnfollowParams,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersUnfollow(ctx, params)
			},
		)
	} else {
		response, err = s.h.UsersUnfollow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUpdateAuthenticatedRequest handles users/update-authenticated operation.
//
// PATCH /user
func (s *Server) handleUsersUpdateAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUpdateAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UsersUpdateAuthenticated",
			ID:   "users/update-authenticated",
		}
	)
	request, close, err := s.decodeUsersUpdateAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersUpdateAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUpdateAuthenticated",
			OperationID:   "users/update-authenticated",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptUsersUpdateAuthenticatedReq
			Params   = struct{}
			Response = UsersUpdateAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (Response, error) {
				return s.h.UsersUpdateAuthenticated(ctx, request)
			},
		)
	} else {
		response, err = s.h.UsersUpdateAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUpdateAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
