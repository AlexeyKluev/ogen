// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// HandleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) HandleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/add-repo-access-to-self-hosted-runner-group-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsAddSelectedRepoToOrgSecretRequest handles actions/add-selected-repo-to-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) HandleActionsAddSelectedRepoToOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsAddSelectedRepoToOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/add-selected-repo-to-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsAddSelectedRepoToOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsAddSelfHostedRunnerToGroupForOrgRequest handles actions/add-self-hosted-runner-to-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) HandleActionsAddSelfHostedRunnerToGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsAddSelfHostedRunnerToGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/add-self-hosted-runner-to-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsApproveWorkflowRunRequest handles actions/approve-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (s *Server) HandleActionsApproveWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsApproveWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/approve-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsApproveWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsApproveWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCancelWorkflowRunRequest handles actions/cancel-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (s *Server) HandleActionsCancelWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCancelWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/cancel-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCancelWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCancelWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateOrUpdateEnvironmentSecretRequest handles actions/create-or-update-environment-secret operation.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) HandleActionsCreateOrUpdateEnvironmentSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateEnvironmentSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-environment-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateEnvironmentSecretRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateOrUpdateOrgSecretRequest handles actions/create-or-update-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) HandleActionsCreateOrUpdateOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateOrUpdateOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateOrgSecretRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateOrUpdateRepoSecretRequest handles actions/create-or-update-repo-secret operation.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) HandleActionsCreateOrUpdateRepoSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateOrUpdateRepoSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-or-update-repo-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateOrUpdateRepoSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateRepoSecretRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateRegistrationTokenForOrgRequest handles actions/create-registration-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/registration-token
func (s *Server) HandleActionsCreateRegistrationTokenForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateRegistrationTokenForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-registration-token-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateRegistrationTokenForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateRegistrationTokenForRepoRequest handles actions/create-registration-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (s *Server) HandleActionsCreateRegistrationTokenForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateRegistrationTokenForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-registration-token-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateRegistrationTokenForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateRemoveTokenForOrgRequest handles actions/create-remove-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/remove-token
func (s *Server) HandleActionsCreateRemoveTokenForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateRemoveTokenForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-remove-token-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateRemoveTokenForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateRemoveTokenForRepoRequest handles actions/create-remove-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (s *Server) HandleActionsCreateRemoveTokenForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateRemoveTokenForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-remove-token-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateRemoveTokenForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsCreateSelfHostedRunnerGroupForOrgRequest handles actions/create-self-hosted-runner-group-for-org operation.
//
// POST /orgs/{org}/actions/runner-groups
func (s *Server) HandleActionsCreateSelfHostedRunnerGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsCreateSelfHostedRunnerGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/create-self-hosted-runner-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteArtifactRequest handles actions/delete-artifact operation.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) HandleActionsDeleteArtifactRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteArtifact`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-artifact`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteArtifactParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteEnvironmentSecretRequest handles actions/delete-environment-secret operation.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) HandleActionsDeleteEnvironmentSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteEnvironmentSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-environment-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteEnvironmentSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteEnvironmentSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteOrgSecretRequest handles actions/delete-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) HandleActionsDeleteOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteRepoSecretRequest handles actions/delete-repo-secret operation.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) HandleActionsDeleteRepoSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteRepoSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-repo-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteRepoSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteRepoSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteSelfHostedRunnerFromOrgRequest handles actions/delete-self-hosted-runner-from-org operation.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (s *Server) HandleActionsDeleteSelfHostedRunnerFromOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerFromOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-from-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteSelfHostedRunnerFromRepoRequest handles actions/delete-self-hosted-runner-from-repo operation.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) HandleActionsDeleteSelfHostedRunnerFromRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerFromRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-from-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteSelfHostedRunnerGroupFromOrgRequest handles actions/delete-self-hosted-runner-group-from-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteSelfHostedRunnerGroupFromOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-self-hosted-runner-group-from-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteWorkflowRunRequest handles actions/delete-workflow-run operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) HandleActionsDeleteWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDeleteWorkflowRunLogsRequest handles actions/delete-workflow-run-logs operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) HandleActionsDeleteWorkflowRunLogsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDeleteWorkflowRunLogs`,
		trace.WithAttributes(otelogen.OperationID(`actions/delete-workflow-run-logs`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDeleteWorkflowRunLogsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest handles actions/disable-selected-repository-github-actions-organization operation.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) HandleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDisableSelectedRepositoryGithubActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/disable-selected-repository-github-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDownloadArtifactRequest handles actions/download-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (s *Server) HandleActionsDownloadArtifactRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDownloadArtifact`,
		trace.WithAttributes(otelogen.OperationID(`actions/download-artifact`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDownloadArtifactParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDownloadArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDownloadJobLogsForWorkflowRunRequest handles actions/download-job-logs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (s *Server) HandleActionsDownloadJobLogsForWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDownloadJobLogsForWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/download-job-logs-for-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsDownloadWorkflowRunLogsRequest handles actions/download-workflow-run-logs operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) HandleActionsDownloadWorkflowRunLogsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsDownloadWorkflowRunLogs`,
		trace.WithAttributes(otelogen.OperationID(`actions/download-workflow-run-logs`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsDownloadWorkflowRunLogsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest handles actions/enable-selected-repository-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) HandleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsEnableSelectedRepositoryGithubActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/enable-selected-repository-github-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetAllowedActionsOrganizationRequest handles actions/get-allowed-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (s *Server) HandleActionsGetAllowedActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetAllowedActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-allowed-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetAllowedActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetAllowedActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetAllowedActionsRepositoryRequest handles actions/get-allowed-actions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) HandleActionsGetAllowedActionsRepositoryRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetAllowedActionsRepository`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-allowed-actions-repository`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetAllowedActionsRepositoryParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetAllowedActionsRepository(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetArtifactRequest handles actions/get-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) HandleActionsGetArtifactRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetArtifact`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-artifact`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetArtifactParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetEnvironmentPublicKeyRequest handles actions/get-environment-public-key operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (s *Server) HandleActionsGetEnvironmentPublicKeyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetEnvironmentPublicKey`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-environment-public-key`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetEnvironmentPublicKeyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetEnvironmentPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetEnvironmentSecretRequest handles actions/get-environment-secret operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) HandleActionsGetEnvironmentSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetEnvironmentSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-environment-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetEnvironmentSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetEnvironmentSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetGithubActionsPermissionsOrganizationRequest handles actions/get-github-actions-permissions-organization operation.
//
// GET /orgs/{org}/actions/permissions
func (s *Server) HandleActionsGetGithubActionsPermissionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetGithubActionsPermissionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-github-actions-permissions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetGithubActionsPermissionsRepositoryRequest handles actions/get-github-actions-permissions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (s *Server) HandleActionsGetGithubActionsPermissionsRepositoryRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetGithubActionsPermissionsRepository`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-github-actions-permissions-repository`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetJobForWorkflowRunRequest handles actions/get-job-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (s *Server) HandleActionsGetJobForWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetJobForWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-job-for-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetJobForWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetJobForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetOrgPublicKeyRequest handles actions/get-org-public-key operation.
//
// GET /orgs/{org}/actions/secrets/public-key
func (s *Server) HandleActionsGetOrgPublicKeyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetOrgPublicKey`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-org-public-key`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetOrgPublicKeyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetOrgPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetOrgSecretRequest handles actions/get-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) HandleActionsGetOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetRepoPublicKeyRequest handles actions/get-repo-public-key operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (s *Server) HandleActionsGetRepoPublicKeyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetRepoPublicKey`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-repo-public-key`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetRepoPublicKeyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetRepoPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetRepoSecretRequest handles actions/get-repo-secret operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) HandleActionsGetRepoSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetRepoSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-repo-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetRepoSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetRepoSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetReviewsForRunRequest handles actions/get-reviews-for-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (s *Server) HandleActionsGetReviewsForRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetReviewsForRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-reviews-for-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetReviewsForRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetReviewsForRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetSelfHostedRunnerForOrgRequest handles actions/get-self-hosted-runner-for-org operation.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (s *Server) HandleActionsGetSelfHostedRunnerForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetSelfHostedRunnerForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetSelfHostedRunnerForRepoRequest handles actions/get-self-hosted-runner-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) HandleActionsGetSelfHostedRunnerForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetSelfHostedRunnerForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetSelfHostedRunnerGroupForOrgRequest handles actions/get-self-hosted-runner-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleActionsGetSelfHostedRunnerGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetSelfHostedRunnerGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-self-hosted-runner-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetWorkflowRunRequest handles actions/get-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) HandleActionsGetWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsGetWorkflowRunUsageRequest handles actions/get-workflow-run-usage operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (s *Server) HandleActionsGetWorkflowRunUsageRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsGetWorkflowRunUsage`,
		trace.WithAttributes(otelogen.OperationID(`actions/get-workflow-run-usage`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsGetWorkflowRunUsageParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsGetWorkflowRunUsage(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListArtifactsForRepoRequest handles actions/list-artifacts-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (s *Server) HandleActionsListArtifactsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListArtifactsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-artifacts-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListArtifactsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListArtifactsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListEnvironmentSecretsRequest handles actions/list-environment-secrets operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (s *Server) HandleActionsListEnvironmentSecretsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListEnvironmentSecrets`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-environment-secrets`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListEnvironmentSecretsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListEnvironmentSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListJobsForWorkflowRunRequest handles actions/list-jobs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (s *Server) HandleActionsListJobsForWorkflowRunRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListJobsForWorkflowRun`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-jobs-for-workflow-run`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListJobsForWorkflowRunParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListJobsForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListOrgSecretsRequest handles actions/list-org-secrets operation.
//
// GET /orgs/{org}/actions/secrets
func (s *Server) HandleActionsListOrgSecretsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListOrgSecrets`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-org-secrets`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListOrgSecretsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListOrgSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) HandleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListRepoAccessToSelfHostedRunnerGroupInOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-repo-access-to-self-hosted-runner-group-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListRepoSecretsRequest handles actions/list-repo-secrets operation.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (s *Server) HandleActionsListRepoSecretsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListRepoSecrets`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-repo-secrets`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListRepoSecretsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListRepoSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListRepoWorkflowsRequest handles actions/list-repo-workflows operation.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (s *Server) HandleActionsListRepoWorkflowsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListRepoWorkflows`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-repo-workflows`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListRepoWorkflowsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListRepoWorkflows(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListRunnerApplicationsForOrgRequest handles actions/list-runner-applications-for-org operation.
//
// GET /orgs/{org}/actions/runners/downloads
func (s *Server) HandleActionsListRunnerApplicationsForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListRunnerApplicationsForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-runner-applications-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListRunnerApplicationsForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListRunnerApplicationsForRepoRequest handles actions/list-runner-applications-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (s *Server) HandleActionsListRunnerApplicationsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListRunnerApplicationsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-runner-applications-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListRunnerApplicationsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelectedReposForOrgSecretRequest handles actions/list-selected-repos-for-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) HandleActionsListSelectedReposForOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelectedReposForOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-selected-repos-for-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelectedReposForOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/repositories
func (s *Server) HandleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelectedRepositoriesEnabledGithubActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-selected-repositories-enabled-github-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelfHostedRunnerGroupsForOrgRequest handles actions/list-self-hosted-runner-groups-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups
func (s *Server) HandleActionsListSelfHostedRunnerGroupsForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnerGroupsForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runner-groups-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelfHostedRunnersForOrgRequest handles actions/list-self-hosted-runners-for-org operation.
//
// GET /orgs/{org}/actions/runners
func (s *Server) HandleActionsListSelfHostedRunnersForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelfHostedRunnersForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelfHostedRunnersForRepoRequest handles actions/list-self-hosted-runners-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners
func (s *Server) HandleActionsListSelfHostedRunnersForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelfHostedRunnersForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListSelfHostedRunnersInGroupForOrgRequest handles actions/list-self-hosted-runners-in-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) HandleActionsListSelfHostedRunnersInGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListSelfHostedRunnersInGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-self-hosted-runners-in-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListWorkflowRunArtifactsRequest handles actions/list-workflow-run-artifacts operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (s *Server) HandleActionsListWorkflowRunArtifactsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListWorkflowRunArtifacts`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-workflow-run-artifacts`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListWorkflowRunArtifactsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListWorkflowRunArtifacts(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsListWorkflowRunsForRepoRequest handles actions/list-workflow-runs-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runs
func (s *Server) HandleActionsListWorkflowRunsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsListWorkflowRunsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`actions/list-workflow-runs-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsListWorkflowRunsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsListWorkflowRunsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsReRunWorkflowRequest handles actions/re-run-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (s *Server) HandleActionsReRunWorkflowRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsReRunWorkflow`,
		trace.WithAttributes(otelogen.OperationID(`actions/re-run-workflow`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsReRunWorkflowParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsReRunWorkflow(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) HandleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/remove-repo-access-to-self-hosted-runner-group-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsRemoveSelectedRepoFromOrgSecretRequest handles actions/remove-selected-repo-from-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) HandleActionsRemoveSelectedRepoFromOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsRemoveSelectedRepoFromOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/remove-selected-repo-from-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest handles actions/remove-self-hosted-runner-from-group-for-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) HandleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsRemoveSelfHostedRunnerFromGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/remove-self-hosted-runner-from-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsRetryWorkflowRequest handles actions/retry-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (s *Server) HandleActionsRetryWorkflowRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsRetryWorkflow`,
		trace.WithAttributes(otelogen.OperationID(`actions/retry-workflow`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsRetryWorkflowParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsRetryWorkflow(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetAllowedActionsOrganizationRequest handles actions/set-allowed-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (s *Server) HandleActionsSetAllowedActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetAllowedActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-allowed-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetAllowedActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetAllowedActionsOrganizationRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetAllowedActionsRepositoryRequest handles actions/set-allowed-actions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) HandleActionsSetAllowedActionsRepositoryRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetAllowedActionsRepository`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-allowed-actions-repository`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetAllowedActionsRepositoryParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetAllowedActionsRepositoryRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetGithubActionsPermissionsOrganizationRequest handles actions/set-github-actions-permissions-organization operation.
//
// PUT /orgs/{org}/actions/permissions
func (s *Server) HandleActionsSetGithubActionsPermissionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetGithubActionsPermissionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-github-actions-permissions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetGithubActionsPermissionsOrganizationRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetGithubActionsPermissionsRepositoryRequest handles actions/set-github-actions-permissions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (s *Server) HandleActionsSetGithubActionsPermissionsRepositoryRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetGithubActionsPermissionsRepository`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-github-actions-permissions-repository`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetGithubActionsPermissionsRepositoryRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) HandleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-repo-access-to-self-hosted-runner-group-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetSelectedReposForOrgSecretRequest handles actions/set-selected-repos-for-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) HandleActionsSetSelectedReposForOrgSecretRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetSelectedReposForOrgSecret`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-selected-repos-for-org-secret`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetSelectedReposForOrgSecretParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetSelectedReposForOrgSecretRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (s *Server) HandleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-selected-repositories-enabled-github-actions-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsSetSelfHostedRunnersInGroupForOrgRequest handles actions/set-self-hosted-runners-in-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) HandleActionsSetSelfHostedRunnersInGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsSetSelfHostedRunnersInGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/set-self-hosted-runners-in-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActionsUpdateSelfHostedRunnerGroupForOrgRequest handles actions/update-self-hosted-runner-group-for-org operation.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleActionsUpdateSelfHostedRunnerGroupForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActionsUpdateSelfHostedRunnerGroupForOrg`,
		trace.WithAttributes(otelogen.OperationID(`actions/update-self-hosted-runner-group-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityCheckRepoIsStarredByAuthenticatedUserRequest handles activity/check-repo-is-starred-by-authenticated-user operation.
//
// GET /user/starred/{owner}/{repo}
func (s *Server) HandleActivityCheckRepoIsStarredByAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityCheckRepoIsStarredByAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/check-repo-is-starred-by-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityDeleteRepoSubscriptionRequest handles activity/delete-repo-subscription operation.
//
// DELETE /repos/{owner}/{repo}/subscription
func (s *Server) HandleActivityDeleteRepoSubscriptionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityDeleteRepoSubscription`,
		trace.WithAttributes(otelogen.OperationID(`activity/delete-repo-subscription`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityDeleteRepoSubscriptionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityDeleteRepoSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityDeleteThreadSubscriptionRequest handles activity/delete-thread-subscription operation.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (s *Server) HandleActivityDeleteThreadSubscriptionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityDeleteThreadSubscription`,
		trace.WithAttributes(otelogen.OperationID(`activity/delete-thread-subscription`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityDeleteThreadSubscriptionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityDeleteThreadSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityGetFeedsRequest handles activity/get-feeds operation.
//
// GET /feeds
func (s *Server) HandleActivityGetFeedsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityGetFeeds`,
		trace.WithAttributes(otelogen.OperationID(`activity/get-feeds`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.ActivityGetFeeds(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityGetRepoSubscriptionRequest handles activity/get-repo-subscription operation.
//
// GET /repos/{owner}/{repo}/subscription
func (s *Server) HandleActivityGetRepoSubscriptionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityGetRepoSubscription`,
		trace.WithAttributes(otelogen.OperationID(`activity/get-repo-subscription`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityGetRepoSubscriptionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityGetRepoSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityGetThreadRequest handles activity/get-thread operation.
//
// GET /notifications/threads/{thread_id}
func (s *Server) HandleActivityGetThreadRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityGetThread`,
		trace.WithAttributes(otelogen.OperationID(`activity/get-thread`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityGetThreadParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityGetThread(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityGetThreadSubscriptionForAuthenticatedUserRequest handles activity/get-thread-subscription-for-authenticated-user operation.
//
// GET /notifications/threads/{thread_id}/subscription
func (s *Server) HandleActivityGetThreadSubscriptionForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityGetThreadSubscriptionForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/get-thread-subscription-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListEventsForAuthenticatedUserRequest handles activity/list-events-for-authenticated-user operation.
//
// GET /users/{username}/events
func (s *Server) HandleActivityListEventsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListEventsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-events-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListEventsForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListOrgEventsForAuthenticatedUserRequest handles activity/list-org-events-for-authenticated-user operation.
//
// GET /users/{username}/events/orgs/{org}
func (s *Server) HandleActivityListOrgEventsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListOrgEventsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-org-events-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListPublicEventsRequest handles activity/list-public-events operation.
//
// GET /events
func (s *Server) HandleActivityListPublicEventsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListPublicEvents`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-public-events`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListPublicEventsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListPublicEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListPublicEventsForRepoNetworkRequest handles activity/list-public-events-for-repo-network operation.
//
// GET /networks/{owner}/{repo}/events
func (s *Server) HandleActivityListPublicEventsForRepoNetworkRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListPublicEventsForRepoNetwork`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-public-events-for-repo-network`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListPublicEventsForRepoNetworkParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListPublicEventsForUserRequest handles activity/list-public-events-for-user operation.
//
// GET /users/{username}/events/public
func (s *Server) HandleActivityListPublicEventsForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListPublicEventsForUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-public-events-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListPublicEventsForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListPublicEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListPublicOrgEventsRequest handles activity/list-public-org-events operation.
//
// GET /orgs/{org}/events
func (s *Server) HandleActivityListPublicOrgEventsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListPublicOrgEvents`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-public-org-events`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListPublicOrgEventsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListPublicOrgEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListReceivedEventsForUserRequest handles activity/list-received-events-for-user operation.
//
// GET /users/{username}/received_events
func (s *Server) HandleActivityListReceivedEventsForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListReceivedEventsForUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-received-events-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListReceivedEventsForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListReceivedEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListReceivedPublicEventsForUserRequest handles activity/list-received-public-events-for-user operation.
//
// GET /users/{username}/received_events/public
func (s *Server) HandleActivityListReceivedPublicEventsForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListReceivedPublicEventsForUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-received-public-events-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListReceivedPublicEventsForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListRepoEventsRequest handles activity/list-repo-events operation.
//
// GET /repos/{owner}/{repo}/events
func (s *Server) HandleActivityListRepoEventsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListRepoEvents`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-repo-events`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListRepoEventsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListRepoEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListRepoNotificationsForAuthenticatedUserRequest handles activity/list-repo-notifications-for-authenticated-user operation.
//
// GET /repos/{owner}/{repo}/notifications
func (s *Server) HandleActivityListRepoNotificationsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListRepoNotificationsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-repo-notifications-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListReposStarredByAuthenticatedUserRequest handles activity/list-repos-starred-by-authenticated-user operation.
//
// GET /user/starred
func (s *Server) HandleActivityListReposStarredByAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListReposStarredByAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-repos-starred-by-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListReposStarredByAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListReposWatchedByUserRequest handles activity/list-repos-watched-by-user operation.
//
// GET /users/{username}/subscriptions
func (s *Server) HandleActivityListReposWatchedByUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListReposWatchedByUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-repos-watched-by-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListReposWatchedByUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListReposWatchedByUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListWatchedReposForAuthenticatedUserRequest handles activity/list-watched-repos-for-authenticated-user operation.
//
// GET /user/subscriptions
func (s *Server) HandleActivityListWatchedReposForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListWatchedReposForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-watched-repos-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListWatchedReposForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityListWatchersForRepoRequest handles activity/list-watchers-for-repo operation.
//
// GET /repos/{owner}/{repo}/subscribers
func (s *Server) HandleActivityListWatchersForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityListWatchersForRepo`,
		trace.WithAttributes(otelogen.OperationID(`activity/list-watchers-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityListWatchersForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityListWatchersForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityMarkNotificationsAsReadRequest handles activity/mark-notifications-as-read operation.
//
// PUT /notifications
func (s *Server) HandleActivityMarkNotificationsAsReadRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityMarkNotificationsAsRead`,
		trace.WithAttributes(otelogen.OperationID(`activity/mark-notifications-as-read`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	request, err := decodeActivityMarkNotificationsAsReadRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityMarkNotificationsAsRead(ctx, request)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityMarkRepoNotificationsAsReadRequest handles activity/mark-repo-notifications-as-read operation.
//
// PUT /repos/{owner}/{repo}/notifications
func (s *Server) HandleActivityMarkRepoNotificationsAsReadRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityMarkRepoNotificationsAsRead`,
		trace.WithAttributes(otelogen.OperationID(`activity/mark-repo-notifications-as-read`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityMarkRepoNotificationsAsReadParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActivityMarkRepoNotificationsAsReadRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityMarkThreadAsReadRequest handles activity/mark-thread-as-read operation.
//
// PATCH /notifications/threads/{thread_id}
func (s *Server) HandleActivityMarkThreadAsReadRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityMarkThreadAsRead`,
		trace.WithAttributes(otelogen.OperationID(`activity/mark-thread-as-read`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityMarkThreadAsReadParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityMarkThreadAsRead(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivitySetRepoSubscriptionRequest handles activity/set-repo-subscription operation.
//
// PUT /repos/{owner}/{repo}/subscription
func (s *Server) HandleActivitySetRepoSubscriptionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivitySetRepoSubscription`,
		trace.WithAttributes(otelogen.OperationID(`activity/set-repo-subscription`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivitySetRepoSubscriptionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActivitySetRepoSubscriptionRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivitySetRepoSubscription(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivitySetThreadSubscriptionRequest handles activity/set-thread-subscription operation.
//
// PUT /notifications/threads/{thread_id}/subscription
func (s *Server) HandleActivitySetThreadSubscriptionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivitySetThreadSubscription`,
		trace.WithAttributes(otelogen.OperationID(`activity/set-thread-subscription`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivitySetThreadSubscriptionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeActivitySetThreadSubscriptionRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivitySetThreadSubscription(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityStarRepoForAuthenticatedUserRequest handles activity/star-repo-for-authenticated-user operation.
//
// PUT /user/starred/{owner}/{repo}
func (s *Server) HandleActivityStarRepoForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityStarRepoForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/star-repo-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityStarRepoForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleActivityUnstarRepoForAuthenticatedUserRequest handles activity/unstar-repo-for-authenticated-user operation.
//
// DELETE /user/starred/{owner}/{repo}
func (s *Server) HandleActivityUnstarRepoForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ActivityUnstarRepoForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`activity/unstar-repo-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsAddRepoToInstallationRequest handles apps/add-repo-to-installation operation.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) HandleAppsAddRepoToInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsAddRepoToInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/add-repo-to-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsAddRepoToInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsAddRepoToInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsDeleteInstallationRequest handles apps/delete-installation operation.
//
// DELETE /app/installations/{installation_id}
func (s *Server) HandleAppsDeleteInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsDeleteInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/delete-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsDeleteInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsDeleteInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsGetAuthenticatedRequest handles apps/get-authenticated operation.
//
// GET /app
func (s *Server) HandleAppsGetAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsGetAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`apps/get-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.AppsGetAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsGetBySlugRequest handles apps/get-by-slug operation.
//
// GET /apps/{app_slug}
func (s *Server) HandleAppsGetBySlugRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsGetBySlug`,
		trace.WithAttributes(otelogen.OperationID(`apps/get-by-slug`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsGetBySlugParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsGetBySlug(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsGetSubscriptionPlanForAccountRequest handles apps/get-subscription-plan-for-account operation.
//
// GET /marketplace_listing/accounts/{account_id}
func (s *Server) HandleAppsGetSubscriptionPlanForAccountRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsGetSubscriptionPlanForAccount`,
		trace.WithAttributes(otelogen.OperationID(`apps/get-subscription-plan-for-account`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsGetSubscriptionPlanForAccountParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsGetSubscriptionPlanForAccountStubbedRequest handles apps/get-subscription-plan-for-account-stubbed operation.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (s *Server) HandleAppsGetSubscriptionPlanForAccountStubbedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsGetSubscriptionPlanForAccountStubbed`,
		trace.WithAttributes(otelogen.OperationID(`apps/get-subscription-plan-for-account-stubbed`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsGetWebhookConfigForAppRequest handles apps/get-webhook-config-for-app operation.
//
// GET /app/hook/config
func (s *Server) HandleAppsGetWebhookConfigForAppRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsGetWebhookConfigForApp`,
		trace.WithAttributes(otelogen.OperationID(`apps/get-webhook-config-for-app`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.AppsGetWebhookConfigForApp(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListAccountsForPlanStubbedRequest handles apps/list-accounts-for-plan-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (s *Server) HandleAppsListAccountsForPlanStubbedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListAccountsForPlanStubbed`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-accounts-for-plan-stubbed`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListAccountsForPlanStubbedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListAccountsForPlanStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListInstallationReposForAuthenticatedUserRequest handles apps/list-installation-repos-for-authenticated-user operation.
//
// GET /user/installations/{installation_id}/repositories
func (s *Server) HandleAppsListInstallationReposForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListInstallationReposForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-installation-repos-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListPlansRequest handles apps/list-plans operation.
//
// GET /marketplace_listing/plans
func (s *Server) HandleAppsListPlansRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListPlans`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-plans`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListPlansParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListPlans(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListPlansResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListPlansStubbedRequest handles apps/list-plans-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans
func (s *Server) HandleAppsListPlansStubbedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListPlansStubbed`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-plans-stubbed`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListPlansStubbedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListPlansStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListReposAccessibleToInstallationRequest handles apps/list-repos-accessible-to-installation operation.
//
// GET /installation/repositories
func (s *Server) HandleAppsListReposAccessibleToInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListReposAccessibleToInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-repos-accessible-to-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListReposAccessibleToInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListReposAccessibleToInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListSubscriptionsForAuthenticatedUserRequest handles apps/list-subscriptions-for-authenticated-user operation.
//
// GET /user/marketplace_purchases
func (s *Server) HandleAppsListSubscriptionsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListSubscriptionsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-subscriptions-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsListSubscriptionsForAuthenticatedUserStubbedRequest handles apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// GET /user/marketplace_purchases/stubbed
func (s *Server) HandleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsListSubscriptionsForAuthenticatedUserStubbed`,
		trace.WithAttributes(otelogen.OperationID(`apps/list-subscriptions-for-authenticated-user-stubbed`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsRemoveRepoFromInstallationRequest handles apps/remove-repo-from-installation operation.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) HandleAppsRemoveRepoFromInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsRemoveRepoFromInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/remove-repo-from-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsRemoveRepoFromInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsRemoveRepoFromInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsRevokeInstallationAccessTokenRequest handles apps/revoke-installation-access-token operation.
//
// DELETE /installation/token
func (s *Server) HandleAppsRevokeInstallationAccessTokenRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsRevokeInstallationAccessToken`,
		trace.WithAttributes(otelogen.OperationID(`apps/revoke-installation-access-token`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.AppsRevokeInstallationAccessToken(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsSuspendInstallationRequest handles apps/suspend-installation operation.
//
// PUT /app/installations/{installation_id}/suspended
func (s *Server) HandleAppsSuspendInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsSuspendInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/suspend-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsSuspendInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsSuspendInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsUnsuspendInstallationRequest handles apps/unsuspend-installation operation.
//
// DELETE /app/installations/{installation_id}/suspended
func (s *Server) HandleAppsUnsuspendInstallationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsUnsuspendInstallation`,
		trace.WithAttributes(otelogen.OperationID(`apps/unsuspend-installation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeAppsUnsuspendInstallationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsUnsuspendInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleAppsUpdateWebhookConfigForAppRequest handles apps/update-webhook-config-for-app operation.
//
// PATCH /app/hook/config
func (s *Server) HandleAppsUpdateWebhookConfigForAppRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `AppsUpdateWebhookConfigForApp`,
		trace.WithAttributes(otelogen.OperationID(`apps/update-webhook-config-for-app`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	request, err := decodeAppsUpdateWebhookConfigForAppRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.AppsUpdateWebhookConfigForApp(ctx, request)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubActionsBillingGheRequest handles billing/get-github-actions-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (s *Server) HandleBillingGetGithubActionsBillingGheRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingGhe`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-ghe`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubActionsBillingGheParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubActionsBillingOrgRequest handles billing/get-github-actions-billing-org operation.
//
// GET /orgs/{org}/settings/billing/actions
func (s *Server) HandleBillingGetGithubActionsBillingOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingOrg`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubActionsBillingOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubActionsBillingUserRequest handles billing/get-github-actions-billing-user operation.
//
// GET /users/{username}/settings/billing/actions
func (s *Server) HandleBillingGetGithubActionsBillingUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubActionsBillingUser`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-actions-billing-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubActionsBillingUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubPackagesBillingGheRequest handles billing/get-github-packages-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (s *Server) HandleBillingGetGithubPackagesBillingGheRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingGhe`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-ghe`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubPackagesBillingGheParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubPackagesBillingOrgRequest handles billing/get-github-packages-billing-org operation.
//
// GET /orgs/{org}/settings/billing/packages
func (s *Server) HandleBillingGetGithubPackagesBillingOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingOrg`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubPackagesBillingOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetGithubPackagesBillingUserRequest handles billing/get-github-packages-billing-user operation.
//
// GET /users/{username}/settings/billing/packages
func (s *Server) HandleBillingGetGithubPackagesBillingUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetGithubPackagesBillingUser`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-github-packages-billing-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetGithubPackagesBillingUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetSharedStorageBillingGheRequest handles billing/get-shared-storage-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (s *Server) HandleBillingGetSharedStorageBillingGheRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingGhe`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-ghe`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetSharedStorageBillingGheParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetSharedStorageBillingOrgRequest handles billing/get-shared-storage-billing-org operation.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (s *Server) HandleBillingGetSharedStorageBillingOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingOrg`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetSharedStorageBillingOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleBillingGetSharedStorageBillingUserRequest handles billing/get-shared-storage-billing-user operation.
//
// GET /users/{username}/settings/billing/shared-storage
func (s *Server) HandleBillingGetSharedStorageBillingUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `BillingGetSharedStorageBillingUser`,
		trace.WithAttributes(otelogen.OperationID(`billing/get-shared-storage-billing-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeBillingGetSharedStorageBillingUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksCreateSuiteRequest handles checks/create-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites
func (s *Server) HandleChecksCreateSuiteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksCreateSuite`,
		trace.WithAttributes(otelogen.OperationID(`checks/create-suite`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksCreateSuiteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeChecksCreateSuiteRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksCreateSuite(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksGetRequest handles checks/get operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (s *Server) HandleChecksGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksGet`,
		trace.WithAttributes(otelogen.OperationID(`checks/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksGetSuiteRequest handles checks/get-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (s *Server) HandleChecksGetSuiteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksGetSuite`,
		trace.WithAttributes(otelogen.OperationID(`checks/get-suite`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksGetSuiteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksGetSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksListAnnotationsRequest handles checks/list-annotations operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (s *Server) HandleChecksListAnnotationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksListAnnotations`,
		trace.WithAttributes(otelogen.OperationID(`checks/list-annotations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksListAnnotationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksListAnnotations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksListForRefRequest handles checks/list-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (s *Server) HandleChecksListForRefRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksListForRef`,
		trace.WithAttributes(otelogen.OperationID(`checks/list-for-ref`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksListForRefParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksListForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksListForSuiteRequest handles checks/list-for-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (s *Server) HandleChecksListForSuiteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksListForSuite`,
		trace.WithAttributes(otelogen.OperationID(`checks/list-for-suite`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksListForSuiteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksListForSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksListSuitesForRefRequest handles checks/list-suites-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (s *Server) HandleChecksListSuitesForRefRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksListSuitesForRef`,
		trace.WithAttributes(otelogen.OperationID(`checks/list-suites-for-ref`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksListSuitesForRefParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksListSuitesForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksRerequestSuiteRequest handles checks/rerequest-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (s *Server) HandleChecksRerequestSuiteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksRerequestSuite`,
		trace.WithAttributes(otelogen.OperationID(`checks/rerequest-suite`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksRerequestSuiteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksRerequestSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleChecksSetSuitesPreferencesRequest handles checks/set-suites-preferences operation.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (s *Server) HandleChecksSetSuitesPreferencesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ChecksSetSuitesPreferences`,
		trace.WithAttributes(otelogen.OperationID(`checks/set-suites-preferences`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeChecksSetSuitesPreferencesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeChecksSetSuitesPreferencesRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ChecksSetSuitesPreferences(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningDeleteAnalysisRequest handles code-scanning/delete-analysis operation.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) HandleCodeScanningDeleteAnalysisRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningDeleteAnalysis`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/delete-analysis`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningDeleteAnalysisParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningDeleteAnalysis(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningGetAlertRequest handles code-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) HandleCodeScanningGetAlertRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningGetAlert`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/get-alert`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningGetAlertParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningGetAlert(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningGetAnalysisRequest handles code-scanning/get-analysis operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) HandleCodeScanningGetAnalysisRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningGetAnalysis`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/get-analysis`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningGetAnalysisParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningGetAnalysis(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningGetSarifRequest handles code-scanning/get-sarif operation.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (s *Server) HandleCodeScanningGetSarifRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningGetSarif`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/get-sarif`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningGetSarifParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningGetSarif(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningListAlertInstancesRequest handles code-scanning/list-alert-instances operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (s *Server) HandleCodeScanningListAlertInstancesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningListAlertInstances`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/list-alert-instances`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningListAlertInstancesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningListAlertInstances(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningListAlertsForRepoRequest handles code-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (s *Server) HandleCodeScanningListAlertsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningListAlertsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/list-alerts-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningListAlertsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningListAlertsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningListRecentAnalysesRequest handles code-scanning/list-recent-analyses operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (s *Server) HandleCodeScanningListRecentAnalysesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningListRecentAnalyses`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/list-recent-analyses`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningListRecentAnalysesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningListRecentAnalyses(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningUpdateAlertRequest handles code-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) HandleCodeScanningUpdateAlertRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningUpdateAlert`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/update-alert`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningUpdateAlertParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeCodeScanningUpdateAlertRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningUpdateAlert(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodeScanningUploadSarifRequest handles code-scanning/upload-sarif operation.
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (s *Server) HandleCodeScanningUploadSarifRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodeScanningUploadSarif`,
		trace.WithAttributes(otelogen.OperationID(`code-scanning/upload-sarif`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodeScanningUploadSarifParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeCodeScanningUploadSarifRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodeScanningUploadSarif(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodesOfConductGetAllCodesOfConductRequest handles codes-of-conduct/get-all-codes-of-conduct operation.
//
// GET /codes_of_conduct
func (s *Server) HandleCodesOfConductGetAllCodesOfConductRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodesOfConductGetAllCodesOfConduct`,
		trace.WithAttributes(otelogen.OperationID(`codes-of-conduct/get-all-codes-of-conduct`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.CodesOfConductGetAllCodesOfConduct(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleCodesOfConductGetConductCodeRequest handles codes-of-conduct/get-conduct-code operation.
//
// GET /codes_of_conduct/{key}
func (s *Server) HandleCodesOfConductGetConductCodeRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `CodesOfConductGetConductCode`,
		trace.WithAttributes(otelogen.OperationID(`codes-of-conduct/get-conduct-code`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeCodesOfConductGetConductCodeParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.CodesOfConductGetConductCode(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEmojisGetRequest handles emojis/get operation.
//
// GET /emojis
func (s *Server) HandleEmojisGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EmojisGet`,
		trace.WithAttributes(otelogen.OperationID(`emojis/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.EmojisGet(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEmojisGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) HandleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest handles enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) HandleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/add-self-hosted-runner-to-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest handles enterprise-admin/create-registration-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (s *Server) HandleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateRegistrationTokenForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-registration-token-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest handles enterprise-admin/create-remove-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (s *Server) HandleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateRemoveTokenForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-remove-token-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (s *Server) HandleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/create-self-hosted-runner-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest handles enterprise-admin/delete-scim-group-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) HandleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteScimGroupFromEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-scim-group-from-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) HandleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-self-hosted-runner-from-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-self-hosted-runner-group-from-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminDeleteUserFromEnterpriseRequest handles enterprise-admin/delete-user-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) HandleEnterpriseAdminDeleteUserFromEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminDeleteUserFromEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/delete-user-from-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) HandleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/disable-selected-organization-github-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) HandleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/enable-selected-organization-github-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetAllowedActionsEnterpriseRequest handles enterprise-admin/get-allowed-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) HandleEnterpriseAdminGetAllowedActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetAllowedActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-allowed-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetAuditLogRequest handles enterprise-admin/get-audit-log operation.
//
// GET /enterprises/{enterprise}/audit-log
func (s *Server) HandleEnterpriseAdminGetAuditLogRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetAuditLog`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-audit-log`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetAuditLogParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetAuditLog(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions
func (s *Server) HandleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetGithubActionsPermissionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-github-actions-permissions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest handles enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) HandleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetProvisioningInformationForEnterpriseGroup`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-provisioning-information-for-enterprise-group`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest handles enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) HandleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetProvisioningInformationForEnterpriseUser`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-provisioning-information-for-enterprise-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) HandleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetSelfHostedRunnerForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-self-hosted-runner-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/get-self-hosted-runner-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) HandleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListProvisionedGroupsEnterpriseRequest handles enterprise-admin/list-provisioned-groups-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) HandleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListProvisionedGroupsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-provisioned-groups-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest handles enterprise-admin/list-provisioned-identities-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (s *Server) HandleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListProvisionedIdentitiesEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-provisioned-identities-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest handles enterprise-admin/list-runner-applications-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (s *Server) HandleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListRunnerApplicationsForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-runner-applications-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) HandleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest handles enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (s *Server) HandleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runner-groups-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners
func (s *Server) HandleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnersForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runners-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) HandleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/list-self-hosted-runners-in-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest handles enterprise-admin/provision-and-invite-enterprise-group operation.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) HandleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminProvisionAndInviteEnterpriseGroup`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/provision-and-invite-enterprise-group`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest handles enterprise-admin/provision-and-invite-enterprise-user operation.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (s *Server) HandleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminProvisionAndInviteEnterpriseUser`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/provision-and-invite-enterprise-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) HandleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest handles enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) HandleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetAllowedActionsEnterpriseRequest handles enterprise-admin/set-allowed-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) HandleEnterpriseAdminSetAllowedActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetAllowedActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-allowed-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (s *Server) HandleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetGithubActionsPermissionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-github-actions-permissions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest handles enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) HandleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetInformationForProvisionedEnterpriseGroup`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-information-for-provisioned-enterprise-group`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest handles enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) HandleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetInformationForProvisionedEnterpriseUser`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-information-for-provisioned-enterprise-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) HandleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) HandleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) HandleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/set-self-hosted-runners-in-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest handles enterprise-admin/update-attribute-for-enterprise-user operation.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) HandleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminUpdateAttributeForEnterpriseUser`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/update-attribute-for-enterprise-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) HandleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise`,
		trace.WithAttributes(otelogen.OperationID(`enterprise-admin/update-self-hosted-runner-group-for-enterprise`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsCheckIsStarredRequest handles gists/check-is-starred operation.
//
// GET /gists/{gist_id}/star
func (s *Server) HandleGistsCheckIsStarredRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsCheckIsStarred`,
		trace.WithAttributes(otelogen.OperationID(`gists/check-is-starred`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsCheckIsStarredParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsCheckIsStarred(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsCreateCommentRequest handles gists/create-comment operation.
//
// POST /gists/{gist_id}/comments
func (s *Server) HandleGistsCreateCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsCreateComment`,
		trace.WithAttributes(otelogen.OperationID(`gists/create-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsCreateCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeGistsCreateCommentRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsCreateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsDeleteRequest handles gists/delete operation.
//
// DELETE /gists/{gist_id}
func (s *Server) HandleGistsDeleteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsDelete`,
		trace.WithAttributes(otelogen.OperationID(`gists/delete`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsDeleteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsDeleteCommentRequest handles gists/delete-comment operation.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (s *Server) HandleGistsDeleteCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsDeleteComment`,
		trace.WithAttributes(otelogen.OperationID(`gists/delete-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsDeleteCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsDeleteComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsGetRequest handles gists/get operation.
//
// GET /gists/{gist_id}
func (s *Server) HandleGistsGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsGet`,
		trace.WithAttributes(otelogen.OperationID(`gists/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsGetCommentRequest handles gists/get-comment operation.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (s *Server) HandleGistsGetCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsGetComment`,
		trace.WithAttributes(otelogen.OperationID(`gists/get-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsGetCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsGetComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsListRequest handles gists/list operation.
//
// GET /gists
func (s *Server) HandleGistsListRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsList`,
		trace.WithAttributes(otelogen.OperationID(`gists/list`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsListParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsListCommentsRequest handles gists/list-comments operation.
//
// GET /gists/{gist_id}/comments
func (s *Server) HandleGistsListCommentsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsListComments`,
		trace.WithAttributes(otelogen.OperationID(`gists/list-comments`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsListCommentsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsListComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsListCommitsRequest handles gists/list-commits operation.
//
// GET /gists/{gist_id}/commits
func (s *Server) HandleGistsListCommitsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsListCommits`,
		trace.WithAttributes(otelogen.OperationID(`gists/list-commits`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsListCommitsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsListForksRequest handles gists/list-forks operation.
//
// GET /gists/{gist_id}/forks
func (s *Server) HandleGistsListForksRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsListForks`,
		trace.WithAttributes(otelogen.OperationID(`gists/list-forks`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsListForksParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsListForks(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListForksResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsListStarredRequest handles gists/list-starred operation.
//
// GET /gists/starred
func (s *Server) HandleGistsListStarredRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsListStarred`,
		trace.WithAttributes(otelogen.OperationID(`gists/list-starred`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsListStarredParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsListStarred(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListStarredResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsStarRequest handles gists/star operation.
//
// PUT /gists/{gist_id}/star
func (s *Server) HandleGistsStarRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsStar`,
		trace.WithAttributes(otelogen.OperationID(`gists/star`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsStarParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsStar(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsStarResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsUnstarRequest handles gists/unstar operation.
//
// DELETE /gists/{gist_id}/star
func (s *Server) HandleGistsUnstarRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsUnstar`,
		trace.WithAttributes(otelogen.OperationID(`gists/unstar`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsUnstarParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsUnstar(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsUnstarResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGistsUpdateCommentRequest handles gists/update-comment operation.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (s *Server) HandleGistsUpdateCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GistsUpdateComment`,
		trace.WithAttributes(otelogen.OperationID(`gists/update-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGistsUpdateCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeGistsUpdateCommentRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GistsUpdateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitGetCommitRequest handles git/get-commit operation.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (s *Server) HandleGitGetCommitRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitGetCommit`,
		trace.WithAttributes(otelogen.OperationID(`git/get-commit`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGitGetCommitParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GitGetCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitGetRefRequest handles git/get-ref operation.
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (s *Server) HandleGitGetRefRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitGetRef`,
		trace.WithAttributes(otelogen.OperationID(`git/get-ref`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGitGetRefParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GitGetRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitGetTagRequest handles git/get-tag operation.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (s *Server) HandleGitGetTagRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitGetTag`,
		trace.WithAttributes(otelogen.OperationID(`git/get-tag`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGitGetTagParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GitGetTag(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetTagResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitListMatchingRefsRequest handles git/list-matching-refs operation.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (s *Server) HandleGitListMatchingRefsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitListMatchingRefs`,
		trace.WithAttributes(otelogen.OperationID(`git/list-matching-refs`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGitListMatchingRefsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GitListMatchingRefs(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitignoreGetAllTemplatesRequest handles gitignore/get-all-templates operation.
//
// GET /gitignore/templates
func (s *Server) HandleGitignoreGetAllTemplatesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitignoreGetAllTemplates`,
		trace.WithAttributes(otelogen.OperationID(`gitignore/get-all-templates`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.GitignoreGetAllTemplates(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleGitignoreGetTemplateRequest handles gitignore/get-template operation.
//
// GET /gitignore/templates/{name}
func (s *Server) HandleGitignoreGetTemplateRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `GitignoreGetTemplate`,
		trace.WithAttributes(otelogen.OperationID(`gitignore/get-template`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeGitignoreGetTemplateParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.GitignoreGetTemplate(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleInteractionsRemoveRestrictionsForAuthenticatedUserRequest handles interactions/remove-restrictions-for-authenticated-user operation.
//
// DELETE /user/interaction-limits
func (s *Server) HandleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleInteractionsRemoveRestrictionsForOrgRequest handles interactions/remove-restrictions-for-org operation.
//
// DELETE /orgs/{org}/interaction-limits
func (s *Server) HandleInteractionsRemoveRestrictionsForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForOrg`,
		trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeInteractionsRemoveRestrictionsForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleInteractionsRemoveRestrictionsForRepoRequest handles interactions/remove-restrictions-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (s *Server) HandleInteractionsRemoveRestrictionsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `InteractionsRemoveRestrictionsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`interactions/remove-restrictions-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeInteractionsRemoveRestrictionsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleInteractionsSetRestrictionsForRepoRequest handles interactions/set-restrictions-for-repo operation.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (s *Server) HandleInteractionsSetRestrictionsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `InteractionsSetRestrictionsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`interactions/set-restrictions-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeInteractionsSetRestrictionsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeInteractionsSetRestrictionsForRepoRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesAddAssigneesRequest handles issues/add-assignees operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) HandleIssuesAddAssigneesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesAddAssignees`,
		trace.WithAttributes(otelogen.OperationID(`issues/add-assignees`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesAddAssigneesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeIssuesAddAssigneesRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesAddAssignees(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesCheckUserCanBeAssignedRequest handles issues/check-user-can-be-assigned operation.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (s *Server) HandleIssuesCheckUserCanBeAssignedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesCheckUserCanBeAssigned`,
		trace.WithAttributes(otelogen.OperationID(`issues/check-user-can-be-assigned`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesCheckUserCanBeAssignedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesCheckUserCanBeAssigned(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesDeleteCommentRequest handles issues/delete-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) HandleIssuesDeleteCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesDeleteComment`,
		trace.WithAttributes(otelogen.OperationID(`issues/delete-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesDeleteCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesDeleteComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesDeleteLabelRequest handles issues/delete-label operation.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (s *Server) HandleIssuesDeleteLabelRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesDeleteLabel`,
		trace.WithAttributes(otelogen.OperationID(`issues/delete-label`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesDeleteLabelParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesDeleteLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesDeleteMilestoneRequest handles issues/delete-milestone operation.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) HandleIssuesDeleteMilestoneRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesDeleteMilestone`,
		trace.WithAttributes(otelogen.OperationID(`issues/delete-milestone`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesDeleteMilestoneParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesDeleteMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesGetCommentRequest handles issues/get-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) HandleIssuesGetCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesGetComment`,
		trace.WithAttributes(otelogen.OperationID(`issues/get-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesGetCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesGetComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesGetEventRequest handles issues/get-event operation.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (s *Server) HandleIssuesGetEventRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesGetEvent`,
		trace.WithAttributes(otelogen.OperationID(`issues/get-event`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesGetEventParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesGetEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesGetLabelRequest handles issues/get-label operation.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (s *Server) HandleIssuesGetLabelRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesGetLabel`,
		trace.WithAttributes(otelogen.OperationID(`issues/get-label`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesGetLabelParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesGetLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesGetMilestoneRequest handles issues/get-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) HandleIssuesGetMilestoneRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesGetMilestone`,
		trace.WithAttributes(otelogen.OperationID(`issues/get-milestone`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesGetMilestoneParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesGetMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListAssigneesRequest handles issues/list-assignees operation.
//
// GET /repos/{owner}/{repo}/assignees
func (s *Server) HandleIssuesListAssigneesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListAssignees`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-assignees`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListAssigneesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListAssignees(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListCommentsRequest handles issues/list-comments operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) HandleIssuesListCommentsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListComments`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-comments`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListCommentsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListLabelsForMilestoneRequest handles issues/list-labels-for-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (s *Server) HandleIssuesListLabelsForMilestoneRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListLabelsForMilestone`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-labels-for-milestone`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListLabelsForMilestoneParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListLabelsForMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListLabelsForRepoRequest handles issues/list-labels-for-repo operation.
//
// GET /repos/{owner}/{repo}/labels
func (s *Server) HandleIssuesListLabelsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListLabelsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-labels-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListLabelsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListLabelsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListLabelsOnIssueRequest handles issues/list-labels-on-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) HandleIssuesListLabelsOnIssueRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListLabelsOnIssue`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-labels-on-issue`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListLabelsOnIssueParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListLabelsOnIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesListMilestonesRequest handles issues/list-milestones operation.
//
// GET /repos/{owner}/{repo}/milestones
func (s *Server) HandleIssuesListMilestonesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesListMilestones`,
		trace.WithAttributes(otelogen.OperationID(`issues/list-milestones`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesListMilestonesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesListMilestones(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesRemoveAllLabelsRequest handles issues/remove-all-labels operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) HandleIssuesRemoveAllLabelsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesRemoveAllLabels`,
		trace.WithAttributes(otelogen.OperationID(`issues/remove-all-labels`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesRemoveAllLabelsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesRemoveAllLabels(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesRemoveAssigneesRequest handles issues/remove-assignees operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) HandleIssuesRemoveAssigneesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesRemoveAssignees`,
		trace.WithAttributes(otelogen.OperationID(`issues/remove-assignees`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesRemoveAssigneesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeIssuesRemoveAssigneesRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesRemoveAssignees(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesRemoveLabelRequest handles issues/remove-label operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (s *Server) HandleIssuesRemoveLabelRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesRemoveLabel`,
		trace.WithAttributes(otelogen.OperationID(`issues/remove-label`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesRemoveLabelParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesRemoveLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesUnlockRequest handles issues/unlock operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) HandleIssuesUnlockRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesUnlock`,
		trace.WithAttributes(otelogen.OperationID(`issues/unlock`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesUnlockParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesUnlock(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesUpdateLabelRequest handles issues/update-label operation.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (s *Server) HandleIssuesUpdateLabelRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesUpdateLabel`,
		trace.WithAttributes(otelogen.OperationID(`issues/update-label`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesUpdateLabelParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeIssuesUpdateLabelRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesUpdateLabel(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleIssuesUpdateMilestoneRequest handles issues/update-milestone operation.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) HandleIssuesUpdateMilestoneRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `IssuesUpdateMilestone`,
		trace.WithAttributes(otelogen.OperationID(`issues/update-milestone`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeIssuesUpdateMilestoneParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeIssuesUpdateMilestoneRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.IssuesUpdateMilestone(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleLicensesGetRequest handles licenses/get operation.
//
// GET /licenses/{license}
func (s *Server) HandleLicensesGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `LicensesGet`,
		trace.WithAttributes(otelogen.OperationID(`licenses/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeLicensesGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.LicensesGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleLicensesGetAllCommonlyUsedRequest handles licenses/get-all-commonly-used operation.
//
// GET /licenses
func (s *Server) HandleLicensesGetAllCommonlyUsedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `LicensesGetAllCommonlyUsed`,
		trace.WithAttributes(otelogen.OperationID(`licenses/get-all-commonly-used`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeLicensesGetAllCommonlyUsedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.LicensesGetAllCommonlyUsed(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleLicensesGetForRepoRequest handles licenses/get-for-repo operation.
//
// GET /repos/{owner}/{repo}/license
func (s *Server) HandleLicensesGetForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `LicensesGetForRepo`,
		trace.WithAttributes(otelogen.OperationID(`licenses/get-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeLicensesGetForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.LicensesGetForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMetaGetRequest handles meta/get operation.
//
// GET /meta
func (s *Server) HandleMetaGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MetaGet`,
		trace.WithAttributes(otelogen.OperationID(`meta/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.MetaGet(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMetaGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMetaRootRequest handles meta/root operation.
//
// GET /
func (s *Server) HandleMetaRootRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MetaRoot`,
		trace.WithAttributes(otelogen.OperationID(`meta/root`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.MetaRoot(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMetaRootResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsCancelImportRequest handles migrations/cancel-import operation.
//
// DELETE /repos/{owner}/{repo}/import
func (s *Server) HandleMigrationsCancelImportRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsCancelImport`,
		trace.WithAttributes(otelogen.OperationID(`migrations/cancel-import`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsCancelImportParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsCancelImport(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsDeleteArchiveForAuthenticatedUserRequest handles migrations/delete-archive-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/archive
func (s *Server) HandleMigrationsDeleteArchiveForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsDeleteArchiveForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/delete-archive-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsDeleteArchiveForOrgRequest handles migrations/delete-archive-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) HandleMigrationsDeleteArchiveForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsDeleteArchiveForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/delete-archive-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsDeleteArchiveForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsDeleteArchiveForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsDownloadArchiveForOrgRequest handles migrations/download-archive-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) HandleMigrationsDownloadArchiveForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsDownloadArchiveForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/download-archive-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsDownloadArchiveForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsDownloadArchiveForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetArchiveForAuthenticatedUserRequest handles migrations/get-archive-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}/archive
func (s *Server) HandleMigrationsGetArchiveForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetArchiveForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-archive-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetCommitAuthorsRequest handles migrations/get-commit-authors operation.
//
// GET /repos/{owner}/{repo}/import/authors
func (s *Server) HandleMigrationsGetCommitAuthorsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetCommitAuthors`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-commit-authors`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetCommitAuthorsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetCommitAuthors(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetImportStatusRequest handles migrations/get-import-status operation.
//
// GET /repos/{owner}/{repo}/import
func (s *Server) HandleMigrationsGetImportStatusRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetImportStatus`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-import-status`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetImportStatusParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetImportStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetLargeFilesRequest handles migrations/get-large-files operation.
//
// GET /repos/{owner}/{repo}/import/large_files
func (s *Server) HandleMigrationsGetLargeFilesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetLargeFiles`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-large-files`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetLargeFilesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetLargeFiles(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetStatusForAuthenticatedUserRequest handles migrations/get-status-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}
func (s *Server) HandleMigrationsGetStatusForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetStatusForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-status-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsGetStatusForOrgRequest handles migrations/get-status-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}
func (s *Server) HandleMigrationsGetStatusForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsGetStatusForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/get-status-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsGetStatusForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsGetStatusForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsListForAuthenticatedUserRequest handles migrations/list-for-authenticated-user operation.
//
// GET /user/migrations
func (s *Server) HandleMigrationsListForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsListForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/list-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsListForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsListForOrgRequest handles migrations/list-for-org operation.
//
// GET /orgs/{org}/migrations
func (s *Server) HandleMigrationsListForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsListForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/list-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsListForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsListReposForOrgRequest handles migrations/list-repos-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (s *Server) HandleMigrationsListReposForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsListReposForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/list-repos-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsListReposForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsListReposForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsListReposForUserRequest handles migrations/list-repos-for-user operation.
//
// GET /user/migrations/{migration_id}/repositories
func (s *Server) HandleMigrationsListReposForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsListReposForUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/list-repos-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsListReposForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsListReposForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsUnlockRepoForAuthenticatedUserRequest handles migrations/unlock-repo-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) HandleMigrationsUnlockRepoForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsUnlockRepoForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`migrations/unlock-repo-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsUnlockRepoForOrgRequest handles migrations/unlock-repo-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) HandleMigrationsUnlockRepoForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsUnlockRepoForOrg`,
		trace.WithAttributes(otelogen.OperationID(`migrations/unlock-repo-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsUnlockRepoForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsUnlockRepoForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleMigrationsUpdateImportRequest handles migrations/update-import operation.
//
// PATCH /repos/{owner}/{repo}/import
func (s *Server) HandleMigrationsUpdateImportRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `MigrationsUpdateImport`,
		trace.WithAttributes(otelogen.OperationID(`migrations/update-import`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeMigrationsUpdateImportParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeMigrationsUpdateImportRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.MigrationsUpdateImport(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsDeleteAuthorizationRequest handles oauth-authorizations/delete-authorization operation.
//
// DELETE /authorizations/{authorization_id}
func (s *Server) HandleOAuthAuthorizationsDeleteAuthorizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsDeleteAuthorization`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/delete-authorization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsDeleteGrantRequest handles oauth-authorizations/delete-grant operation.
//
// DELETE /applications/grants/{grant_id}
func (s *Server) HandleOAuthAuthorizationsDeleteGrantRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsDeleteGrant`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/delete-grant`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsDeleteGrantParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsGetAuthorizationRequest handles oauth-authorizations/get-authorization operation.
//
// GET /authorizations/{authorization_id}
func (s *Server) HandleOAuthAuthorizationsGetAuthorizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsGetAuthorization`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/get-authorization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsGetAuthorizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsGetGrantRequest handles oauth-authorizations/get-grant operation.
//
// GET /applications/grants/{grant_id}
func (s *Server) HandleOAuthAuthorizationsGetGrantRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsGetGrant`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/get-grant`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsGetGrantParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetGrant(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsListAuthorizationsRequest handles oauth-authorizations/list-authorizations operation.
//
// GET /authorizations
func (s *Server) HandleOAuthAuthorizationsListAuthorizationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsListAuthorizations`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/list-authorizations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsListAuthorizationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOAuthAuthorizationsListGrantsRequest handles oauth-authorizations/list-grants operation.
//
// GET /applications/grants
func (s *Server) HandleOAuthAuthorizationsListGrantsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OAuthAuthorizationsListGrants`,
		trace.WithAttributes(otelogen.OperationID(`oauth-authorizations/list-grants`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOAuthAuthorizationsListGrantsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsListGrants(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsCheckBlockedUserRequest handles orgs/check-blocked-user operation.
//
// GET /orgs/{org}/blocks/{username}
func (s *Server) HandleOrgsCheckBlockedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsCheckBlockedUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/check-blocked-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsCheckBlockedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsCheckBlockedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsCheckMembershipForUserRequest handles orgs/check-membership-for-user operation.
//
// GET /orgs/{org}/members/{username}
func (s *Server) HandleOrgsCheckMembershipForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsCheckMembershipForUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/check-membership-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsCheckMembershipForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsCheckMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsCheckPublicMembershipForUserRequest handles orgs/check-public-membership-for-user operation.
//
// GET /orgs/{org}/public_members/{username}
func (s *Server) HandleOrgsCheckPublicMembershipForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsCheckPublicMembershipForUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/check-public-membership-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsCheckPublicMembershipForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsCheckPublicMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsConvertMemberToOutsideCollaboratorRequest handles orgs/convert-member-to-outside-collaborator operation.
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (s *Server) HandleOrgsConvertMemberToOutsideCollaboratorRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsConvertMemberToOutsideCollaborator`,
		trace.WithAttributes(otelogen.OperationID(`orgs/convert-member-to-outside-collaborator`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsDeleteWebhookRequest handles orgs/delete-webhook operation.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (s *Server) HandleOrgsDeleteWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsDeleteWebhook`,
		trace.WithAttributes(otelogen.OperationID(`orgs/delete-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsDeleteWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsDeleteWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetRequest handles orgs/get operation.
//
// GET /orgs/{org}
func (s *Server) HandleOrgsGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGet`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetAuditLogRequest handles orgs/get-audit-log operation.
//
// GET /orgs/{org}/audit-log
func (s *Server) HandleOrgsGetAuditLogRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGetAuditLog`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get-audit-log`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetAuditLogParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGetAuditLog(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetMembershipForAuthenticatedUserRequest handles orgs/get-membership-for-authenticated-user operation.
//
// GET /user/memberships/orgs/{org}
func (s *Server) HandleOrgsGetMembershipForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGetMembershipForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get-membership-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetMembershipForUserRequest handles orgs/get-membership-for-user operation.
//
// GET /orgs/{org}/memberships/{username}
func (s *Server) HandleOrgsGetMembershipForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGetMembershipForUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get-membership-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetMembershipForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGetMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetWebhookRequest handles orgs/get-webhook operation.
//
// GET /orgs/{org}/hooks/{hook_id}
func (s *Server) HandleOrgsGetWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGetWebhook`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGetWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsGetWebhookConfigForOrgRequest handles orgs/get-webhook-config-for-org operation.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (s *Server) HandleOrgsGetWebhookConfigForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsGetWebhookConfigForOrg`,
		trace.WithAttributes(otelogen.OperationID(`orgs/get-webhook-config-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsGetWebhookConfigForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsGetWebhookConfigForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListRequest handles orgs/list operation.
//
// GET /organizations
func (s *Server) HandleOrgsListRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsList`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListBlockedUsersRequest handles orgs/list-blocked-users operation.
//
// GET /orgs/{org}/blocks
func (s *Server) HandleOrgsListBlockedUsersRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListBlockedUsers`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-blocked-users`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListBlockedUsersParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListBlockedUsers(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListFailedInvitationsRequest handles orgs/list-failed-invitations operation.
//
// GET /orgs/{org}/failed_invitations
func (s *Server) HandleOrgsListFailedInvitationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListFailedInvitations`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-failed-invitations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListFailedInvitationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListFailedInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListForAuthenticatedUserRequest handles orgs/list-for-authenticated-user operation.
//
// GET /user/orgs
func (s *Server) HandleOrgsListForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListForUserRequest handles orgs/list-for-user operation.
//
// GET /users/{username}/orgs
func (s *Server) HandleOrgsListForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListForUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListInvitationTeamsRequest handles orgs/list-invitation-teams operation.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (s *Server) HandleOrgsListInvitationTeamsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListInvitationTeams`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-invitation-teams`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListInvitationTeamsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListInvitationTeams(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListOutsideCollaboratorsRequest handles orgs/list-outside-collaborators operation.
//
// GET /orgs/{org}/outside_collaborators
func (s *Server) HandleOrgsListOutsideCollaboratorsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListOutsideCollaborators`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-outside-collaborators`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListOutsideCollaboratorsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListOutsideCollaborators(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListPendingInvitationsRequest handles orgs/list-pending-invitations operation.
//
// GET /orgs/{org}/invitations
func (s *Server) HandleOrgsListPendingInvitationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListPendingInvitations`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-pending-invitations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListPendingInvitationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListPendingInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListPublicMembersRequest handles orgs/list-public-members operation.
//
// GET /orgs/{org}/public_members
func (s *Server) HandleOrgsListPublicMembersRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListPublicMembers`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-public-members`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListPublicMembersParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListPublicMembers(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListSamlSSOAuthorizationsRequest handles orgs/list-saml-sso-authorizations operation.
//
// GET /orgs/{org}/credential-authorizations
func (s *Server) HandleOrgsListSamlSSOAuthorizationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListSamlSSOAuthorizations`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-saml-sso-authorizations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListSamlSSOAuthorizationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListSamlSSOAuthorizations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsListWebhooksRequest handles orgs/list-webhooks operation.
//
// GET /orgs/{org}/hooks
func (s *Server) HandleOrgsListWebhooksRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsListWebhooks`,
		trace.WithAttributes(otelogen.OperationID(`orgs/list-webhooks`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsListWebhooksParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsListWebhooks(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsPingWebhookRequest handles orgs/ping-webhook operation.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (s *Server) HandleOrgsPingWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsPingWebhook`,
		trace.WithAttributes(otelogen.OperationID(`orgs/ping-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsPingWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsPingWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsRemoveMemberRequest handles orgs/remove-member operation.
//
// DELETE /orgs/{org}/members/{username}
func (s *Server) HandleOrgsRemoveMemberRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsRemoveMember`,
		trace.WithAttributes(otelogen.OperationID(`orgs/remove-member`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsRemoveMemberParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsRemoveMember(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsRemoveMembershipForUserRequest handles orgs/remove-membership-for-user operation.
//
// DELETE /orgs/{org}/memberships/{username}
func (s *Server) HandleOrgsRemoveMembershipForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsRemoveMembershipForUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/remove-membership-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsRemoveMembershipForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsRemoveMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsRemoveOutsideCollaboratorRequest handles orgs/remove-outside-collaborator operation.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (s *Server) HandleOrgsRemoveOutsideCollaboratorRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsRemoveOutsideCollaborator`,
		trace.WithAttributes(otelogen.OperationID(`orgs/remove-outside-collaborator`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsRemoveOutsideCollaboratorParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsRemoveOutsideCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsRemovePublicMembershipForAuthenticatedUserRequest handles orgs/remove-public-membership-for-authenticated-user operation.
//
// DELETE /orgs/{org}/public_members/{username}
func (s *Server) HandleOrgsRemovePublicMembershipForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsRemovePublicMembershipForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/remove-public-membership-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsRemoveSamlSSOAuthorizationRequest handles orgs/remove-saml-sso-authorization operation.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (s *Server) HandleOrgsRemoveSamlSSOAuthorizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsRemoveSamlSSOAuthorization`,
		trace.WithAttributes(otelogen.OperationID(`orgs/remove-saml-sso-authorization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsSetPublicMembershipForAuthenticatedUserRequest handles orgs/set-public-membership-for-authenticated-user operation.
//
// PUT /orgs/{org}/public_members/{username}
func (s *Server) HandleOrgsSetPublicMembershipForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsSetPublicMembershipForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/set-public-membership-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsUnblockUserRequest handles orgs/unblock-user operation.
//
// DELETE /orgs/{org}/blocks/{username}
func (s *Server) HandleOrgsUnblockUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsUnblockUser`,
		trace.WithAttributes(otelogen.OperationID(`orgs/unblock-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsUnblockUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsUnblockUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleOrgsUpdateWebhookConfigForOrgRequest handles orgs/update-webhook-config-for-org operation.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (s *Server) HandleOrgsUpdateWebhookConfigForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `OrgsUpdateWebhookConfigForOrg`,
		trace.WithAttributes(otelogen.OperationID(`orgs/update-webhook-config-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeOrgsUpdateWebhookConfigForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeOrgsUpdateWebhookConfigForOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageForAuthenticatedUserRequest handles packages/delete-package-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesDeletePackageForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageForOrgRequest handles packages/delete-package-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesDeletePackageForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForOrg`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageForUserRequest handles packages/delete-package-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesDeletePackageForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageVersionForAuthenticatedUserRequest handles packages/delete-package-version-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesDeletePackageVersionForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageVersionForOrgRequest handles packages/delete-package-version-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesDeletePackageVersionForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForOrg`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageVersionForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesDeletePackageVersionForUserRequest handles packages/delete-package-version-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesDeletePackageVersionForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesDeletePackageVersionForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/delete-package-version-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesDeletePackageVersionForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest handles packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (s *Server) HandlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest handles packages/get-all-package-versions-for-package-owned-by-org operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (s *Server) HandlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByOrg`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest handles packages/get-all-package-versions-for-package-owned-by-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (s *Server) HandlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetAllPackageVersionsForPackageOwnedByUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-all-package-versions-for-package-owned-by-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageForAuthenticatedUserRequest handles packages/get-package-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesGetPackageForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageForOrganizationRequest handles packages/get-package-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesGetPackageForOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageForOrganization`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageForOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageForUserRequest handles packages/get-package-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (s *Server) HandlePackagesGetPackageForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageVersionForAuthenticatedUserRequest handles packages/get-package-version-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesGetPackageVersionForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageVersionForOrganizationRequest handles packages/get-package-version-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesGetPackageVersionForOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForOrganization`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageVersionForOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesGetPackageVersionForUserRequest handles packages/get-package-version-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) HandlePackagesGetPackageVersionForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesGetPackageVersionForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/get-package-version-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesGetPackageVersionForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesListPackagesForAuthenticatedUserRequest handles packages/list-packages-for-authenticated-user operation.
//
// GET /user/packages
func (s *Server) HandlePackagesListPackagesForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesListPackagesForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesListPackagesForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesListPackagesForOrganizationRequest handles packages/list-packages-for-organization operation.
//
// GET /orgs/{org}/packages
func (s *Server) HandlePackagesListPackagesForOrganizationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesListPackagesForOrganization`,
		trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-organization`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesListPackagesForOrganizationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesListPackagesForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesListPackagesForUserRequest handles packages/list-packages-for-user operation.
//
// GET /users/{username}/packages
func (s *Server) HandlePackagesListPackagesForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesListPackagesForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/list-packages-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesListPackagesForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesListPackagesForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageForAuthenticatedUserRequest handles packages/restore-package-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (s *Server) HandlePackagesRestorePackageForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageForOrgRequest handles packages/restore-package-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (s *Server) HandlePackagesRestorePackageForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForOrg`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageForUserRequest handles packages/restore-package-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (s *Server) HandlePackagesRestorePackageForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageVersionForAuthenticatedUserRequest handles packages/restore-package-version-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) HandlePackagesRestorePackageVersionForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageVersionForOrgRequest handles packages/restore-package-version-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) HandlePackagesRestorePackageVersionForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForOrg`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageVersionForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePackagesRestorePackageVersionForUserRequest handles packages/restore-package-version-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) HandlePackagesRestorePackageVersionForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PackagesRestorePackageVersionForUser`,
		trace.WithAttributes(otelogen.OperationID(`packages/restore-package-version-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePackagesRestorePackageVersionForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsCreateColumnRequest handles projects/create-column operation.
//
// POST /projects/{project_id}/columns
func (s *Server) HandleProjectsCreateColumnRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsCreateColumn`,
		trace.WithAttributes(otelogen.OperationID(`projects/create-column`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsCreateColumnParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsCreateColumnRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsCreateColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsCreateForAuthenticatedUserRequest handles projects/create-for-authenticated-user operation.
//
// POST /user/projects
func (s *Server) HandleProjectsCreateForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsCreateForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`projects/create-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	request, err := decodeProjectsCreateForAuthenticatedUserRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsCreateForOrgRequest handles projects/create-for-org operation.
//
// POST /orgs/{org}/projects
func (s *Server) HandleProjectsCreateForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsCreateForOrg`,
		trace.WithAttributes(otelogen.OperationID(`projects/create-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsCreateForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsCreateForOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsCreateForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsCreateForRepoRequest handles projects/create-for-repo operation.
//
// POST /repos/{owner}/{repo}/projects
func (s *Server) HandleProjectsCreateForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsCreateForRepo`,
		trace.WithAttributes(otelogen.OperationID(`projects/create-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsCreateForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsCreateForRepoRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsCreateForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsDeleteRequest handles projects/delete operation.
//
// DELETE /projects/{project_id}
func (s *Server) HandleProjectsDeleteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsDelete`,
		trace.WithAttributes(otelogen.OperationID(`projects/delete`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsDeleteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsDeleteCardRequest handles projects/delete-card operation.
//
// DELETE /projects/columns/cards/{card_id}
func (s *Server) HandleProjectsDeleteCardRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsDeleteCard`,
		trace.WithAttributes(otelogen.OperationID(`projects/delete-card`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsDeleteCardParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsDeleteCard(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsDeleteColumnRequest handles projects/delete-column operation.
//
// DELETE /projects/columns/{column_id}
func (s *Server) HandleProjectsDeleteColumnRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsDeleteColumn`,
		trace.WithAttributes(otelogen.OperationID(`projects/delete-column`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsDeleteColumnParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsDeleteColumn(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsGetRequest handles projects/get operation.
//
// GET /projects/{project_id}
func (s *Server) HandleProjectsGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsGet`,
		trace.WithAttributes(otelogen.OperationID(`projects/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsGetCardRequest handles projects/get-card operation.
//
// GET /projects/columns/cards/{card_id}
func (s *Server) HandleProjectsGetCardRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsGetCard`,
		trace.WithAttributes(otelogen.OperationID(`projects/get-card`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsGetCardParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsGetCard(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsGetColumnRequest handles projects/get-column operation.
//
// GET /projects/columns/{column_id}
func (s *Server) HandleProjectsGetColumnRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsGetColumn`,
		trace.WithAttributes(otelogen.OperationID(`projects/get-column`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsGetColumnParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsGetColumn(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsListCardsRequest handles projects/list-cards operation.
//
// GET /projects/columns/{column_id}/cards
func (s *Server) HandleProjectsListCardsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsListCards`,
		trace.WithAttributes(otelogen.OperationID(`projects/list-cards`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsListCardsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsListCards(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsListColumnsRequest handles projects/list-columns operation.
//
// GET /projects/{project_id}/columns
func (s *Server) HandleProjectsListColumnsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsListColumns`,
		trace.WithAttributes(otelogen.OperationID(`projects/list-columns`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsListColumnsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsListColumns(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsListForOrgRequest handles projects/list-for-org operation.
//
// GET /orgs/{org}/projects
func (s *Server) HandleProjectsListForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsListForOrg`,
		trace.WithAttributes(otelogen.OperationID(`projects/list-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsListForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsListForRepoRequest handles projects/list-for-repo operation.
//
// GET /repos/{owner}/{repo}/projects
func (s *Server) HandleProjectsListForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsListForRepo`,
		trace.WithAttributes(otelogen.OperationID(`projects/list-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsListForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsListForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsMoveColumnRequest handles projects/move-column operation.
//
// POST /projects/columns/{column_id}/moves
func (s *Server) HandleProjectsMoveColumnRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsMoveColumn`,
		trace.WithAttributes(otelogen.OperationID(`projects/move-column`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsMoveColumnParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsMoveColumnRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsMoveColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsUpdateRequest handles projects/update operation.
//
// PATCH /projects/{project_id}
func (s *Server) HandleProjectsUpdateRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsUpdate`,
		trace.WithAttributes(otelogen.OperationID(`projects/update`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsUpdateParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsUpdateRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsUpdate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsUpdateCardRequest handles projects/update-card operation.
//
// PATCH /projects/columns/cards/{card_id}
func (s *Server) HandleProjectsUpdateCardRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsUpdateCard`,
		trace.WithAttributes(otelogen.OperationID(`projects/update-card`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsUpdateCardParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsUpdateCardRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsUpdateCard(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleProjectsUpdateColumnRequest handles projects/update-column operation.
//
// PATCH /projects/columns/{column_id}
func (s *Server) HandleProjectsUpdateColumnRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ProjectsUpdateColumn`,
		trace.WithAttributes(otelogen.OperationID(`projects/update-column`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeProjectsUpdateColumnParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeProjectsUpdateColumnRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ProjectsUpdateColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsCheckIfMergedRequest handles pulls/check-if-merged operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) HandlePullsCheckIfMergedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsCheckIfMerged`,
		trace.WithAttributes(otelogen.OperationID(`pulls/check-if-merged`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsCheckIfMergedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsCheckIfMerged(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsCreateReplyForReviewCommentRequest handles pulls/create-reply-for-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (s *Server) HandlePullsCreateReplyForReviewCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsCreateReplyForReviewComment`,
		trace.WithAttributes(otelogen.OperationID(`pulls/create-reply-for-review-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsCreateReplyForReviewCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsCreateReplyForReviewCommentRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsCreateReplyForReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsCreateReviewRequest handles pulls/create-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) HandlePullsCreateReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsCreateReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/create-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsCreateReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsCreateReviewRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsCreateReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsDeletePendingReviewRequest handles pulls/delete-pending-review operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) HandlePullsDeletePendingReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsDeletePendingReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/delete-pending-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsDeletePendingReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsDeletePendingReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsDeleteReviewCommentRequest handles pulls/delete-review-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) HandlePullsDeleteReviewCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsDeleteReviewComment`,
		trace.WithAttributes(otelogen.OperationID(`pulls/delete-review-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsDeleteReviewCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsDeleteReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsDismissReviewRequest handles pulls/dismiss-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (s *Server) HandlePullsDismissReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsDismissReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/dismiss-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsDismissReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsDismissReviewRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsDismissReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsGetRequest handles pulls/get operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) HandlePullsGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsGet`,
		trace.WithAttributes(otelogen.OperationID(`pulls/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsGetReviewRequest handles pulls/get-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) HandlePullsGetReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsGetReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/get-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsGetReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsGetReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsGetReviewCommentRequest handles pulls/get-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) HandlePullsGetReviewCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsGetReviewComment`,
		trace.WithAttributes(otelogen.OperationID(`pulls/get-review-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsGetReviewCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsGetReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListCommentsForReviewRequest handles pulls/list-comments-for-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (s *Server) HandlePullsListCommentsForReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListCommentsForReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-comments-for-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListCommentsForReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListCommentsForReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListCommitsRequest handles pulls/list-commits operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (s *Server) HandlePullsListCommitsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListCommits`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-commits`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListCommitsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListRequestedReviewersRequest handles pulls/list-requested-reviewers operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) HandlePullsListRequestedReviewersRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListRequestedReviewers`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-requested-reviewers`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListRequestedReviewersParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListRequestedReviewers(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListReviewCommentsRequest handles pulls/list-review-comments operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) HandlePullsListReviewCommentsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListReviewComments`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-review-comments`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListReviewCommentsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListReviewComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListReviewCommentsForRepoRequest handles pulls/list-review-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (s *Server) HandlePullsListReviewCommentsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListReviewCommentsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-review-comments-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListReviewCommentsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListReviewCommentsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsListReviewsRequest handles pulls/list-reviews operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) HandlePullsListReviewsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsListReviews`,
		trace.WithAttributes(otelogen.OperationID(`pulls/list-reviews`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsListReviewsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsListReviews(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsSubmitReviewRequest handles pulls/submit-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (s *Server) HandlePullsSubmitReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsSubmitReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/submit-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsSubmitReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsSubmitReviewRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsSubmitReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsUpdateReviewRequest handles pulls/update-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) HandlePullsUpdateReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsUpdateReview`,
		trace.WithAttributes(otelogen.OperationID(`pulls/update-review`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsUpdateReviewParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsUpdateReviewRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsUpdateReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandlePullsUpdateReviewCommentRequest handles pulls/update-review-comment operation.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) HandlePullsUpdateReviewCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `PullsUpdateReviewComment`,
		trace.WithAttributes(otelogen.OperationID(`pulls/update-review-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodePullsUpdateReviewCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodePullsUpdateReviewCommentRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.PullsUpdateReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleRateLimitGetRequest handles rate-limit/get operation.
//
// GET /rate_limit
func (s *Server) HandleRateLimitGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `RateLimitGet`,
		trace.WithAttributes(otelogen.OperationID(`rate-limit/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.RateLimitGet(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeRateLimitGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsCreateForTeamDiscussionCommentInOrgRequest handles reactions/create-for-team-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) HandleReactionsCreateForTeamDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsCreateForTeamDiscussionCommentLegacyRequest handles reactions/create-for-team-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) HandleReactionsCreateForTeamDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsCreateForTeamDiscussionInOrgRequest handles reactions/create-for-team-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) HandleReactionsCreateForTeamDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsCreateForTeamDiscussionLegacyRequest handles reactions/create-for-team-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) HandleReactionsCreateForTeamDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsCreateForTeamDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`reactions/create-for-team-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForCommitCommentRequest handles reactions/delete-for-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForCommitCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForCommitComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-commit-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForCommitCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForIssueRequest handles reactions/delete-for-issue operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForIssueRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForIssue`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-issue`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForIssueParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForIssueCommentRequest handles reactions/delete-for-issue-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForIssueCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForIssueComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-issue-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForIssueCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForIssueComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForPullRequestCommentRequest handles reactions/delete-for-pull-request-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForPullRequestCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForPullRequestComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-pull-request-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForPullRequestCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForPullRequestComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForTeamDiscussionRequest handles reactions/delete-for-team-discussion operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForTeamDiscussionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForTeamDiscussion`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-team-discussion`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForTeamDiscussionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteForTeamDiscussionCommentRequest handles reactions/delete-for-team-discussion-comment operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteForTeamDiscussionCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteForTeamDiscussionComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-for-team-discussion-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsDeleteLegacyRequest handles reactions/delete-legacy operation.
//
// DELETE /reactions/{reaction_id}
func (s *Server) HandleReactionsDeleteLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsDeleteLegacy`,
		trace.WithAttributes(otelogen.OperationID(`reactions/delete-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsDeleteLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsDeleteLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForCommitCommentRequest handles reactions/list-for-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) HandleReactionsListForCommitCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForCommitComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-commit-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForCommitCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForIssueRequest handles reactions/list-for-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) HandleReactionsListForIssueRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForIssue`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-issue`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForIssueParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForIssueCommentRequest handles reactions/list-for-issue-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) HandleReactionsListForIssueCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForIssueComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-issue-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForIssueCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForIssueComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForPullRequestReviewCommentRequest handles reactions/list-for-pull-request-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) HandleReactionsListForPullRequestReviewCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForPullRequestReviewComment`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-pull-request-review-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForPullRequestReviewCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForPullRequestReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForTeamDiscussionCommentInOrgRequest handles reactions/list-for-team-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) HandleReactionsListForTeamDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForTeamDiscussionCommentLegacyRequest handles reactions/list-for-team-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) HandleReactionsListForTeamDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForTeamDiscussionInOrgRequest handles reactions/list-for-team-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) HandleReactionsListForTeamDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForTeamDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReactionsListForTeamDiscussionLegacyRequest handles reactions/list-for-team-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) HandleReactionsListForTeamDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReactionsListForTeamDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`reactions/list-for-team-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReactionsListForTeamDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposAcceptInvitationRequest handles repos/accept-invitation operation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (s *Server) HandleReposAcceptInvitationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposAcceptInvitation`,
		trace.WithAttributes(otelogen.OperationID(`repos/accept-invitation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposAcceptInvitationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposAcceptInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCheckCollaboratorRequest handles repos/check-collaborator operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) HandleReposCheckCollaboratorRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCheckCollaborator`,
		trace.WithAttributes(otelogen.OperationID(`repos/check-collaborator`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCheckCollaboratorParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCheckCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCheckVulnerabilityAlertsRequest handles repos/check-vulnerability-alerts operation.
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) HandleReposCheckVulnerabilityAlertsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCheckVulnerabilityAlerts`,
		trace.WithAttributes(otelogen.OperationID(`repos/check-vulnerability-alerts`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCheckVulnerabilityAlertsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCheckVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCompareCommitsRequest handles repos/compare-commits operation.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (s *Server) HandleReposCompareCommitsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCompareCommits`,
		trace.WithAttributes(otelogen.OperationID(`repos/compare-commits`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCompareCommitsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCompareCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCreateCommitSignatureProtectionRequest handles repos/create-commit-signature-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) HandleReposCreateCommitSignatureProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCreateCommitSignatureProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/create-commit-signature-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCreateCommitSignatureProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCreateCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCreateCommitStatusRequest handles repos/create-commit-status operation.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (s *Server) HandleReposCreateCommitStatusRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCreateCommitStatus`,
		trace.WithAttributes(otelogen.OperationID(`repos/create-commit-status`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCreateCommitStatusParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposCreateCommitStatusRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCreateCommitStatus(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposCreateUsingTemplateRequest handles repos/create-using-template operation.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (s *Server) HandleReposCreateUsingTemplateRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposCreateUsingTemplate`,
		trace.WithAttributes(otelogen.OperationID(`repos/create-using-template`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposCreateUsingTemplateParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposCreateUsingTemplateRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposCreateUsingTemplate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeclineInvitationRequest handles repos/decline-invitation operation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (s *Server) HandleReposDeclineInvitationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeclineInvitation`,
		trace.WithAttributes(otelogen.OperationID(`repos/decline-invitation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeclineInvitationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeclineInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteRequest handles repos/delete operation.
//
// DELETE /repos/{owner}/{repo}
func (s *Server) HandleReposDeleteRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDelete`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteAccessRestrictionsRequest handles repos/delete-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) HandleReposDeleteAccessRestrictionsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteAccessRestrictions`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-access-restrictions`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteAccessRestrictionsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteAccessRestrictions(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteAdminBranchProtectionRequest handles repos/delete-admin-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) HandleReposDeleteAdminBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteAdminBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-admin-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteAdminBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteAnEnvironmentRequest handles repos/delete-an-environment operation.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (s *Server) HandleReposDeleteAnEnvironmentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteAnEnvironment`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-an-environment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteAnEnvironmentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteAnEnvironment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteAutolinkRequest handles repos/delete-autolink operation.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) HandleReposDeleteAutolinkRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteAutolink`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-autolink`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteAutolinkParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteAutolink(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteBranchProtectionRequest handles repos/delete-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) HandleReposDeleteBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteCommitCommentRequest handles repos/delete-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) HandleReposDeleteCommitCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteCommitComment`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-commit-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteCommitCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteCommitSignatureProtectionRequest handles repos/delete-commit-signature-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) HandleReposDeleteCommitSignatureProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteCommitSignatureProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-commit-signature-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteCommitSignatureProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteDeployKeyRequest handles repos/delete-deploy-key operation.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) HandleReposDeleteDeployKeyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteDeployKey`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-deploy-key`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteDeployKeyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteDeployKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteDeploymentRequest handles repos/delete-deployment operation.
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) HandleReposDeleteDeploymentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteDeployment`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-deployment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteDeploymentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteInvitationRequest handles repos/delete-invitation operation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) HandleReposDeleteInvitationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteInvitation`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-invitation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteInvitationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeletePullRequestReviewProtectionRequest handles repos/delete-pull-request-review-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) HandleReposDeletePullRequestReviewProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeletePullRequestReviewProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-pull-request-review-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeletePullRequestReviewProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeletePullRequestReviewProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteReleaseRequest handles repos/delete-release operation.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) HandleReposDeleteReleaseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteRelease`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-release`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteReleaseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteReleaseAssetRequest handles repos/delete-release-asset operation.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) HandleReposDeleteReleaseAssetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteReleaseAsset`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-release-asset`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteReleaseAssetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteReleaseAsset(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDeleteWebhookRequest handles repos/delete-webhook operation.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) HandleReposDeleteWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDeleteWebhook`,
		trace.WithAttributes(otelogen.OperationID(`repos/delete-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDeleteWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDeleteWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDisableAutomatedSecurityFixesRequest handles repos/disable-automated-security-fixes operation.
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) HandleReposDisableAutomatedSecurityFixesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDisableAutomatedSecurityFixes`,
		trace.WithAttributes(otelogen.OperationID(`repos/disable-automated-security-fixes`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDisableAutomatedSecurityFixesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDisableLfsForRepoRequest handles repos/disable-lfs-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/lfs
func (s *Server) HandleReposDisableLfsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDisableLfsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`repos/disable-lfs-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDisableLfsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDisableLfsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDisableVulnerabilityAlertsRequest handles repos/disable-vulnerability-alerts operation.
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) HandleReposDisableVulnerabilityAlertsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDisableVulnerabilityAlerts`,
		trace.WithAttributes(otelogen.OperationID(`repos/disable-vulnerability-alerts`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDisableVulnerabilityAlertsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDisableVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDownloadTarballArchiveRequest handles repos/download-tarball-archive operation.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (s *Server) HandleReposDownloadTarballArchiveRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDownloadTarballArchive`,
		trace.WithAttributes(otelogen.OperationID(`repos/download-tarball-archive`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDownloadTarballArchiveParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDownloadTarballArchive(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposDownloadZipballArchiveRequest handles repos/download-zipball-archive operation.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (s *Server) HandleReposDownloadZipballArchiveRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposDownloadZipballArchive`,
		trace.WithAttributes(otelogen.OperationID(`repos/download-zipball-archive`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposDownloadZipballArchiveParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposDownloadZipballArchive(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposEnableAutomatedSecurityFixesRequest handles repos/enable-automated-security-fixes operation.
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) HandleReposEnableAutomatedSecurityFixesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposEnableAutomatedSecurityFixes`,
		trace.WithAttributes(otelogen.OperationID(`repos/enable-automated-security-fixes`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposEnableAutomatedSecurityFixesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposEnableLfsForRepoRequest handles repos/enable-lfs-for-repo operation.
//
// PUT /repos/{owner}/{repo}/lfs
func (s *Server) HandleReposEnableLfsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposEnableLfsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`repos/enable-lfs-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposEnableLfsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposEnableLfsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposEnableVulnerabilityAlertsRequest handles repos/enable-vulnerability-alerts operation.
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) HandleReposEnableVulnerabilityAlertsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposEnableVulnerabilityAlerts`,
		trace.WithAttributes(otelogen.OperationID(`repos/enable-vulnerability-alerts`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposEnableVulnerabilityAlertsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposEnableVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetRequest handles repos/get operation.
//
// GET /repos/{owner}/{repo}
func (s *Server) HandleReposGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGet`,
		trace.WithAttributes(otelogen.OperationID(`repos/get`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAccessRestrictionsRequest handles repos/get-access-restrictions operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) HandleReposGetAccessRestrictionsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAccessRestrictions`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-access-restrictions`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAccessRestrictionsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAccessRestrictions(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAdminBranchProtectionRequest handles repos/get-admin-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) HandleReposGetAdminBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAdminBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-admin-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAdminBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAllStatusCheckContextsRequest handles repos/get-all-status-check-contexts operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) HandleReposGetAllStatusCheckContextsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAllStatusCheckContexts`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-all-status-check-contexts`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAllStatusCheckContextsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAllStatusCheckContexts(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAllTopicsRequest handles repos/get-all-topics operation.
//
// GET /repos/{owner}/{repo}/topics
func (s *Server) HandleReposGetAllTopicsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAllTopics`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-all-topics`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAllTopicsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAllTopics(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAppsWithAccessToProtectedBranchRequest handles repos/get-apps-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) HandleReposGetAppsWithAccessToProtectedBranchRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAppsWithAccessToProtectedBranch`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-apps-with-access-to-protected-branch`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetAutolinkRequest handles repos/get-autolink operation.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) HandleReposGetAutolinkRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetAutolink`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-autolink`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetAutolinkParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetAutolink(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetBranchRequest handles repos/get-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (s *Server) HandleReposGetBranchRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetBranch`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-branch`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetBranchParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetBranchProtectionRequest handles repos/get-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) HandleReposGetBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetClonesRequest handles repos/get-clones operation.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (s *Server) HandleReposGetClonesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetClones`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-clones`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetClonesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetClones(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetClonesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCodeFrequencyStatsRequest handles repos/get-code-frequency-stats operation.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (s *Server) HandleReposGetCodeFrequencyStatsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCodeFrequencyStats`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-code-frequency-stats`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCodeFrequencyStatsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCodeFrequencyStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCollaboratorPermissionLevelRequest handles repos/get-collaborator-permission-level operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (s *Server) HandleReposGetCollaboratorPermissionLevelRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCollaboratorPermissionLevel`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-collaborator-permission-level`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCollaboratorPermissionLevelParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCombinedStatusForRefRequest handles repos/get-combined-status-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (s *Server) HandleReposGetCombinedStatusForRefRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCombinedStatusForRef`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-combined-status-for-ref`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCombinedStatusForRefParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCombinedStatusForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCommitActivityStatsRequest handles repos/get-commit-activity-stats operation.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (s *Server) HandleReposGetCommitActivityStatsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCommitActivityStats`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-commit-activity-stats`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCommitActivityStatsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCommitActivityStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCommitCommentRequest handles repos/get-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) HandleReposGetCommitCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCommitComment`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-commit-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCommitCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCommitSignatureProtectionRequest handles repos/get-commit-signature-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) HandleReposGetCommitSignatureProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCommitSignatureProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-commit-signature-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCommitSignatureProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetCommunityProfileMetricsRequest handles repos/get-community-profile-metrics operation.
//
// GET /repos/{owner}/{repo}/community/profile
func (s *Server) HandleReposGetCommunityProfileMetricsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetCommunityProfileMetrics`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-community-profile-metrics`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetCommunityProfileMetricsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetCommunityProfileMetrics(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetContributorsStatsRequest handles repos/get-contributors-stats operation.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (s *Server) HandleReposGetContributorsStatsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetContributorsStats`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-contributors-stats`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetContributorsStatsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetContributorsStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetDeployKeyRequest handles repos/get-deploy-key operation.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) HandleReposGetDeployKeyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetDeployKey`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-deploy-key`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetDeployKeyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetDeployKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetDeploymentStatusRequest handles repos/get-deployment-status operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (s *Server) HandleReposGetDeploymentStatusRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetDeploymentStatus`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-deployment-status`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetDeploymentStatusParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetDeploymentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetLatestPagesBuildRequest handles repos/get-latest-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (s *Server) HandleReposGetLatestPagesBuildRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetLatestPagesBuild`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-latest-pages-build`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetLatestPagesBuildParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetLatestPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetLatestReleaseRequest handles repos/get-latest-release operation.
//
// GET /repos/{owner}/{repo}/releases/latest
func (s *Server) HandleReposGetLatestReleaseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetLatestRelease`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-latest-release`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetLatestReleaseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetLatestRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetPagesRequest handles repos/get-pages operation.
//
// GET /repos/{owner}/{repo}/pages
func (s *Server) HandleReposGetPagesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetPages`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-pages`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetPagesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetPages(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetPagesBuildRequest handles repos/get-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (s *Server) HandleReposGetPagesBuildRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetPagesBuild`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-pages-build`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetPagesBuildParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetPagesHealthCheckRequest handles repos/get-pages-health-check operation.
//
// GET /repos/{owner}/{repo}/pages/health
func (s *Server) HandleReposGetPagesHealthCheckRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetPagesHealthCheck`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-pages-health-check`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetPagesHealthCheckParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetPagesHealthCheck(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetParticipationStatsRequest handles repos/get-participation-stats operation.
//
// GET /repos/{owner}/{repo}/stats/participation
func (s *Server) HandleReposGetParticipationStatsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetParticipationStats`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-participation-stats`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetParticipationStatsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetParticipationStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetPullRequestReviewProtectionRequest handles repos/get-pull-request-review-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) HandleReposGetPullRequestReviewProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetPullRequestReviewProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-pull-request-review-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetPullRequestReviewProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetPullRequestReviewProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetPunchCardStatsRequest handles repos/get-punch-card-stats operation.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (s *Server) HandleReposGetPunchCardStatsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetPunchCardStats`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-punch-card-stats`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetPunchCardStatsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetPunchCardStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetReleaseRequest handles repos/get-release operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) HandleReposGetReleaseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetRelease`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-release`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetReleaseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetReleaseAssetRequest handles repos/get-release-asset operation.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) HandleReposGetReleaseAssetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetReleaseAsset`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-release-asset`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetReleaseAssetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetReleaseAsset(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetReleaseByTagRequest handles repos/get-release-by-tag operation.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (s *Server) HandleReposGetReleaseByTagRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetReleaseByTag`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-release-by-tag`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetReleaseByTagParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetReleaseByTag(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetStatusChecksProtectionRequest handles repos/get-status-checks-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) HandleReposGetStatusChecksProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetStatusChecksProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-status-checks-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetStatusChecksProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetStatusChecksProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetTeamsWithAccessToProtectedBranchRequest handles repos/get-teams-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) HandleReposGetTeamsWithAccessToProtectedBranchRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetTeamsWithAccessToProtectedBranch`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-teams-with-access-to-protected-branch`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetTopPathsRequest handles repos/get-top-paths operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (s *Server) HandleReposGetTopPathsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetTopPaths`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-top-paths`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetTopPathsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetTopPaths(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetTopReferrersRequest handles repos/get-top-referrers operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (s *Server) HandleReposGetTopReferrersRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetTopReferrers`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-top-referrers`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetTopReferrersParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetTopReferrers(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetUsersWithAccessToProtectedBranchRequest handles repos/get-users-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) HandleReposGetUsersWithAccessToProtectedBranchRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetUsersWithAccessToProtectedBranch`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-users-with-access-to-protected-branch`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetViewsRequest handles repos/get-views operation.
//
// GET /repos/{owner}/{repo}/traffic/views
func (s *Server) HandleReposGetViewsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetViews`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-views`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetViewsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetViews(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetViewsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetWebhookRequest handles repos/get-webhook operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) HandleReposGetWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetWebhook`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposGetWebhookConfigForRepoRequest handles repos/get-webhook-config-for-repo operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) HandleReposGetWebhookConfigForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposGetWebhookConfigForRepo`,
		trace.WithAttributes(otelogen.OperationID(`repos/get-webhook-config-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposGetWebhookConfigForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposGetWebhookConfigForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListAutolinksRequest handles repos/list-autolinks operation.
//
// GET /repos/{owner}/{repo}/autolinks
func (s *Server) HandleReposListAutolinksRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListAutolinks`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-autolinks`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListAutolinksParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListAutolinks(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListBranchesRequest handles repos/list-branches operation.
//
// GET /repos/{owner}/{repo}/branches
func (s *Server) HandleReposListBranchesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListBranches`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-branches`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListBranchesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListBranches(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListBranchesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListCollaboratorsRequest handles repos/list-collaborators operation.
//
// GET /repos/{owner}/{repo}/collaborators
func (s *Server) HandleReposListCollaboratorsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListCollaborators`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-collaborators`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListCollaboratorsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListCollaborators(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListCommentsForCommitRequest handles repos/list-comments-for-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) HandleReposListCommentsForCommitRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListCommentsForCommit`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-comments-for-commit`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListCommentsForCommitParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListCommentsForCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListCommitCommentsForRepoRequest handles repos/list-commit-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/comments
func (s *Server) HandleReposListCommitCommentsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListCommitCommentsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-commit-comments-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListCommitCommentsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListCommitCommentsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListCommitStatusesForRefRequest handles repos/list-commit-statuses-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (s *Server) HandleReposListCommitStatusesForRefRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListCommitStatusesForRef`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-commit-statuses-for-ref`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListCommitStatusesForRefParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListCommitStatusesForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListCommitsRequest handles repos/list-commits operation.
//
// GET /repos/{owner}/{repo}/commits
func (s *Server) HandleReposListCommitsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListCommits`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-commits`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListCommitsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListContributorsRequest handles repos/list-contributors operation.
//
// GET /repos/{owner}/{repo}/contributors
func (s *Server) HandleReposListContributorsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListContributors`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-contributors`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListContributorsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListContributors(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListContributorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListDeployKeysRequest handles repos/list-deploy-keys operation.
//
// GET /repos/{owner}/{repo}/keys
func (s *Server) HandleReposListDeployKeysRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListDeployKeys`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-deploy-keys`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListDeployKeysParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListDeployKeys(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListDeploymentStatusesRequest handles repos/list-deployment-statuses operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) HandleReposListDeploymentStatusesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListDeploymentStatuses`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-deployment-statuses`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListDeploymentStatusesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListDeploymentStatuses(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListForOrgRequest handles repos/list-for-org operation.
//
// GET /orgs/{org}/repos
func (s *Server) HandleReposListForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListForOrg`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListForUserRequest handles repos/list-for-user operation.
//
// GET /users/{username}/repos
func (s *Server) HandleReposListForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListForUser`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListForksRequest handles repos/list-forks operation.
//
// GET /repos/{owner}/{repo}/forks
func (s *Server) HandleReposListForksRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListForks`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-forks`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListForksParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListForks(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForksResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListInvitationsRequest handles repos/list-invitations operation.
//
// GET /repos/{owner}/{repo}/invitations
func (s *Server) HandleReposListInvitationsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListInvitations`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-invitations`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListInvitationsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListInvitationsForAuthenticatedUserRequest handles repos/list-invitations-for-authenticated-user operation.
//
// GET /user/repository_invitations
func (s *Server) HandleReposListInvitationsForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListInvitationsForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-invitations-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListInvitationsForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListLanguagesRequest handles repos/list-languages operation.
//
// GET /repos/{owner}/{repo}/languages
func (s *Server) HandleReposListLanguagesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListLanguages`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-languages`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListLanguagesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListLanguages(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListPagesBuildsRequest handles repos/list-pages-builds operation.
//
// GET /repos/{owner}/{repo}/pages/builds
func (s *Server) HandleReposListPagesBuildsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListPagesBuilds`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-pages-builds`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListPagesBuildsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListPagesBuilds(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListPullRequestsAssociatedWithCommitRequest handles repos/list-pull-requests-associated-with-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (s *Server) HandleReposListPullRequestsAssociatedWithCommitRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListPullRequestsAssociatedWithCommit`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-pull-requests-associated-with-commit`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListPullRequestsAssociatedWithCommitParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListReleaseAssetsRequest handles repos/list-release-assets operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) HandleReposListReleaseAssetsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListReleaseAssets`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-release-assets`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListReleaseAssetsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListReleaseAssets(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListReleasesRequest handles repos/list-releases operation.
//
// GET /repos/{owner}/{repo}/releases
func (s *Server) HandleReposListReleasesRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListReleases`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-releases`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListReleasesParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListReleases(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListReleasesResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListTagsRequest handles repos/list-tags operation.
//
// GET /repos/{owner}/{repo}/tags
func (s *Server) HandleReposListTagsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListTags`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-tags`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListTagsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListTags(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListTagsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListTeamsRequest handles repos/list-teams operation.
//
// GET /repos/{owner}/{repo}/teams
func (s *Server) HandleReposListTeamsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListTeams`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-teams`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListTeamsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListTeams(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListTeamsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposListWebhooksRequest handles repos/list-webhooks operation.
//
// GET /repos/{owner}/{repo}/hooks
func (s *Server) HandleReposListWebhooksRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposListWebhooks`,
		trace.WithAttributes(otelogen.OperationID(`repos/list-webhooks`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposListWebhooksParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposListWebhooks(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposMergeUpstreamRequest handles repos/merge-upstream operation.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (s *Server) HandleReposMergeUpstreamRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposMergeUpstream`,
		trace.WithAttributes(otelogen.OperationID(`repos/merge-upstream`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposMergeUpstreamParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposMergeUpstreamRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposMergeUpstream(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposPingWebhookRequest handles repos/ping-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (s *Server) HandleReposPingWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposPingWebhook`,
		trace.WithAttributes(otelogen.OperationID(`repos/ping-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposPingWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposPingWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposRemoveCollaboratorRequest handles repos/remove-collaborator operation.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) HandleReposRemoveCollaboratorRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposRemoveCollaborator`,
		trace.WithAttributes(otelogen.OperationID(`repos/remove-collaborator`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposRemoveCollaboratorParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposRemoveCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposRemoveStatusCheckProtectionRequest handles repos/remove-status-check-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) HandleReposRemoveStatusCheckProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposRemoveStatusCheckProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/remove-status-check-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposRemoveStatusCheckProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposRemoveStatusCheckProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposReplaceAllTopicsRequest handles repos/replace-all-topics operation.
//
// PUT /repos/{owner}/{repo}/topics
func (s *Server) HandleReposReplaceAllTopicsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposReplaceAllTopics`,
		trace.WithAttributes(otelogen.OperationID(`repos/replace-all-topics`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposReplaceAllTopicsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposReplaceAllTopicsRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposReplaceAllTopics(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposRequestPagesBuildRequest handles repos/request-pages-build operation.
//
// POST /repos/{owner}/{repo}/pages/builds
func (s *Server) HandleReposRequestPagesBuildRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposRequestPagesBuild`,
		trace.WithAttributes(otelogen.OperationID(`repos/request-pages-build`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposRequestPagesBuildParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposRequestPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposSetAdminBranchProtectionRequest handles repos/set-admin-branch-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) HandleReposSetAdminBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposSetAdminBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/set-admin-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposSetAdminBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposSetAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposTestPushWebhookRequest handles repos/test-push-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (s *Server) HandleReposTestPushWebhookRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposTestPushWebhook`,
		trace.WithAttributes(otelogen.OperationID(`repos/test-push-webhook`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposTestPushWebhookParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposTestPushWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposTransferRequest handles repos/transfer operation.
//
// POST /repos/{owner}/{repo}/transfer
func (s *Server) HandleReposTransferRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposTransfer`,
		trace.WithAttributes(otelogen.OperationID(`repos/transfer`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposTransferParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposTransferRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposTransfer(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposTransferResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateBranchProtectionRequest handles repos/update-branch-protection operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) HandleReposUpdateBranchProtectionRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateBranchProtection`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-branch-protection`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateBranchProtectionParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateBranchProtectionRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateBranchProtection(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateCommitCommentRequest handles repos/update-commit-comment operation.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) HandleReposUpdateCommitCommentRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateCommitComment`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-commit-comment`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateCommitCommentParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateCommitCommentRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateCommitComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateInvitationRequest handles repos/update-invitation operation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) HandleReposUpdateInvitationRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateInvitation`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-invitation`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateInvitationParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateInvitationRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateInvitation(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateReleaseRequest handles repos/update-release operation.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) HandleReposUpdateReleaseRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateRelease`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-release`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateReleaseParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateReleaseRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateRelease(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateReleaseAssetRequest handles repos/update-release-asset operation.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) HandleReposUpdateReleaseAssetRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateReleaseAsset`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-release-asset`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateReleaseAssetParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateReleaseAssetRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateReleaseAsset(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleReposUpdateWebhookConfigForRepoRequest handles repos/update-webhook-config-for-repo operation.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) HandleReposUpdateWebhookConfigForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ReposUpdateWebhookConfigForRepo`,
		trace.WithAttributes(otelogen.OperationID(`repos/update-webhook-config-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeReposUpdateWebhookConfigForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeReposUpdateWebhookConfigForRepoRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleScimDeleteUserFromOrgRequest handles scim/delete-user-from-org operation.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (s *Server) HandleScimDeleteUserFromOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `ScimDeleteUserFromOrg`,
		trace.WithAttributes(otelogen.OperationID(`scim/delete-user-from-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeScimDeleteUserFromOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.ScimDeleteUserFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSearchCommitsRequest handles search/commits operation.
//
// GET /search/commits
func (s *Server) HandleSearchCommitsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SearchCommits`,
		trace.WithAttributes(otelogen.OperationID(`search/commits`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSearchCommitsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SearchCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSearchTopicsRequest handles search/topics operation.
//
// GET /search/topics
func (s *Server) HandleSearchTopicsRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SearchTopics`,
		trace.WithAttributes(otelogen.OperationID(`search/topics`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSearchTopicsParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SearchTopics(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSecretScanningGetAlertRequest handles secret-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) HandleSecretScanningGetAlertRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SecretScanningGetAlert`,
		trace.WithAttributes(otelogen.OperationID(`secret-scanning/get-alert`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSecretScanningGetAlertParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SecretScanningGetAlert(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSecretScanningListAlertsForOrgRequest handles secret-scanning/list-alerts-for-org operation.
//
// GET /orgs/{org}/secret-scanning/alerts
func (s *Server) HandleSecretScanningListAlertsForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SecretScanningListAlertsForOrg`,
		trace.WithAttributes(otelogen.OperationID(`secret-scanning/list-alerts-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSecretScanningListAlertsForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SecretScanningListAlertsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSecretScanningListAlertsForRepoRequest handles secret-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (s *Server) HandleSecretScanningListAlertsForRepoRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SecretScanningListAlertsForRepo`,
		trace.WithAttributes(otelogen.OperationID(`secret-scanning/list-alerts-for-repo`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSecretScanningListAlertsForRepoParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SecretScanningListAlertsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleSecretScanningUpdateAlertRequest handles secret-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) HandleSecretScanningUpdateAlertRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `SecretScanningUpdateAlert`,
		trace.WithAttributes(otelogen.OperationID(`secret-scanning/update-alert`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeSecretScanningUpdateAlertParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeSecretScanningUpdateAlertRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.SecretScanningUpdateAlert(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsAddMemberLegacyRequest handles teams/add-member-legacy operation.
//
// PUT /teams/{team_id}/members/{username}
func (s *Server) HandleTeamsAddMemberLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsAddMemberLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/add-member-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsAddMemberLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsAddMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsAddOrUpdateMembershipForUserInOrgRequest handles teams/add-or-update-membership-for-user-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) HandleTeamsAddOrUpdateMembershipForUserInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateMembershipForUserInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-membership-for-user-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsAddOrUpdateMembershipForUserLegacyRequest handles teams/add-or-update-membership-for-user-legacy operation.
//
// PUT /teams/{team_id}/memberships/{username}
func (s *Server) HandleTeamsAddOrUpdateMembershipForUserLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateMembershipForUserLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-membership-for-user-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsAddOrUpdateProjectPermissionsInOrgRequest handles teams/add-or-update-project-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) HandleTeamsAddOrUpdateProjectPermissionsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateProjectPermissionsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-project-permissions-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsAddOrUpdateRepoPermissionsInOrgRequest handles teams/add-or-update-repo-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) HandleTeamsAddOrUpdateRepoPermissionsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsAddOrUpdateRepoPermissionsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/add-or-update-repo-permissions-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCheckPermissionsForProjectInOrgRequest handles teams/check-permissions-for-project-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) HandleTeamsCheckPermissionsForProjectInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForProjectInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-project-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCheckPermissionsForProjectLegacyRequest handles teams/check-permissions-for-project-legacy operation.
//
// GET /teams/{team_id}/projects/{project_id}
func (s *Server) HandleTeamsCheckPermissionsForProjectLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForProjectLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-project-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCheckPermissionsForRepoInOrgRequest handles teams/check-permissions-for-repo-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) HandleTeamsCheckPermissionsForRepoInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForRepoInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-repo-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCheckPermissionsForRepoLegacyRequest handles teams/check-permissions-for-repo-legacy operation.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) HandleTeamsCheckPermissionsForRepoLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCheckPermissionsForRepoLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/check-permissions-for-repo-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCreateDiscussionCommentInOrgRequest handles teams/create-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) HandleTeamsCreateDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCreateDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCreateDiscussionCommentLegacyRequest handles teams/create-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) HandleTeamsCreateDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCreateDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCreateDiscussionInOrgRequest handles teams/create-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) HandleTeamsCreateDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCreateDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCreateDiscussionLegacyRequest handles teams/create-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions
func (s *Server) HandleTeamsCreateDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCreateDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/create-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCreateDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest handles teams/create-or-update-idp-group-connections-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) HandleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsCreateOrUpdateIdpGroupConnectionsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/create-or-update-idp-group-connections-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsDeleteDiscussionCommentInOrgRequest handles teams/delete-discussion-comment-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsDeleteDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsDeleteDiscussionCommentLegacyRequest handles teams/delete-discussion-comment-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsDeleteDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsDeleteDiscussionInOrgRequest handles teams/delete-discussion-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) HandleTeamsDeleteDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsDeleteDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsDeleteDiscussionLegacyRequest handles teams/delete-discussion-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (s *Server) HandleTeamsDeleteDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsDeleteDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/delete-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsDeleteDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsDeleteInOrgRequest handles teams/delete-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (s *Server) HandleTeamsDeleteInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsDeleteInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/delete-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsDeleteInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsDeleteInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetByNameRequest handles teams/get-by-name operation.
//
// GET /orgs/{org}/teams/{team_slug}
func (s *Server) HandleTeamsGetByNameRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetByName`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-by-name`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetByNameParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetByName(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetDiscussionCommentInOrgRequest handles teams/get-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsGetDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetDiscussionCommentLegacyRequest handles teams/get-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsGetDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetDiscussionInOrgRequest handles teams/get-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) HandleTeamsGetDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetDiscussionLegacyRequest handles teams/get-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (s *Server) HandleTeamsGetDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetLegacyRequest handles teams/get-legacy operation.
//
// GET /teams/{team_id}
func (s *Server) HandleTeamsGetLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetMemberLegacyRequest handles teams/get-member-legacy operation.
//
// GET /teams/{team_id}/members/{username}
func (s *Server) HandleTeamsGetMemberLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetMemberLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-member-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetMemberLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetMembershipForUserInOrgRequest handles teams/get-membership-for-user-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) HandleTeamsGetMembershipForUserInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetMembershipForUserInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-membership-for-user-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetMembershipForUserInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetMembershipForUserInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsGetMembershipForUserLegacyRequest handles teams/get-membership-for-user-legacy operation.
//
// GET /teams/{team_id}/memberships/{username}
func (s *Server) HandleTeamsGetMembershipForUserLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsGetMembershipForUserLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/get-membership-for-user-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsGetMembershipForUserLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsGetMembershipForUserLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListRequest handles teams/list operation.
//
// GET /orgs/{org}/teams
func (s *Server) HandleTeamsListRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsList`,
		trace.WithAttributes(otelogen.OperationID(`teams/list`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListChildInOrgRequest handles teams/list-child-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (s *Server) HandleTeamsListChildInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListChildInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-child-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListChildInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListChildInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListDiscussionCommentsInOrgRequest handles teams/list-discussion-comments-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) HandleTeamsListDiscussionCommentsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListDiscussionCommentsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-discussion-comments-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListDiscussionCommentsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListDiscussionCommentsLegacyRequest handles teams/list-discussion-comments-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) HandleTeamsListDiscussionCommentsLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListDiscussionCommentsLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-discussion-comments-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListDiscussionCommentsLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListDiscussionsInOrgRequest handles teams/list-discussions-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) HandleTeamsListDiscussionsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListDiscussionsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-discussions-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListDiscussionsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListDiscussionsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListDiscussionsLegacyRequest handles teams/list-discussions-legacy operation.
//
// GET /teams/{team_id}/discussions
func (s *Server) HandleTeamsListDiscussionsLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListDiscussionsLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-discussions-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListDiscussionsLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListDiscussionsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListForAuthenticatedUserRequest handles teams/list-for-authenticated-user operation.
//
// GET /user/teams
func (s *Server) HandleTeamsListForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListIdpGroupsForLegacyRequest handles teams/list-idp-groups-for-legacy operation.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (s *Server) HandleTeamsListIdpGroupsForLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsForLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-for-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListIdpGroupsForLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsForLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListIdpGroupsForOrgRequest handles teams/list-idp-groups-for-org operation.
//
// GET /orgs/{org}/team-sync/groups
func (s *Server) HandleTeamsListIdpGroupsForOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsForOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-for-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListIdpGroupsForOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListIdpGroupsInOrgRequest handles teams/list-idp-groups-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) HandleTeamsListIdpGroupsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListIdpGroupsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-idp-groups-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListIdpGroupsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListMembersInOrgRequest handles teams/list-members-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (s *Server) HandleTeamsListMembersInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListMembersInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-members-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListMembersInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListMembersInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListMembersLegacyRequest handles teams/list-members-legacy operation.
//
// GET /teams/{team_id}/members
func (s *Server) HandleTeamsListMembersLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListMembersLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-members-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListMembersLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListMembersLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListPendingInvitationsInOrgRequest handles teams/list-pending-invitations-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (s *Server) HandleTeamsListPendingInvitationsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListPendingInvitationsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-pending-invitations-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListPendingInvitationsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListPendingInvitationsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListPendingInvitationsLegacyRequest handles teams/list-pending-invitations-legacy operation.
//
// GET /teams/{team_id}/invitations
func (s *Server) HandleTeamsListPendingInvitationsLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListPendingInvitationsLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-pending-invitations-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListPendingInvitationsLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListPendingInvitationsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListProjectsInOrgRequest handles teams/list-projects-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (s *Server) HandleTeamsListProjectsInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListProjectsInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-projects-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListProjectsInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListProjectsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListProjectsLegacyRequest handles teams/list-projects-legacy operation.
//
// GET /teams/{team_id}/projects
func (s *Server) HandleTeamsListProjectsLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListProjectsLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-projects-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListProjectsLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListProjectsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListReposInOrgRequest handles teams/list-repos-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (s *Server) HandleTeamsListReposInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListReposInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-repos-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListReposInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListReposInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsListReposLegacyRequest handles teams/list-repos-legacy operation.
//
// GET /teams/{team_id}/repos
func (s *Server) HandleTeamsListReposLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsListReposLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/list-repos-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsListReposLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsListReposLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveMemberLegacyRequest handles teams/remove-member-legacy operation.
//
// DELETE /teams/{team_id}/members/{username}
func (s *Server) HandleTeamsRemoveMemberLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveMemberLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-member-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveMemberLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveMembershipForUserInOrgRequest handles teams/remove-membership-for-user-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) HandleTeamsRemoveMembershipForUserInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveMembershipForUserInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-membership-for-user-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveMembershipForUserInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveMembershipForUserLegacyRequest handles teams/remove-membership-for-user-legacy operation.
//
// DELETE /teams/{team_id}/memberships/{username}
func (s *Server) HandleTeamsRemoveMembershipForUserLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveMembershipForUserLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-membership-for-user-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveMembershipForUserLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveProjectInOrgRequest handles teams/remove-project-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) HandleTeamsRemoveProjectInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveProjectInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-project-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveProjectInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveProjectInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveRepoInOrgRequest handles teams/remove-repo-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) HandleTeamsRemoveRepoInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveRepoInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-repo-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveRepoInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveRepoInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsRemoveRepoLegacyRequest handles teams/remove-repo-legacy operation.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) HandleTeamsRemoveRepoLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsRemoveRepoLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/remove-repo-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsRemoveRepoLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsRemoveRepoLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsUpdateDiscussionCommentInOrgRequest handles teams/update-discussion-comment-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsUpdateDiscussionCommentInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionCommentInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-comment-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsUpdateDiscussionCommentLegacyRequest handles teams/update-discussion-comment-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) HandleTeamsUpdateDiscussionCommentLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionCommentLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-comment-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsUpdateDiscussionInOrgRequest handles teams/update-discussion-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) HandleTeamsUpdateDiscussionInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsUpdateDiscussionInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsUpdateDiscussionLegacyRequest handles teams/update-discussion-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (s *Server) HandleTeamsUpdateDiscussionLegacyRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsUpdateDiscussionLegacy`,
		trace.WithAttributes(otelogen.OperationID(`teams/update-discussion-legacy`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsUpdateDiscussionLegacyParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionLegacyRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleTeamsUpdateInOrgRequest handles teams/update-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (s *Server) HandleTeamsUpdateInOrgRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `TeamsUpdateInOrg`,
		trace.WithAttributes(otelogen.OperationID(`teams/update-in-org`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeTeamsUpdateInOrgParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}
	request, err := decodeTeamsUpdateInOrgRequest(r, span)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.TeamsUpdateInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersCheckBlockedRequest handles users/check-blocked operation.
//
// GET /user/blocks/{username}
func (s *Server) HandleUsersCheckBlockedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersCheckBlocked`,
		trace.WithAttributes(otelogen.OperationID(`users/check-blocked`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersCheckBlockedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersCheckBlocked(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersCheckFollowingForUserRequest handles users/check-following-for-user operation.
//
// GET /users/{username}/following/{target_user}
func (s *Server) HandleUsersCheckFollowingForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersCheckFollowingForUser`,
		trace.WithAttributes(otelogen.OperationID(`users/check-following-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersCheckFollowingForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersCheckFollowingForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersCheckPersonIsFollowedByAuthenticatedRequest handles users/check-person-is-followed-by-authenticated operation.
//
// GET /user/following/{username}
func (s *Server) HandleUsersCheckPersonIsFollowedByAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersCheckPersonIsFollowedByAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/check-person-is-followed-by-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersDeletePublicSSHKeyForAuthenticatedRequest handles users/delete-public-ssh-key-for-authenticated operation.
//
// DELETE /user/keys/{key_id}
func (s *Server) HandleUsersDeletePublicSSHKeyForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersDeletePublicSSHKeyForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/delete-public-ssh-key-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersFollowRequest handles users/follow operation.
//
// PUT /user/following/{username}
func (s *Server) HandleUsersFollowRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersFollow`,
		trace.WithAttributes(otelogen.OperationID(`users/follow`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersFollowParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersFollow(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersFollowResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersGetAuthenticatedRequest handles users/get-authenticated operation.
//
// GET /user
func (s *Server) HandleUsersGetAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersGetAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/get-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.UsersGetAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersGetByUsernameRequest handles users/get-by-username operation.
//
// GET /users/{username}
func (s *Server) HandleUsersGetByUsernameRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersGetByUsername`,
		trace.WithAttributes(otelogen.OperationID(`users/get-by-username`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersGetByUsernameParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersGetByUsername(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersGetGpgKeyForAuthenticatedRequest handles users/get-gpg-key-for-authenticated operation.
//
// GET /user/gpg_keys/{gpg_key_id}
func (s *Server) HandleUsersGetGpgKeyForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersGetGpgKeyForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/get-gpg-key-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersGetGpgKeyForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersGetPublicSSHKeyForAuthenticatedRequest handles users/get-public-ssh-key-for-authenticated operation.
//
// GET /user/keys/{key_id}
func (s *Server) HandleUsersGetPublicSSHKeyForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersGetPublicSSHKeyForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/get-public-ssh-key-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListRequest handles users/list operation.
//
// GET /users
func (s *Server) HandleUsersListRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersList`,
		trace.WithAttributes(otelogen.OperationID(`users/list`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersList(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListBlockedByAuthenticatedRequest handles users/list-blocked-by-authenticated operation.
//
// GET /user/blocks
func (s *Server) HandleUsersListBlockedByAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListBlockedByAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-blocked-by-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	response, err := s.h.UsersListBlockedByAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListEmailsForAuthenticatedRequest handles users/list-emails-for-authenticated operation.
//
// GET /user/emails
func (s *Server) HandleUsersListEmailsForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListEmailsForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-emails-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListEmailsForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListEmailsForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListFollowedByAuthenticatedRequest handles users/list-followed-by-authenticated operation.
//
// GET /user/following
func (s *Server) HandleUsersListFollowedByAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListFollowedByAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-followed-by-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListFollowedByAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListFollowedByAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListFollowersForAuthenticatedUserRequest handles users/list-followers-for-authenticated-user operation.
//
// GET /user/followers
func (s *Server) HandleUsersListFollowersForAuthenticatedUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListFollowersForAuthenticatedUser`,
		trace.WithAttributes(otelogen.OperationID(`users/list-followers-for-authenticated-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListFollowersForAuthenticatedUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListFollowersForUserRequest handles users/list-followers-for-user operation.
//
// GET /users/{username}/followers
func (s *Server) HandleUsersListFollowersForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListFollowersForUser`,
		trace.WithAttributes(otelogen.OperationID(`users/list-followers-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListFollowersForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListFollowersForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListFollowingForUserRequest handles users/list-following-for-user operation.
//
// GET /users/{username}/following
func (s *Server) HandleUsersListFollowingForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListFollowingForUser`,
		trace.WithAttributes(otelogen.OperationID(`users/list-following-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListFollowingForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListFollowingForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListGpgKeysForAuthenticatedRequest handles users/list-gpg-keys-for-authenticated operation.
//
// GET /user/gpg_keys
func (s *Server) HandleUsersListGpgKeysForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListGpgKeysForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-gpg-keys-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListGpgKeysForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListGpgKeysForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListGpgKeysForUserRequest handles users/list-gpg-keys-for-user operation.
//
// GET /users/{username}/gpg_keys
func (s *Server) HandleUsersListGpgKeysForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListGpgKeysForUser`,
		trace.WithAttributes(otelogen.OperationID(`users/list-gpg-keys-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListGpgKeysForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListGpgKeysForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListPublicEmailsForAuthenticatedRequest handles users/list-public-emails-for-authenticated operation.
//
// GET /user/public_emails
func (s *Server) HandleUsersListPublicEmailsForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListPublicEmailsForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-public-emails-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListPublicEmailsForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListPublicKeysForUserRequest handles users/list-public-keys-for-user operation.
//
// GET /users/{username}/keys
func (s *Server) HandleUsersListPublicKeysForUserRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListPublicKeysForUser`,
		trace.WithAttributes(otelogen.OperationID(`users/list-public-keys-for-user`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListPublicKeysForUserParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListPublicKeysForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersListPublicSSHKeysForAuthenticatedRequest handles users/list-public-ssh-keys-for-authenticated operation.
//
// GET /user/keys
func (s *Server) HandleUsersListPublicSSHKeysForAuthenticatedRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersListPublicSSHKeysForAuthenticated`,
		trace.WithAttributes(otelogen.OperationID(`users/list-public-ssh-keys-for-authenticated`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersListPublicSSHKeysForAuthenticatedParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersUnblockRequest handles users/unblock operation.
//
// DELETE /user/blocks/{username}
func (s *Server) HandleUsersUnblockRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersUnblock`,
		trace.WithAttributes(otelogen.OperationID(`users/unblock`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersUnblockParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersUnblock(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersUnblockResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

// HandleUsersUnfollowRequest handles users/unfollow operation.
//
// DELETE /user/following/{username}
func (s *Server) HandleUsersUnfollowRequest(w http.ResponseWriter, r *http.Request) {
	ctx, span := s.cfg.Tracer.Start(r.Context(), `UsersUnfollow`,
		trace.WithAttributes(otelogen.OperationID(`users/unfollow`)),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()
	params, err := decodeUsersUnfollowParams(r)
	if err != nil {
		span.RecordError(err)
		respondError(w, http.StatusBadRequest, err)
		return
	}

	response, err := s.h.UsersUnfollow(ctx, params)
	if err != nil {
		span.RecordError(err)
		s.respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
		span.RecordError(err)
		return
	}
}

func respondError(w http.ResponseWriter, code int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	data, writeErr := json.Marshal(struct {
		ErrorMessage string `json:"error_message"`
	}{
		ErrorMessage: err.Error(),
	})
	if writeErr == nil {
		w.Write(data)
	}
}
