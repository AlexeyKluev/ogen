// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"math"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = math.Mod
	_ = validate.Int{}
)

type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

type Client struct {
	serverURL string
	http      HTTPClient
}

func NewClient(serverURL string) *Client {
	return &Client{
		serverURL: serverURL,
		http: &http.Client{
			Timeout: time.Second * 15,
		},
	}
}

func (c *Client) MetaRoot(ctx context.Context) (res MetaRoot, err error) {
	path := c.serverURL
	path += "/"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMetaRootResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsGetAuthenticated(ctx context.Context) (res Integration, err error) {
	path := c.serverURL
	path += "/app"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (res AppsDeleteInstallationResponse, err error) {
	path := c.serverURL
	path += "/app/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (res AppsSuspendInstallationResponse, err error) {
	path := c.serverURL
	path += "/app/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}
	path += "/suspended"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsSuspendInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (res AppsUnsuspendInstallationResponse, err error) {
	path := c.serverURL
	path += "/app/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}
	path += "/suspended"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsUnsuspendInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (res OAuthAuthorizationsListGrantsResponse, err error) {
	path := c.serverURL
	path += "/applications/grants"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'client_id' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ClientID
		param := e.EncodeString(v)
		q.Set("client_id", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListGrantsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (res OAuthAuthorizationsGetGrantResponse, err error) {
	path := c.serverURL
	path += "/applications/grants/"
	{
		// Encode 'grant_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.GrantID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetGrantResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (res OAuthAuthorizationsDeleteGrantResponse, err error) {
	path := c.serverURL
	path += "/applications/grants/"
	{
		// Encode 'grant_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "grant_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.GrantID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteGrantResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (res AppsGetBySlugResponse, err error) {
	path := c.serverURL
	path += "/apps/"
	{
		// Encode 'app_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "app_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.AppSlug)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetBySlugResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (res OAuthAuthorizationsListAuthorizationsResponse, err error) {
	path := c.serverURL
	path += "/authorizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'client_id' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ClientID
		param := e.EncodeString(v)
		q.Set("client_id", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListAuthorizationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (res OAuthAuthorizationsGetAuthorizationResponse, err error) {
	path := c.serverURL
	path += "/authorizations/"
	{
		// Encode 'authorization_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AuthorizationID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetAuthorizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (res OAuthAuthorizationsDeleteAuthorizationResponse, err error) {
	path := c.serverURL
	path += "/authorizations/"
	{
		// Encode 'authorization_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "authorization_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AuthorizationID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteAuthorizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodesOfConductGetAllCodesOfConduct(ctx context.Context) (res CodesOfConductGetAllCodesOfConductResponse, err error) {
	path := c.serverURL
	path += "/codes_of_conduct"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetAllCodesOfConductResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (res CodesOfConductGetConductCodeResponse, err error) {
	path := c.serverURL
	path += "/codes_of_conduct/"
	{
		// Encode 'key' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Key)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetConductCodeResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EmojisGet(ctx context.Context) (res EmojisGetResponse, err error) {
	path := c.serverURL
	path += "/emojis"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEmojisGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (res ActionsEnterprisePermissions, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, req EnterpriseAdminSetGithubActionsPermissionsEnterpriseApplicationJSONRequest, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) (res EnterpriseAdminSetGithubActionsPermissionsEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, req EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseApplicationJSONRequest, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (res EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/organizations"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) (res EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/organizations/"
	{
		// Encode 'org_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.OrgID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) (res EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/organizations/"
	{
		// Encode 'org_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.OrgID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (res SelectedActions, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, req SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) (res EnterpriseAdminSetAllowedActionsEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, req EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) (res EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, req *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (res RunnerGroupsEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, req EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseApplicationJSONRequest, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/organizations/"
	{
		// Encode 'org_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.OrgID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (res EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/organizations/"
	{
		// Encode 'org_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.OrgID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, req EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) (res EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise, err error) {
	body, contentType, err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) (res EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) (res EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (res EnterpriseAdminListSelfHostedRunnersForEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) (res []RunnerApplication, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (res Runner, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) (res EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (res ActionsBillingUsage, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/settings/billing/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingGheResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (res PackagesBillingUsage, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/settings/billing/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingGheResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (res CombinedBillingUsage, err error) {
	path := c.serverURL
	path += "/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/settings/billing/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingGheResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (res ActivityListPublicEventsResponse, err error) {
	path := c.serverURL
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityGetFeeds(ctx context.Context) (res Feed, err error) {
	path := c.serverURL
	path += "/feeds"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetFeedsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsList(ctx context.Context, params GistsListParams) (res GistsListResponse, err error) {
	path := c.serverURL
	path += "/gists"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeTime(v)
		q.Set("since", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsListResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsListStarred(ctx context.Context, params GistsListStarredParams) (res GistsListStarredResponse, err error) {
	path := c.serverURL
	path += "/gists/starred"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeTime(v)
		q.Set("since", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsListStarredResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsGet(ctx context.Context, params GistsGetParams) (res GistsGetResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsDelete(ctx context.Context, params GistsDeleteParams) (res GistsDeleteResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsListComments(ctx context.Context, params GistsListCommentsParams) (res GistsListCommentsResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommentsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsCreateComment(ctx context.Context, req GistsCreateCommentApplicationJSONRequest, params GistsCreateCommentParams) (res GistsCreateCommentResponse, err error) {
	body, contentType, err := encodeGistsCreateCommentRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsCreateCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsGetComment(ctx context.Context, params GistsGetCommentParams) (res GistsGetCommentResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (res GistsDeleteCommentResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsUpdateComment(ctx context.Context, req GistsUpdateCommentApplicationJSONRequest, params GistsUpdateCommentParams) (res GistsUpdateCommentResponse, err error) {
	body, contentType, err := encodeGistsUpdateCommentRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsUpdateCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsListCommits(ctx context.Context, params GistsListCommitsParams) (res GistsListCommitsResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommitsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsListForks(ctx context.Context, params GistsListForksParams) (res GistsListForksResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/forks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsListForksResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (res GistsCheckIsStarredResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsCheckIsStarredResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsStar(ctx context.Context, params GistsStarParams) (res GistsStarResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsStarResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GistsUnstar(ctx context.Context, params GistsUnstarParams) (res GistsUnstarResponse, err error) {
	path := c.serverURL
	path += "/gists/"
	{
		// Encode 'gist_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gist_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.GistID)
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGistsUnstarResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitignoreGetAllTemplates(ctx context.Context) (res GitignoreGetAllTemplatesResponse, err error) {
	path := c.serverURL
	path += "/gitignore/templates"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetAllTemplatesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (res GitignoreGetTemplateResponse, err error) {
	path := c.serverURL
	path += "/gitignore/templates/"
	{
		// Encode 'name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Name)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetTemplateResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (res AppsListReposAccessibleToInstallationResponse, err error) {
	path := c.serverURL
	path += "/installation/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListReposAccessibleToInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsRevokeInstallationAccessToken(ctx context.Context) (res AppsRevokeInstallationAccessToken, err error) {
	path := c.serverURL
	path += "/installation/token"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsRevokeInstallationAccessTokenResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) LicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (res LicensesGetAllCommonlyUsedResponse, err error) {
	path := c.serverURL
	path += "/licenses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'featured' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Featured
		param := e.EncodeBool(v)
		q.Set("featured", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetAllCommonlyUsedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) LicensesGet(ctx context.Context, params LicensesGetParams) (res LicensesGetResponse, err error) {
	path := c.serverURL
	path += "/licenses/"
	{
		// Encode 'license' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "license",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.License)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MarkdownRender(ctx context.Context, req MarkdownRenderApplicationJSONRequest) (res MarkdownRenderResponse, err error) {
	body, contentType, err := encodeMarkdownRenderRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/markdown"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMarkdownRenderResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MarkdownRenderRaw(ctx context.Context, req MarkdownRenderRawRequest) (res MarkdownRenderRawResponse, err error) {
	body, contentType, err := encodeMarkdownRenderRawRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/markdown/raw"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMarkdownRenderRawResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (res AppsGetSubscriptionPlanForAccountResponse, err error) {
	path := c.serverURL
	path += "/marketplace_listing/accounts/"
	{
		// Encode 'account_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AccountID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListPlans(ctx context.Context, params AppsListPlansParams) (res AppsListPlansResponse, err error) {
	path := c.serverURL
	path += "/marketplace_listing/plans"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (res AppsGetSubscriptionPlanForAccountStubbedResponse, err error) {
	path := c.serverURL
	path += "/marketplace_listing/stubbed/accounts/"
	{
		// Encode 'account_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AccountID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountStubbedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (res AppsListPlansStubbedResponse, err error) {
	path := c.serverURL
	path += "/marketplace_listing/stubbed/plans"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansStubbedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MetaGet(ctx context.Context) (res MetaGetResponse, err error) {
	path := c.serverURL
	path += "/meta"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (res ActivityListPublicEventsForRepoNetworkResponse, err error) {
	path := c.serverURL
	path += "/networks/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForRepoNetworkResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityMarkNotificationsAsRead(ctx context.Context, req *ActivityMarkNotificationsAsReadApplicationJSONRequest) (res ActivityMarkNotificationsAsReadResponse, err error) {
	body, contentType, err := encodeActivityMarkNotificationsAsReadRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkNotificationsAsReadResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (res ActivityGetThreadResponse, err error) {
	path := c.serverURL
	path += "/notifications/threads/"
	{
		// Encode 'thread_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ThreadID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (res ActivityMarkThreadAsReadResponse, err error) {
	path := c.serverURL
	path += "/notifications/threads/"
	{
		// Encode 'thread_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ThreadID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkThreadAsReadResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (res ActivityGetThreadSubscriptionForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/notifications/threads/"
	{
		// Encode 'thread_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ThreadID)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivitySetThreadSubscription(ctx context.Context, req *ActivitySetThreadSubscriptionApplicationJSONRequest, params ActivitySetThreadSubscriptionParams) (res ActivitySetThreadSubscriptionResponse, err error) {
	body, contentType, err := encodeActivitySetThreadSubscriptionRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/notifications/threads/"
	{
		// Encode 'thread_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ThreadID)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetThreadSubscriptionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (res ActivityDeleteThreadSubscriptionResponse, err error) {
	path := c.serverURL
	path += "/notifications/threads/"
	{
		// Encode 'thread_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ThreadID)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteThreadSubscriptionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MetaGetOctocat(ctx context.Context, params MetaGetOctocatParams) (res string, err error) {
	path := c.serverURL
	path += "/octocat"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 's' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.S
		param := e.EncodeString(v)
		q.Set("s", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetOctocatResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsList(ctx context.Context, params OrgsListParams) (res OrgsListResponse, err error) {
	path := c.serverURL
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeInt(v)
		q.Set("since", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsGet(ctx context.Context, params OrgsGetParams) (res OrgsGetResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (res ActionsOrganizationPermissions, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, req ActionsSetGithubActionsPermissionsOrganizationApplicationJSONRequest, params ActionsSetGithubActionsPermissionsOrganizationParams) (res ActionsSetGithubActionsPermissionsOrganization, err error) {
	body, contentType, err := encodeActionsSetGithubActionsPermissionsOrganizationRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res ActionsListSelectedRepositoriesEnabledGithubActionsOrganization, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, req ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationApplicationJSONRequest, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) (res ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization, err error) {
	body, contentType, err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) (res ActionsEnableSelectedRepositoryGithubActionsOrganization, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) (res ActionsDisableSelectedRepositoryGithubActionsOrganization, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (res SelectedActions, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetAllowedActionsOrganization(ctx context.Context, req *SelectedActions, params ActionsSetAllowedActionsOrganizationParams) (res ActionsSetAllowedActionsOrganization, err error) {
	body, contentType, err := encodeActionsSetAllowedActionsOrganizationRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (res ActionsListSelfHostedRunnerGroupsForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnerGroupsForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, req ActionsCreateSelfHostedRunnerGroupForOrgApplicationJSONRequest, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	body, contentType, err := encodeActionsCreateSelfHostedRunnerGroupForOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) (res ActionsDeleteSelfHostedRunnerGroupFromOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, req ActionsUpdateSelfHostedRunnerGroupForOrgApplicationJSONRequest, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (res RunnerGroupsOrg, err error) {
	body, contentType, err := encodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsListRepoAccessToSelfHostedRunnerGroupInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, req ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgApplicationJSONRequest, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg, err error) {
	body, contentType, err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) (res ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (res ActionsListSelfHostedRunnersInGroupForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, req ActionsSetSelfHostedRunnersInGroupForOrgApplicationJSONRequest, params ActionsSetSelfHostedRunnersInGroupForOrgParams) (res ActionsSetSelfHostedRunnersInGroupForOrg, err error) {
	body, contentType, err := encodeActionsSetSelfHostedRunnersInGroupForOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) (res ActionsAddSelfHostedRunnerToGroupForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelfHostedRunnerToGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) (res ActionsRemoveSelfHostedRunnerFromGroupForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runner-groups/"
	{
		// Encode 'runner_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerGroupID)
	}
	path += "/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (res ActionsListSelfHostedRunnersForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) (res []RunnerApplication, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (res Runner, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) (res ActionsDeleteSelfHostedRunnerFromOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (res ActionsListOrgSecrets, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListOrgSecretsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (res ActionsPublicKey, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgPublicKeyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (res OrganizationActionsSecret, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, req ActionsCreateOrUpdateOrgSecretApplicationJSONRequest, params ActionsCreateOrUpdateOrgSecretParams) (res ActionsCreateOrUpdateOrgSecretResponse, err error) {
	body, contentType, err := encodeActionsCreateOrUpdateOrgSecretRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) (res ActionsDeleteOrgSecret, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (res ActionsListSelectedReposForOrgSecret, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, req ActionsSetSelectedReposForOrgSecretApplicationJSONRequest, params ActionsSetSelectedReposForOrgSecretParams) (res ActionsSetSelectedReposForOrgSecret, err error) {
	body, contentType, err := encodeActionsSetSelectedReposForOrgSecretRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (res ActionsAddSelectedRepoToOrgSecretResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelectedRepoToOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (res ActionsRemoveSelectedRepoFromOrgSecretResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelectedRepoFromOrgSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (res OrgsListBlockedUsersResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/blocks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListBlockedUsersResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (res OrgsCheckBlockedUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/blocks/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckBlockedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) (res OrgsUnblockUser, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/blocks/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUnblockUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) (res []CredentialAuthorization, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/credential-authorizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListSamlSSOAuthorizationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (res OrgsRemoveSamlSSOAuthorizationResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/credential-authorizations/"
	{
		// Encode 'credential_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "credential_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CredentialID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveSamlSSOAuthorizationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) (res []Event, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicOrgEventsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (res OrgsListFailedInvitationsResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/failed_invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListFailedInvitationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (res OrgsListWebhooksResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/hooks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListWebhooksResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (res OrgsGetWebhookResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (res OrgsDeleteWebhookResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsDeleteWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (res OrgsPingWebhookResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}
	path += "/pings"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsPingWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) (res InteractionsRemoveRestrictionsForOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (res OrgsListPendingInvitationsResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPendingInvitationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (res OrgsListInvitationTeamsResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/invitations/"
	{
		// Encode 'invitation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InvitationID)
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListInvitationTeamsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (res OrgsCheckMembershipForUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckMembershipForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (res OrgsRemoveMemberResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMemberResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (res OrgsGetMembershipForUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (res OrgsRemoveMembershipForUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMembershipForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (res MigrationsDownloadArchiveForOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDownloadArchiveForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (res MigrationsDeleteArchiveForOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (res MigrationsUnlockRepoForOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/repos/"
	{
		// Encode 'repo_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.RepoName)
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (res MigrationsListReposForOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (res OrgsConvertMemberToOutsideCollaboratorResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/outside_collaborators/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsConvertMemberToOutsideCollaboratorResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (res OrgsRemoveOutsideCollaboratorResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/outside_collaborators/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveOutsideCollaboratorResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsCreateForOrg(ctx context.Context, req ProjectsCreateForOrgApplicationJSONRequest, params ProjectsCreateForOrgParams) (res ProjectsCreateForOrgResponse, err error) {
	body, contentType, err := encodeProjectsCreateForOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (res []SimpleUser, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/public_members"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPublicMembersResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (res OrgsCheckPublicMembershipForUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/public_members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckPublicMembershipForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (res OrgsSetPublicMembershipForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/public_members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsSetPublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) (res OrgsRemovePublicMembershipForAuthenticatedUser, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/public_members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (res ActionsBillingUsage, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/settings/billing/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (res PackagesBillingUsage, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/settings/billing/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (res CombinedBillingUsage, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/settings/billing/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (res GroupMapping, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/team-sync/groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeString(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsList(ctx context.Context, params TeamsListParams) (res TeamsListResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (res TeamsGetByNameResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetByNameResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) (res TeamsDeleteInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgApplicationJSONRequest, params TeamsUpdateInOrgParams) (res TeamFull, err error) {
	body, contentType, err := encodeTeamsUpdateInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionInOrg(ctx context.Context, req TeamsCreateDiscussionInOrgApplicationJSONRequest, params TeamsCreateDiscussionInOrgParams) (res TeamDiscussion, err error) {
	body, contentType, err := encodeTeamsCreateDiscussionInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (res TeamDiscussion, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) (res TeamsDeleteDiscussionInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgApplicationJSONRequest, params TeamsUpdateDiscussionInOrgParams) (res TeamDiscussion, err error) {
	body, contentType, err := encodeTeamsUpdateDiscussionInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req TeamsCreateDiscussionCommentInOrgApplicationJSONRequest, params TeamsCreateDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	body, contentType, err := encodeTeamsCreateDiscussionCommentInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) (res TeamsDeleteDiscussionCommentInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req TeamsUpdateDiscussionCommentInOrgApplicationJSONRequest, params TeamsUpdateDiscussionCommentInOrgParams) (res TeamDiscussionComment, err error) {
	body, contentType, err := encodeTeamsUpdateDiscussionCommentInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONRequest, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (res ReactionsCreateForTeamDiscussionCommentInOrgResponse, err error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionCommentInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) (res ReactionsDeleteForTeamDiscussionComment, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req ReactionsCreateForTeamDiscussionInOrgApplicationJSONRequest, params ReactionsCreateForTeamDiscussionInOrgParams) (res ReactionsCreateForTeamDiscussionInOrgResponse, err error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) (res ReactionsDeleteForTeamDiscussion, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (res []OrganizationInvitation, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (res TeamsGetMembershipForUserInOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgApplicationJSONRequest, params TeamsAddOrUpdateMembershipForUserInOrgParams) (res TeamsAddOrUpdateMembershipForUserInOrgResponse, err error) {
	body, contentType, err := encodeTeamsAddOrUpdateMembershipForUserInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (res TeamsRemoveMembershipForUserInOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (res []TeamProject, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (res TeamsCheckPermissionsForProjectInOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgApplicationJSONRequest, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (res TeamsAddOrUpdateProjectPermissionsInOrgResponse, err error) {
	body, contentType, err := encodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) (res TeamsRemoveProjectInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveProjectInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (res []MinimalRepository, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (res TeamsCheckPermissionsForRepoInOrgResponse, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgApplicationJSONRequest, params TeamsAddOrUpdateRepoPermissionsInOrgParams) (res TeamsAddOrUpdateRepoPermissionsInOrg, err error) {
	body, contentType, err := encodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) (res TeamsRemoveRepoInOrg, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (res GroupMapping, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/team-sync/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req TeamsCreateOrUpdateIdpGroupConnectionsInOrgApplicationJSONRequest, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (res GroupMapping, err error) {
	body, contentType, err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/team-sync/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (res []Team, err error) {
	path := c.serverURL
	path += "/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/teams/"
	{
		// Encode 'team_slug' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TeamSlug)
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListChildInOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (res ProjectsGetCardResponse, err error) {
	path := c.serverURL
	path += "/projects/columns/cards/"
	{
		// Encode 'card_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CardID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetCardResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (res ProjectsDeleteCardResponse, err error) {
	path := c.serverURL
	path += "/projects/columns/cards/"
	{
		// Encode 'card_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CardID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteCardResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardApplicationJSONRequest, params ProjectsUpdateCardParams) (res ProjectsUpdateCardResponse, err error) {
	body, contentType, err := encodeProjectsUpdateCardRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/projects/columns/cards/"
	{
		// Encode 'card_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "card_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CardID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateCardResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (res ProjectsGetColumnResponse, err error) {
	path := c.serverURL
	path += "/projects/columns/"
	{
		// Encode 'column_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ColumnID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetColumnResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (res ProjectsDeleteColumnResponse, err error) {
	path := c.serverURL
	path += "/projects/columns/"
	{
		// Encode 'column_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ColumnID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteColumnResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsUpdateColumn(ctx context.Context, req ProjectsUpdateColumnApplicationJSONRequest, params ProjectsUpdateColumnParams) (res ProjectsUpdateColumnResponse, err error) {
	body, contentType, err := encodeProjectsUpdateColumnRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/projects/columns/"
	{
		// Encode 'column_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ColumnID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateColumnResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsMoveColumn(ctx context.Context, req ProjectsMoveColumnApplicationJSONRequest, params ProjectsMoveColumnParams) (res ProjectsMoveColumnResponse, err error) {
	body, contentType, err := encodeProjectsMoveColumnRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/projects/columns/"
	{
		// Encode 'column_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "column_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ColumnID)
	}
	path += "/moves"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsMoveColumnResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsGet(ctx context.Context, params ProjectsGetParams) (res ProjectsGetResponse, err error) {
	path := c.serverURL
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (res ProjectsDeleteResponse, err error) {
	path := c.serverURL
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsUpdate(ctx context.Context, req *ProjectsUpdateApplicationJSONRequest, params ProjectsUpdateParams) (res ProjectsUpdateResponse, err error) {
	body, contentType, err := encodeProjectsUpdateRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (res ProjectsListColumnsResponse, err error) {
	path := c.serverURL
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}
	path += "/columns"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListColumnsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsCreateColumn(ctx context.Context, req ProjectsCreateColumnApplicationJSONRequest, params ProjectsCreateColumnParams) (res ProjectsCreateColumnResponse, err error) {
	body, contentType, err := encodeProjectsCreateColumnRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}
	path += "/columns"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateColumnResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) RateLimitGet(ctx context.Context) (res RateLimitGetResponse, err error) {
	path := c.serverURL
	path += "/rate_limit"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeRateLimitGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (res ReactionsDeleteLegacyResponse, err error) {
	path := c.serverURL
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGet(ctx context.Context, params ReposGetParams) (res ReposGetResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDelete(ctx context.Context, params ReposDeleteParams) (res ReposDeleteResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (res ActionsListArtifactsForRepo, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/artifacts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListArtifactsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (res Artifact, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/artifacts/"
	{
		// Encode 'artifact_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ArtifactID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetArtifactResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) (res ActionsDeleteArtifact, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/artifacts/"
	{
		// Encode 'artifact_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ArtifactID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteArtifactResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (res ActionsDownloadArtifact, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/artifacts/"
	{
		// Encode 'artifact_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "artifact_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ArtifactID)
	}
	path += "/"
	{
		// Encode 'archive_format' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "archive_format",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ArchiveFormat)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadArtifactResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (res Job, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/jobs/"
	{
		// Encode 'job_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.JobID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetJobForWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (res ActionsDownloadJobLogsForWorkflowRun, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/jobs/"
	{
		// Encode 'job_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "job_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.JobID)
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadJobLogsForWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (res ActionsRepositoryPermissions, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, req ActionsSetGithubActionsPermissionsRepositoryApplicationJSONRequest, params ActionsSetGithubActionsPermissionsRepositoryParams) (res ActionsSetGithubActionsPermissionsRepository, err error) {
	body, contentType, err := encodeActionsSetGithubActionsPermissionsRepositoryRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (res SelectedActions, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsSetAllowedActionsRepository(ctx context.Context, req *SelectedActions, params ActionsSetAllowedActionsRepositoryParams) (res ActionsSetAllowedActionsRepository, err error) {
	body, contentType, err := encodeActionsSetAllowedActionsRepositoryRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/permissions/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (res ActionsListSelfHostedRunnersForRepo, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) (res []RunnerApplication, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (res AuthenticationToken, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (res Runner, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) (res ActionsDeleteSelfHostedRunnerFromRepo, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runners/"
	{
		// Encode 'runner_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runner_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunnerID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (res WorkflowRun, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) (res ActionsDeleteWorkflowRun, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) (res []EnvironmentApprovals, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/approvals"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetReviewsForRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (res ActionsApproveWorkflowRunResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/approve"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsApproveWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (res ActionsListWorkflowRunArtifacts, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/artifacts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListWorkflowRunArtifactsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) (res ActionsCancelWorkflowRun, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/cancel"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCancelWorkflowRunResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (res ActionsDownloadWorkflowRunLogs, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadWorkflowRunLogsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) (res ActionsDeleteWorkflowRunLogs, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunLogsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) (res ActionsReRunWorkflow, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/rerun"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsReRunWorkflowResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) (res ActionsRetryWorkflow, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/retry"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsRetryWorkflowResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (res WorkflowRunUsage, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/runs/"
	{
		// Encode 'run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RunID)
	}
	path += "/timing"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunUsageResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (res ActionsListRepoSecrets, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoSecretsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (res ActionsPublicKey, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/secrets/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoPublicKeyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (res ActionsSecret, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, req ActionsCreateOrUpdateRepoSecretApplicationJSONRequest, params ActionsCreateOrUpdateRepoSecretParams) (res ActionsCreateOrUpdateRepoSecretResponse, err error) {
	body, contentType, err := encodeActionsCreateOrUpdateRepoSecretRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateRepoSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) (res ActionsDeleteRepoSecret, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteRepoSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (res ActionsListRepoWorkflows, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/actions/workflows"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoWorkflowsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (res IssuesListAssigneesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListAssigneesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (res IssuesCheckUserCanBeAssignedResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/assignees/"
	{
		// Encode 'assignee' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "assignee",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Assignee)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCheckUserCanBeAssignedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) (res []Autolink, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/autolinks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListAutolinksResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (res ReposGetAutolinkResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/autolinks/"
	{
		// Encode 'autolink_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AutolinkID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAutolinkResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (res ReposDeleteAutolinkResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/autolinks/"
	{
		// Encode 'autolink_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "autolink_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AutolinkID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAutolinkResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) (res ReposEnableAutomatedSecurityFixes, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/automated-security-fixes"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) (res ReposDisableAutomatedSecurityFixes, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/automated-security-fixes"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListBranches(ctx context.Context, params ReposListBranchesParams) (res ReposListBranchesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'protected' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Protected
		param := e.EncodeBool(v)
		q.Set("protected", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListBranchesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetBranch(ctx context.Context, params ReposGetBranchParams) (res ReposGetBranchResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (res ReposGetBranchProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUpdateBranchProtection(ctx context.Context, req ReposUpdateBranchProtectionApplicationJSONRequest, params ReposUpdateBranchProtectionParams) (res ReposUpdateBranchProtectionResponse, err error) {
	body, contentType, err := encodeReposUpdateBranchProtectionRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (res ReposDeleteBranchProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (res ProtectedBranchAdminEnforced, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (res ProtectedBranchAdminEnforced, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposSetAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (res ReposDeleteAdminBranchProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAdminBranchProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (res ProtectedBranchPullRequestReview, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_pull_request_reviews"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPullRequestReviewProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (res ReposDeletePullRequestReviewProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_pull_request_reviews"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeletePullRequestReviewProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (res ReposGetCommitSignatureProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (res ReposCreateCommitSignatureProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (res ReposDeleteCommitSignatureProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitSignatureProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (res ReposGetStatusChecksProtectionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_status_checks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetStatusChecksProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) (res ReposRemoveStatusCheckProtection, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_status_checks"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveStatusCheckProtectionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (res ReposGetAllStatusCheckContextsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/required_status_checks/contexts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllStatusCheckContextsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (res ReposGetAccessRestrictionsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/restrictions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAccessRestrictionsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) (res ReposDeleteAccessRestrictions, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/restrictions"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAccessRestrictionsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (res ReposGetAppsWithAccessToProtectedBranchResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/restrictions/apps"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAppsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (res ReposGetTeamsWithAccessToProtectedBranchResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/restrictions/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTeamsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (res ReposGetUsersWithAccessToProtectedBranchResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/branches/"
	{
		// Encode 'branch' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "branch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Branch)
	}
	path += "/protection/restrictions/users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetUsersWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksGet(ctx context.Context, params ChecksGetParams) (res CheckRun, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-runs/"
	{
		// Encode 'check_run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CheckRunID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (res []CheckAnnotation, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-runs/"
	{
		// Encode 'check_run_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_run_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CheckRunID)
	}
	path += "/annotations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksListAnnotationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksCreateSuite(ctx context.Context, req ChecksCreateSuiteApplicationJSONRequest, params ChecksCreateSuiteParams) (res ChecksCreateSuiteResponse, err error) {
	body, contentType, err := encodeChecksCreateSuiteRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-suites"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksCreateSuiteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksSetSuitesPreferences(ctx context.Context, req ChecksSetSuitesPreferencesApplicationJSONRequest, params ChecksSetSuitesPreferencesParams) (res CheckSuitePreference, err error) {
	body, contentType, err := encodeChecksSetSuitesPreferencesRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-suites/preferences"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksSetSuitesPreferencesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (res CheckSuite, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-suites/"
	{
		// Encode 'check_suite_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CheckSuiteID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetSuiteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) (res ChecksRerequestSuite, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/check-suites/"
	{
		// Encode 'check_suite_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "check_suite_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CheckSuiteID)
	}
	path += "/rerequest"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksRerequestSuiteResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (res CodeScanningGetAlertResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/alerts/"
	{
		// Encode 'alert_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AlertNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAlertResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningUpdateAlert(ctx context.Context, req CodeScanningUpdateAlertApplicationJSONRequest, params CodeScanningUpdateAlertParams) (res CodeScanningUpdateAlertResponse, err error) {
	body, contentType, err := encodeCodeScanningUpdateAlertRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/alerts/"
	{
		// Encode 'alert_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AlertNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUpdateAlertResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (res CodeScanningListAlertInstancesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/alerts/"
	{
		// Encode 'alert_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AlertNumber)
	}
	path += "/instances"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'ref' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Ref
		param := e.EncodeString(v)
		q.Set("ref", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListAlertInstancesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (res CodeScanningListRecentAnalysesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/analyses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'tool_name' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ToolName
		param := e.EncodeString(v)
		q.Set("tool_name", param)
	}
	{
		// Encode 'tool_guid' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ToolGUID
		param := e.EncodeString(v)
		q.Set("tool_guid", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'ref' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Ref
		param := e.EncodeString(v)
		q.Set("ref", param)
	}
	{
		// Encode 'sarif_id' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.SarifID
		param := e.EncodeString(v)
		q.Set("sarif_id", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListRecentAnalysesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (res CodeScanningGetAnalysisResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/analyses/"
	{
		// Encode 'analysis_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AnalysisID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAnalysisResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (res CodeScanningDeleteAnalysisResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/analyses/"
	{
		// Encode 'analysis_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "analysis_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AnalysisID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'confirm_delete' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ConfirmDelete
		param := e.EncodeString(v)
		q.Set("confirm_delete", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningDeleteAnalysisResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningUploadSarif(ctx context.Context, req CodeScanningUploadSarifApplicationJSONRequest, params CodeScanningUploadSarifParams) (res CodeScanningUploadSarifResponse, err error) {
	body, contentType, err := encodeCodeScanningUploadSarifRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/sarifs"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUploadSarifResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) CodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (res CodeScanningGetSarifResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/code-scanning/sarifs/"
	{
		// Encode 'sarif_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sarif_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SarifID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetSarifResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (res ReposCheckCollaboratorResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/collaborators/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckCollaboratorResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) (res ReposRemoveCollaborator, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/collaborators/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveCollaboratorResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (res ReposGetCollaboratorPermissionLevelResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/collaborators/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/permission"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCollaboratorPermissionLevelResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (res []CommitComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitCommentsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (res ReposGetCommitCommentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (res ReposDeleteCommitCommentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUpdateCommitComment(ctx context.Context, req ReposUpdateCommitCommentApplicationJSONRequest, params ReposUpdateCommitCommentParams) (res ReposUpdateCommitCommentResponse, err error) {
	body, contentType, err := encodeReposUpdateCommitCommentRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateCommitCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) (res ReactionsDeleteForCommitComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForCommitCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListCommits(ctx context.Context, params ReposListCommitsParams) (res ReposListCommitsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'sha' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Sha
		param := e.EncodeString(v)
		q.Set("sha", param)
	}
	{
		// Encode 'path' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Path
		param := e.EncodeString(v)
		q.Set("path", param)
	}
	{
		// Encode 'author' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Author
		param := e.EncodeString(v)
		q.Set("author", param)
	}
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeTime(v)
		q.Set("since", param)
	}
	{
		// Encode 'until' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Until
		param := e.EncodeTime(v)
		q.Set("until", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (res []CommitComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits/"
	{
		// Encode 'commit_sha' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.CommitSha)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommentsForCommitResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (res []PullRequestSimple, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits/"
	{
		// Encode 'commit_sha' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.CommitSha)
	}
	path += "/pulls"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListPullRequestsAssociatedWithCommitResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (res ChecksListSuitesForRef, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}
	path += "/check-suites"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'app_id' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.AppID
		param := e.EncodeInt(v)
		q.Set("app_id", param)
	}
	{
		// Encode 'check_name' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.CheckName
		param := e.EncodeString(v)
		q.Set("check_name", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeChecksListSuitesForRefResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (res ReposGetCombinedStatusForRefResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}
	path += "/status"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCombinedStatusForRefResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (res ReposListCommitStatusesForRefResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/commits/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}
	path += "/statuses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitStatusesForRefResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (res CommunityProfile, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/community/profile"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommunityProfileMetricsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (res ReposCompareCommitsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/compare/"
	{
		// Encode 'basehead' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "basehead",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Basehead)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCompareCommitsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListContributors(ctx context.Context, params ReposListContributorsParams) (res ReposListContributorsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/contributors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'anon' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Anon
		param := e.EncodeString(v)
		q.Set("anon", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListContributorsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (res ReposDeleteDeploymentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/deployments/"
	{
		// Encode 'deployment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DeploymentID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeploymentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (res ReposListDeploymentStatusesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/deployments/"
	{
		// Encode 'deployment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DeploymentID)
	}
	path += "/statuses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeploymentStatusesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (res ReposGetDeploymentStatusResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/deployments/"
	{
		// Encode 'deployment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "deployment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DeploymentID)
	}
	path += "/statuses/"
	{
		// Encode 'status_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "status_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.StatusID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeploymentStatusResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) (res ReposDeleteAnEnvironment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAnEnvironmentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) (res []Event, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoEventsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitGetCommit(ctx context.Context, params GitGetCommitParams) (res GitGetCommitResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/git/commits/"
	{
		// Encode 'commit_sha' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commit_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.CommitSha)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitGetCommitResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (res []GitRef, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/git/matching-refs/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitListMatchingRefsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitGetRef(ctx context.Context, params GitGetRefParams) (res GitGetRefResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/git/ref/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitGetRefResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) GitGetTag(ctx context.Context, params GitGetTagParams) (res GitGetTagResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/git/tags/"
	{
		// Encode 'tag_sha' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag_sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TagSha)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeGitGetTagResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (res ReposDeleteWebhookResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (res ReposPingWebhookResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}
	path += "/pings"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposPingWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (res ReposTestPushWebhookResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/hooks/"
	{
		// Encode 'hook_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.HookID)
	}
	path += "/tests"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposTestPushWebhookResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (res MigrationsGetImportStatusResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetImportStatusResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) (res MigrationsCancelImport, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsCancelImportResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsUpdateImport(ctx context.Context, req *MigrationsUpdateImportApplicationJSONRequest, params MigrationsUpdateImportParams) (res Import, err error) {
	body, contentType, err := encodeMigrationsUpdateImportRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUpdateImportResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (res MigrationsGetCommitAuthorsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/import/authors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeInt(v)
		q.Set("since", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetCommitAuthorsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) (res []PorterLargeFile, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/import/large_files"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetLargeFilesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) InteractionsSetRestrictionsForRepo(ctx context.Context, req InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (res InteractionsSetRestrictionsForRepoResponse, err error) {
	body, contentType, err := encodeInteractionsSetRestrictionsForRepoRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (res InteractionsRemoveRestrictionsForRepoResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (res []RepositoryInvitation, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) (res ReposDeleteInvitation, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/invitations/"
	{
		// Encode 'invitation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InvitationID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteInvitationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationApplicationJSONRequest, params ReposUpdateInvitationParams) (res RepositoryInvitation, err error) {
	body, contentType, err := encodeReposUpdateInvitationRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/invitations/"
	{
		// Encode 'invitation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InvitationID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateInvitationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (res IssuesGetCommentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) (res IssuesDeleteComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) (res ReactionsDeleteForIssueComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (res IssuesGetEventResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/events/"
	{
		// Encode 'event_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "event_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.EventID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetEventResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesApplicationJSONRequest, params IssuesAddAssigneesParams) (res IssueSimple, err error) {
	body, contentType, err := encodeIssuesAddAssigneesRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesAddAssigneesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesApplicationJSONRequest, params IssuesRemoveAssigneesParams) (res IssueSimple, err error) {
	body, contentType, err := encodeIssuesRemoveAssigneesRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAssigneesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesListComments(ctx context.Context, params IssuesListCommentsParams) (res IssuesListCommentsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeTime(v)
		q.Set("since", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListCommentsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (res IssuesListLabelsOnIssueResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsOnIssueResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (res IssuesRemoveAllLabelsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAllLabelsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (res IssuesRemoveLabelResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/labels/"
	{
		// Encode 'name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Name)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveLabelResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesUnlock(ctx context.Context, params IssuesUnlockParams) (res IssuesUnlockResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUnlockResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) (res ReactionsDeleteForIssue, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/issues/"
	{
		// Encode 'issue_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "issue_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.IssueNumber)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (res []DeployKey, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeployKeysResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (res ReposGetDeployKeyResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/keys/"
	{
		// Encode 'key_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.KeyID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeployKeyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) (res ReposDeleteDeployKey, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/keys/"
	{
		// Encode 'key_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.KeyID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeployKeyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (res IssuesListLabelsForRepoResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (res IssuesGetLabelResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/labels/"
	{
		// Encode 'name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Name)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetLabelResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) (res IssuesDeleteLabel, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/labels/"
	{
		// Encode 'name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Name)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteLabelResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelApplicationJSONRequest, params IssuesUpdateLabelParams) (res Label, err error) {
	body, contentType, err := encodeIssuesUpdateLabelRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/labels/"
	{
		// Encode 'name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Name)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateLabelResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (res Language, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/languages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListLanguagesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (res ReposEnableLfsForRepoResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/lfs"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableLfsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) (res ReposDisableLfsForRepo, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/lfs"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableLfsForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) LicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (res LicenseContent, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/license"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposMergeUpstream(ctx context.Context, req ReposMergeUpstreamApplicationJSONRequest, params ReposMergeUpstreamParams) (res ReposMergeUpstreamResponse, err error) {
	body, contentType, err := encodeReposMergeUpstreamRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/merge-upstream"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposMergeUpstreamResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (res IssuesGetMilestoneResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/milestones/"
	{
		// Encode 'milestone_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MilestoneNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetMilestoneResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (res IssuesDeleteMilestoneResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/milestones/"
	{
		// Encode 'milestone_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MilestoneNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteMilestoneResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneApplicationJSONRequest, params IssuesUpdateMilestoneParams) (res Milestone, err error) {
	body, contentType, err := encodeIssuesUpdateMilestoneRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/milestones/"
	{
		// Encode 'milestone_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MilestoneNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateMilestoneResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) IssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (res []Label, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/milestones/"
	{
		// Encode 'milestone_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "milestone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MilestoneNumber)
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForMilestoneResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (res []Thread, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'all' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.All
		param := e.EncodeBool(v)
		q.Set("all", param)
	}
	{
		// Encode 'participating' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Participating
		param := e.EncodeBool(v)
		q.Set("participating", param)
	}
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeTime(v)
		q.Set("since", param)
	}
	{
		// Encode 'before' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Before
		param := e.EncodeTime(v)
		q.Set("before", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoNotificationsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, req *ActivityMarkRepoNotificationsAsReadApplicationJSONRequest, params ActivityMarkRepoNotificationsAsReadParams) (res ActivityMarkRepoNotificationsAsReadResponse, err error) {
	body, contentType, err := encodeActivityMarkRepoNotificationsAsReadRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkRepoNotificationsAsReadResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetPages(ctx context.Context, params ReposGetPagesParams) (res ReposGetPagesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (res []PageBuild, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages/builds"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListPagesBuildsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (res PageBuildStatus, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages/builds"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposRequestPagesBuildResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (res PageBuild, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages/builds/latest"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestPagesBuildResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (res PageBuild, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages/builds/"
	{
		// Encode 'build_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "build_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.BuildID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesBuildResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (res ReposGetPagesHealthCheckResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pages/health"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesHealthCheckResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsCreateForRepo(ctx context.Context, req ProjectsCreateForRepoApplicationJSONRequest, params ProjectsCreateForRepoParams) (res ProjectsCreateForRepoResponse, err error) {
	body, contentType, err := encodeProjectsCreateForRepoRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (res PullsGetReviewCommentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (res PullsDeleteReviewCommentResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsDeleteReviewCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsUpdateReviewComment(ctx context.Context, req PullsUpdateReviewCommentApplicationJSONRequest, params PullsUpdateReviewCommentParams) (res PullRequestReviewComment, err error) {
	body, contentType, err := encodePullsUpdateReviewCommentRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) (res ReactionsDeleteForPullRequestComment, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}
	path += "/reactions/"
	{
		// Encode 'reaction_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "reaction_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReactionID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForPullRequestCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsGet(ctx context.Context, params PullsGetParams) (res PullsGetResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsGetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsCreateReplyForReviewComment(ctx context.Context, req PullsCreateReplyForReviewCommentApplicationJSONRequest, params PullsCreateReplyForReviewCommentParams) (res PullsCreateReplyForReviewCommentResponse, err error) {
	body, contentType, err := encodePullsCreateReplyForReviewCommentRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentID)
	}
	path += "/replies"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReplyForReviewCommentResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsListCommits(ctx context.Context, params PullsListCommitsParams) (res []Commit, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommitsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (res PullsCheckIfMergedResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/merge"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsCheckIfMergedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (res PullRequestReviewRequest, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/requested_reviewers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsListRequestedReviewersResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsListReviews(ctx context.Context, params PullsListReviewsParams) (res []PullRequestReview, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsCreateReview(ctx context.Context, req *PullsCreateReviewApplicationJSONRequest, params PullsCreateReviewParams) (res PullsCreateReviewResponse, err error) {
	body, contentType, err := encodePullsCreateReviewRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsGetReview(ctx context.Context, params PullsGetReviewParams) (res PullsGetReviewResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsUpdateReview(ctx context.Context, req PullsUpdateReviewApplicationJSONRequest, params PullsUpdateReviewParams) (res PullsUpdateReviewResponse, err error) {
	body, contentType, err := encodePullsUpdateReviewRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (res PullsDeletePendingReviewResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsDeletePendingReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (res PullsListCommentsForReviewResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommentsForReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsDismissReview(ctx context.Context, req PullsDismissReviewApplicationJSONRequest, params PullsDismissReviewParams) (res PullsDismissReviewResponse, err error) {
	body, contentType, err := encodePullsDismissReviewRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}
	path += "/dismissals"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsDismissReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) PullsSubmitReview(ctx context.Context, req PullsSubmitReviewApplicationJSONRequest, params PullsSubmitReviewParams) (res PullsSubmitReviewResponse, err error) {
	body, contentType, err := encodePullsSubmitReviewRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/pulls/"
	{
		// Encode 'pull_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pull_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.PullNumber)
	}
	path += "/reviews/"
	{
		// Encode 'review_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "review_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReviewID)
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodePullsSubmitReviewResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListReleases(ctx context.Context, params ReposListReleasesParams) (res ReposListReleasesResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleasesResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (res ReposGetReleaseAssetResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/assets/"
	{
		// Encode 'asset_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AssetID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseAssetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) (res ReposDeleteReleaseAsset, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/assets/"
	{
		// Encode 'asset_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AssetID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseAssetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetApplicationJSONRequest, params ReposUpdateReleaseAssetParams) (res ReleaseAsset, err error) {
	body, contentType, err := encodeReposUpdateReleaseAssetRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/assets/"
	{
		// Encode 'asset_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "asset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AssetID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseAssetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (res Release, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/latest"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestReleaseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (res ReposGetReleaseByTagResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/tags/"
	{
		// Encode 'tag' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Tag)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseByTagResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (res ReposGetReleaseResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/"
	{
		// Encode 'release_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReleaseID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) (res ReposDeleteRelease, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/"
	{
		// Encode 'release_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReleaseID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseApplicationJSONRequest, params ReposUpdateReleaseParams) (res ReposUpdateReleaseResponse, err error) {
	body, contentType, err := encodeReposUpdateReleaseRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/"
	{
		// Encode 'release_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReleaseID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (res []ReleaseAsset, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/"
	{
		// Encode 'release_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReleaseID)
	}
	path += "/assets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleaseAssetsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposUploadReleaseAsset(ctx context.Context, req *string, params ReposUploadReleaseAssetParams) (res ReleaseAsset, err error) {
	body, contentType, err := encodeReposUploadReleaseAssetRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/releases/"
	{
		// Encode 'release_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "release_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ReleaseID)
	}
	path += "/assets"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		// Encode 'name' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Name
		param := e.EncodeString(v)
		q.Set("name", param)
	}
	{
		// Encode 'label' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Label
		param := e.EncodeString(v)
		q.Set("label", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposUploadReleaseAssetResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) SecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (res SecretScanningGetAlertResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/secret-scanning/alerts/"
	{
		// Encode 'alert_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AlertNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningGetAlertResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) SecretScanningUpdateAlert(ctx context.Context, req SecretScanningUpdateAlertApplicationJSONRequest, params SecretScanningUpdateAlertParams) (res SecretScanningUpdateAlertResponse, err error) {
	body, contentType, err := encodeSecretScanningUpdateAlertRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/secret-scanning/alerts/"
	{
		// Encode 'alert_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "alert_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.AlertNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningUpdateAlertResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (res ReposGetCodeFrequencyStatsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/stats/code_frequency"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCodeFrequencyStatsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (res ReposGetCommitActivityStatsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/stats/commit_activity"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitActivityStatsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (res ReposGetContributorsStatsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/stats/contributors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetContributorsStatsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (res ReposGetParticipationStatsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/stats/participation"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetParticipationStatsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (res ReposGetPunchCardStatsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/stats/punch_card"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPunchCardStatsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCreateCommitStatus(ctx context.Context, req ReposCreateCommitStatusApplicationJSONRequest, params ReposCreateCommitStatusParams) (res Status, err error) {
	body, contentType, err := encodeReposCreateCommitStatusRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/statuses/"
	{
		// Encode 'sha' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sha",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Sha)
	}

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitStatusResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (res []SimpleUser, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/subscribers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchersForRepoResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (res ActivityGetRepoSubscriptionResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetRepoSubscriptionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivitySetRepoSubscription(ctx context.Context, req *ActivitySetRepoSubscriptionApplicationJSONRequest, params ActivitySetRepoSubscriptionParams) (res RepositorySubscription, err error) {
	body, contentType, err := encodeActivitySetRepoSubscriptionRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetRepoSubscriptionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) (res ActivityDeleteRepoSubscription, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteRepoSubscriptionResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListTags(ctx context.Context, params ReposListTagsParams) (res []Tag, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/tags"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListTagsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (res ReposDownloadTarballArchive, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/tarball/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadTarballArchiveResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListTeams(ctx context.Context, params ReposListTeamsParams) (res []Team, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListTeamsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (res ReposGetAllTopicsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/topics"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllTopicsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposReplaceAllTopics(ctx context.Context, req ReposReplaceAllTopicsApplicationJSONRequest, params ReposReplaceAllTopicsParams) (res ReposReplaceAllTopicsResponse, err error) {
	body, contentType, err := encodeReposReplaceAllTopicsRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/topics"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposReplaceAllTopicsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (res ReposGetTopPathsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/traffic/popular/paths"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopPathsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (res ReposGetTopReferrersResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/traffic/popular/referrers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopReferrersResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposTransfer(ctx context.Context, req ReposTransferApplicationJSONRequest, params ReposTransferParams) (res MinimalRepository, err error) {
	body, contentType, err := encodeReposTransferRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/transfer"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposTransferResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (res ReposCheckVulnerabilityAlertsResponse, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) (res ReposEnableVulnerabilityAlerts, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) (res ReposDisableVulnerabilityAlerts, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableVulnerabilityAlertsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (res ReposDownloadZipballArchive, err error) {
	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}
	path += "/zipball/"
	{
		// Encode 'ref' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ref",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Ref)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadZipballArchiveResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposCreateUsingTemplate(ctx context.Context, req ReposCreateUsingTemplateApplicationJSONRequest, params ReposCreateUsingTemplateParams) (res Repository, err error) {
	body, contentType, err := encodeReposCreateUsingTemplateRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repos/"
	{
		// Encode 'template_owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TemplateOwner)
	}
	path += "/"
	{
		// Encode 'template_repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "template_repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TemplateRepo)
	}
	path += "/generate"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateUsingTemplateResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (res ActionsListEnvironmentSecrets, err error) {
	path := c.serverURL
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsListEnvironmentSecretsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (res ActionsPublicKey, err error) {
	path := c.serverURL
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}
	path += "/secrets/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentPublicKeyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (res ActionsSecret, err error) {
	path := c.serverURL
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}
	path += "/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, req ActionsCreateOrUpdateEnvironmentSecretApplicationJSONRequest, params ActionsCreateOrUpdateEnvironmentSecretParams) (res ActionsCreateOrUpdateEnvironmentSecretResponse, err error) {
	body, contentType, err := encodeActionsCreateOrUpdateEnvironmentSecretRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}
	path += "/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateEnvironmentSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) (res ActionsDeleteEnvironmentSecret, err error) {
	path := c.serverURL
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}
	path += "/environments/"
	{
		// Encode 'environment_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.EnvironmentName)
	}
	path += "/secrets/"
	{
		// Encode 'secret_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.SecretName)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteEnvironmentSecretResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (res ScimGroupListEnterprise, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'startIndex' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.StartIndex
		param := e.EncodeInt(v)
		q.Set("startIndex", param)
	}
	{
		// Encode 'count' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Count
		param := e.EncodeInt(v)
		q.Set("count", param)
	}
	{
		// Encode 'filter' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Filter
		param := e.EncodeString(v)
		q.Set("filter", param)
	}
	{
		// Encode 'excludedAttributes' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ExcludedAttributes
		param := e.EncodeString(v)
		q.Set("excludedAttributes", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, req EnterpriseAdminProvisionAndInviteEnterpriseGroupApplicationJSONRequest, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	body, contentType, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Groups/"
	{
		// Encode 'scim_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'excludedAttributes' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.ExcludedAttributes
		param := e.EncodeString(v)
		q.Set("excludedAttributes", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, req EnterpriseAdminSetInformationForProvisionedEnterpriseGroupApplicationJSONRequest, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (res ScimEnterpriseGroup, err error) {
	body, contentType, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Groups/"
	{
		// Encode 'scim_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) (res EnterpriseAdminDeleteScimGroupFromEnterprise, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Groups/"
	{
		// Encode 'scim_group_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimGroupID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (res ScimUserListEnterprise, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'startIndex' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.StartIndex
		param := e.EncodeInt(v)
		q.Set("startIndex", param)
	}
	{
		// Encode 'count' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Count
		param := e.EncodeInt(v)
		q.Set("count", param)
	}
	{
		// Encode 'filter' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Filter
		param := e.EncodeString(v)
		q.Set("filter", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, req EnterpriseAdminProvisionAndInviteEnterpriseUserApplicationJSONRequest, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	body, contentType, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users/"
	{
		// Encode 'scim_user_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimUserID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, req EnterpriseAdminSetInformationForProvisionedEnterpriseUserApplicationJSONRequest, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	body, contentType, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users/"
	{
		// Encode 'scim_user_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimUserID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) (res EnterpriseAdminDeleteUserFromEnterprise, err error) {
	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users/"
	{
		// Encode 'scim_user_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimUserID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteUserFromEnterpriseResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, req EnterpriseAdminUpdateAttributeForEnterpriseUserApplicationJSONRequest, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (res ScimEnterpriseUser, err error) {
	body, contentType, err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/scim/v2/enterprises/"
	{
		// Encode 'enterprise' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "enterprise",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Enterprise)
	}
	path += "/Users/"
	{
		// Encode 'scim_user_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimUserID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (res ScimDeleteUserFromOrgResponse, err error) {
	path := c.serverURL
	path += "/scim/v2/organizations/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}
	path += "/Users/"
	{
		// Encode 'scim_user_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scim_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.ScimUserID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeScimDeleteUserFromOrgResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) SearchTopics(ctx context.Context, params SearchTopicsParams) (res SearchTopicsResponse, err error) {
	path := c.serverURL
	path += "/search/topics"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'q' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Q
		param := e.EncodeString(v)
		q.Set("q", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeSearchTopicsResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (res TeamsGetLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionLegacy(ctx context.Context, req TeamsCreateDiscussionLegacyApplicationJSONRequest, params TeamsCreateDiscussionLegacyParams) (res TeamDiscussion, err error) {
	body, contentType, err := encodeTeamsCreateDiscussionLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (res TeamDiscussion, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) (res TeamsDeleteDiscussionLegacy, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyApplicationJSONRequest, params TeamsUpdateDiscussionLegacyParams) (res TeamDiscussion, err error) {
	body, contentType, err := encodeTeamsUpdateDiscussionLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, req TeamsCreateDiscussionCommentLegacyApplicationJSONRequest, params TeamsCreateDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	body, contentType, err := encodeTeamsCreateDiscussionCommentLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) (res TeamsDeleteDiscussionCommentLegacy, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req TeamsUpdateDiscussionCommentLegacyApplicationJSONRequest, params TeamsUpdateDiscussionCommentLegacyParams) (res TeamDiscussionComment, err error) {
	body, contentType, err := encodeTeamsUpdateDiscussionCommentLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req ReactionsCreateForTeamDiscussionCommentLegacyApplicationJSONRequest, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (res Reaction, err error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionCommentLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/comments/"
	{
		// Encode 'comment_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "comment_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.CommentNumber)
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req ReactionsCreateForTeamDiscussionLegacyApplicationJSONRequest, params ReactionsCreateForTeamDiscussionLegacyParams) (res Reaction, err error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/discussions/"
	{
		// Encode 'discussion_number' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "discussion_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.DiscussionNumber)
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (res []OrganizationInvitation, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (res TeamsGetMemberLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMemberLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (res TeamsAddMemberLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddMemberLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (res TeamsRemoveMemberLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/members/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMemberLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (res TeamsGetMembershipForUserLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyApplicationJSONRequest, params TeamsAddOrUpdateMembershipForUserLegacyParams) (res TeamsAddOrUpdateMembershipForUserLegacyResponse, err error) {
	body, contentType, err := encodeTeamsAddOrUpdateMembershipForUserLegacyRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (res TeamsRemoveMembershipForUserLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/memberships/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (res TeamsListProjectsLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (res TeamsCheckPermissionsForProjectLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/projects/"
	{
		// Encode 'project_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.ProjectID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (res TeamsListReposLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (res TeamsCheckPermissionsForRepoLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) (res TeamsRemoveRepoLegacy, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/repos/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (res TeamsListIdpGroupsForLegacyResponse, err error) {
	path := c.serverURL
	path += "/teams/"
	{
		// Encode 'team_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "team_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.TeamID)
	}
	path += "/team-sync/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForLegacyResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListBlockedByAuthenticated(ctx context.Context) (res UsersListBlockedByAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/blocks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListBlockedByAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (res UsersCheckBlockedResponse, err error) {
	path := c.serverURL
	path += "/user/blocks/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckBlockedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersUnblock(ctx context.Context, params UsersUnblockParams) (res UsersUnblockResponse, err error) {
	path := c.serverURL
	path += "/user/blocks/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnblockResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (res UsersListEmailsForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/emails"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListEmailsForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (res UsersListFollowersForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/followers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (res UsersListFollowedByAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/following"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowedByAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (res UsersCheckPersonIsFollowedByAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/following/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckPersonIsFollowedByAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersFollow(ctx context.Context, params UsersFollowParams) (res UsersFollowResponse, err error) {
	path := c.serverURL
	path += "/user/following/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersFollowResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersUnfollow(ctx context.Context, params UsersUnfollowParams) (res UsersUnfollowResponse, err error) {
	path := c.serverURL
	path += "/user/following/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnfollowResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (res UsersListGpgKeysForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/gpg_keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (res UsersGetGpgKeyForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/gpg_keys/"
	{
		// Encode 'gpg_key_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gpg_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.GpgKeyID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (res AppsListInstallationReposForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListInstallationReposForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (res AppsAddRepoToInstallationResponse, err error) {
	path := c.serverURL
	path += "/user/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsAddRepoToInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (res AppsRemoveRepoFromInstallationResponse, err error) {
	path := c.serverURL
	path += "/user/installations/"
	{
		// Encode 'installation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "installation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InstallationID)
	}
	path += "/repositories/"
	{
		// Encode 'repository_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repository_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.RepositoryID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsRemoveRepoFromInstallationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) (res InteractionsRemoveRestrictionsForAuthenticatedUser, err error) {
	path := c.serverURL
	path += "/user/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (res UsersListPublicSSHKeysForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicSSHKeysForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (res UsersGetPublicSSHKeyForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/keys/"
	{
		// Encode 'key_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.KeyID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetPublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (res UsersDeletePublicSSHKeyForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/keys/"
	{
		// Encode 'key_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.KeyID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeletePublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (res AppsListSubscriptionsForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/marketplace_purchases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (res AppsListSubscriptionsForAuthenticatedUserStubbedResponse, err error) {
	path := c.serverURL
	path += "/user/marketplace_purchases/stubbed"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (res OrgsGetMembershipForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/memberships/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (res MigrationsListForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (res MigrationsGetStatusForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'exclude' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Exclude
		param := e.EncodeStringArray(v)
		q["exclude"] = param
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetStatusForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (res MigrationsGetArchiveForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (res MigrationsDeleteArchiveForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (res MigrationsUnlockRepoForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/repos/"
	{
		// Encode 'repo_name' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.RepoName)
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (res MigrationsListReposForUserResponse, err error) {
	path := c.serverURL
	path += "/user/migrations/"
	{
		// Encode 'migration_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "migration_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.MigrationID)
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (res OrgsListForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/orgs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, req ProjectsCreateForAuthenticatedUserApplicationJSONRequest) (res ProjectsCreateForAuthenticatedUserResponse, err error) {
	body, contentType, err := encodeProjectsCreateForAuthenticatedUserRequest(req)
	if err != nil {
		return res, err
	}

	path := c.serverURL
	path += "/user/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (res UsersListPublicEmailsForAuthenticatedResponse, err error) {
	path := c.serverURL
	path += "/user/public_emails"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicEmailsForAuthenticatedResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (res ReposListInvitationsForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/repository_invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (res ReposDeclineInvitationResponse, err error) {
	path := c.serverURL
	path += "/user/repository_invitations/"
	{
		// Encode 'invitation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InvitationID)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposDeclineInvitationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (res ReposAcceptInvitationResponse, err error) {
	path := c.serverURL
	path += "/user/repository_invitations/"
	{
		// Encode 'invitation_id' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeInt(params.InvitationID)
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeReposAcceptInvitationResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (res ActivityCheckRepoIsStarredByAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/starred/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (res ActivityStarRepoForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/starred/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityStarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (res ActivityUnstarRepoForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/starred/"
	{
		// Encode 'owner' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "owner",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Owner)
	}
	path += "/"
	{
		// Encode 'repo' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Repo)
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityUnstarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (res ActivityListWatchedReposForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/subscriptions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchedReposForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) TeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (res TeamsListForAuthenticatedUserResponse, err error) {
	path := c.serverURL
	path += "/user/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersList(ctx context.Context, params UsersListParams) (res UsersListResponse, err error) {
	path := c.serverURL
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'since' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Since
		param := e.EncodeInt(v)
		q.Set("since", param)
	}
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) (res []Event, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) (res []Event, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/events/orgs/"
	{
		// Encode 'org' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "org",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Org)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListOrgEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) (res []Event, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/events/public"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (res []SimpleUser, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/followers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (res []SimpleUser, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/following"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowingForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (res UsersCheckFollowingForUserResponse, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/following/"
	{
		// Encode 'target_user' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "target_user",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.TargetUser)
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckFollowingForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (res []GpgKey, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/gpg_keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) UsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (res []KeySimple, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicKeysForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) OrgsListForUser(ctx context.Context, params OrgsListForUserParams) (res []OrganizationSimple, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/orgs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) (res []Event, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/received_events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedEventsForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) (res []Event, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/received_events/public"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedPublicEventsForUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (res ActionsBillingUsage, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/settings/billing/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (res PackagesBillingUsage, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/settings/billing/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (res CombinedBillingUsage, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/settings/billing/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) ActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (res []MinimalRepository, err error) {
	path := c.serverURL
	path += "/users/"
	{
		// Encode 'username' parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		path += e.EncodeString(params.Username)
	}
	path += "/subscriptions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	q := r.URL.Query()
	{
		// Encode 'per_page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.PerPage
		param := e.EncodeInt(v)
		q.Set("per_page", param)
	}
	{
		// Encode 'page' parameter.
		e := uri.NewQueryEncoder(uri.QueryEncoderConfig{
			Style:   uri.QueryStyleForm,
			Explode: true,
		})
		v := params.Page
		param := e.EncodeInt(v)
		q.Set("page", param)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposWatchedByUserResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}

func (c *Client) MetaGetZen(ctx context.Context) (res string, err error) {
	path := c.serverURL
	path += "/zen"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		return res, fmt.Errorf("create request: %w", err)
	}

	resp, err := c.http.Do(r)
	if err != nil {
		return res, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetZenResponse(resp)
	if err != nil {
		return res, fmt.Errorf("decode response: %w", err)
	}

	return result, nil
}
