// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsAddSelectedRepoToOrgSecretParams(args map[string]string, r *http.Request) (ActionsAddSelectedRepoToOrgSecretParams, error) {
	var params ActionsAddSelectedRepoToOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args map[string]string, r *http.Request) (ActionsAddSelfHostedRunnerToGroupForOrgParams, error) {
	var params ActionsAddSelfHostedRunnerToGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsApproveWorkflowRunParams(args map[string]string, r *http.Request) (ActionsApproveWorkflowRunParams, error) {
	var params ActionsApproveWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCancelWorkflowRunParams(args map[string]string, r *http.Request) (ActionsCancelWorkflowRunParams, error) {
	var params ActionsCancelWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateEnvironmentSecretParams, error) {
	var params ActionsCreateOrUpdateEnvironmentSecretParams
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateOrgSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateOrgSecretParams, error) {
	var params ActionsCreateOrUpdateOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateRepoSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateRepoSecretParams, error) {
	var params ActionsCreateOrUpdateRepoSecretParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForOrgParams(args map[string]string, r *http.Request) (ActionsCreateRegistrationTokenForOrgParams, error) {
	var params ActionsCreateRegistrationTokenForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForRepoParams(args map[string]string, r *http.Request) (ActionsCreateRegistrationTokenForRepoParams, error) {
	var params ActionsCreateRegistrationTokenForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForOrgParams(args map[string]string, r *http.Request) (ActionsCreateRemoveTokenForOrgParams, error) {
	var params ActionsCreateRemoveTokenForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForRepoParams(args map[string]string, r *http.Request) (ActionsCreateRemoveTokenForRepoParams, error) {
	var params ActionsCreateRemoveTokenForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsCreateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsCreateSelfHostedRunnerGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteArtifactParams(args map[string]string, r *http.Request) (ActionsDeleteArtifactParams, error) {
	var params ActionsDeleteArtifactParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsDeleteEnvironmentSecretParams, error) {
	var params ActionsDeleteEnvironmentSecretParams
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteOrgSecretParams(args map[string]string, r *http.Request) (ActionsDeleteOrgSecretParams, error) {
	var params ActionsDeleteOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteRepoSecretParams(args map[string]string, r *http.Request) (ActionsDeleteRepoSecretParams, error) {
	var params ActionsDeleteRepoSecretParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerFromRepoParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerGroupFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerGroupFromOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunParams(args map[string]string, r *http.Request) (ActionsDeleteWorkflowRunParams, error) {
	var params ActionsDeleteWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunLogsParams(args map[string]string, r *http.Request) (ActionsDeleteWorkflowRunLogsParams, error) {
	var params ActionsDeleteWorkflowRunLogsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadArtifactParams(args map[string]string, r *http.Request) (ActionsDownloadArtifactParams, error) {
	var params ActionsDownloadArtifactParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	// Decode path: archive_format.
	{
		param := args["archive_format"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "archive_format",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ArchiveFormat = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: archive_format: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsDownloadJobLogsForWorkflowRunParams, error) {
	var params ActionsDownloadJobLogsForWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: job_id.
	{
		param := args["job_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: job_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadWorkflowRunLogsParams(args map[string]string, r *http.Request) (ActionsDownloadWorkflowRunLogsParams, error) {
	var params ActionsDownloadWorkflowRunLogsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsGetAllowedActionsOrganizationParams, error) {
	var params ActionsGetAllowedActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsRepositoryParams(args map[string]string, r *http.Request) (ActionsGetAllowedActionsRepositoryParams, error) {
	var params ActionsGetAllowedActionsRepositoryParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetArtifactParams(args map[string]string, r *http.Request) (ActionsGetArtifactParams, error) {
	var params ActionsGetArtifactParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetEnvironmentPublicKeyParams, error) {
	var params ActionsGetEnvironmentPublicKeyParams
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsGetEnvironmentSecretParams, error) {
	var params ActionsGetEnvironmentSecretParams
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(args map[string]string, r *http.Request) (ActionsGetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsGetGithubActionsPermissionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(args map[string]string, r *http.Request) (ActionsGetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsGetGithubActionsPermissionsRepositoryParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetJobForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsGetJobForWorkflowRunParams, error) {
	var params ActionsGetJobForWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: job_id.
	{
		param := args["job_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: job_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetOrgPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetOrgPublicKeyParams, error) {
	var params ActionsGetOrgPublicKeyParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetOrgSecretParams(args map[string]string, r *http.Request) (ActionsGetOrgSecretParams, error) {
	var params ActionsGetOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetRepoPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetRepoPublicKeyParams, error) {
	var params ActionsGetRepoPublicKeyParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetRepoSecretParams(args map[string]string, r *http.Request) (ActionsGetRepoSecretParams, error) {
	var params ActionsGetRepoSecretParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetReviewsForRunParams(args map[string]string, r *http.Request) (ActionsGetReviewsForRunParams, error) {
	var params ActionsGetReviewsForRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForOrgParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForRepoParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerForRepoParams, error) {
	var params ActionsGetSelfHostedRunnerForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunParams(args map[string]string, r *http.Request) (ActionsGetWorkflowRunParams, error) {
	var params ActionsGetWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunUsageParams(args map[string]string, r *http.Request) (ActionsGetWorkflowRunUsageParams, error) {
	var params ActionsGetWorkflowRunUsageParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListArtifactsForRepoParams(args map[string]string, r *http.Request) (ActionsListArtifactsForRepoParams, error) {
	var params ActionsListArtifactsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListEnvironmentSecretsParams(args map[string]string, r *http.Request) (ActionsListEnvironmentSecretsParams, error) {
	var params ActionsListEnvironmentSecretsParams
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListJobsForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsListJobsForWorkflowRunParams, error) {
	var params ActionsListJobsForWorkflowRunParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ActionsListJobsForWorkflowRunFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ActionsListJobsForWorkflowRunFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {

				if params.Filter.Set {
					if err := func() error {

						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListOrgSecretsParams(args map[string]string, r *http.Request) (ActionsListOrgSecretsParams, error) {
	var params ActionsListOrgSecretsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoSecretsParams(args map[string]string, r *http.Request) (ActionsListRepoSecretsParams, error) {
	var params ActionsListRepoSecretsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoWorkflowsParams(args map[string]string, r *http.Request) (ActionsListRepoWorkflowsParams, error) {
	var params ActionsListRepoWorkflowsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForOrgParams(args map[string]string, r *http.Request) (ActionsListRunnerApplicationsForOrgParams, error) {
	var params ActionsListRunnerApplicationsForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForRepoParams(args map[string]string, r *http.Request) (ActionsListRunnerApplicationsForRepoParams, error) {
	var params ActionsListRunnerApplicationsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListSelectedReposForOrgSecretParams(args map[string]string, r *http.Request) (ActionsListSelectedReposForOrgSecretParams, error) {
	var params ActionsListSelectedReposForOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnerGroupsForOrgParams, error) {
	var params ActionsListSelfHostedRunnerGroupsForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersForOrgParams, error) {
	var params ActionsListSelfHostedRunnersForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForRepoParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersForRepoParams, error) {
	var params ActionsListSelfHostedRunnersForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsListSelfHostedRunnersInGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunArtifactsParams(args map[string]string, r *http.Request) (ActionsListWorkflowRunArtifactsParams, error) {
	var params ActionsListWorkflowRunArtifactsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunsForRepoParams(args map[string]string, r *http.Request) (ActionsListWorkflowRunsForRepoParams, error) {
	var params ActionsListWorkflowRunsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: actor.
	{
		values, ok := r.URL.Query()["actor"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsActorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsActorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Actor.SetTo(paramsActorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: actor: parse`)
			}
		}
	}
	// Decode query: branch.
	{
		values, ok := r.URL.Query()["branch"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBranchVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBranchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Branch.SetTo(paramsBranchVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: branch: parse`)
			}
		}
	}
	// Decode query: event.
	{
		values, ok := r.URL.Query()["event"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsEventVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsEventVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Event.SetTo(paramsEventVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: event: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := r.URL.Query()["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ActionsListWorkflowRunsForRepoStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ActionsListWorkflowRunsForRepoStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {

				if params.Status.Set {
					if err := func() error {

						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: created.
	{
		values, ok := r.URL.Query()["created"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCreatedVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsCreatedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Created.SetTo(paramsCreatedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: created: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsReRunWorkflowParams(args map[string]string, r *http.Request) (ActionsReRunWorkflowParams, error) {
	var params ActionsReRunWorkflowParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(args map[string]string, r *http.Request) (ActionsRemoveSelectedRepoFromOrgSecretParams, error) {
	var params ActionsRemoveSelectedRepoFromOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args map[string]string, r *http.Request) (ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, error) {
	var params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRetryWorkflowParams(args map[string]string, r *http.Request) (ActionsRetryWorkflowParams, error) {
	var params ActionsRetryWorkflowParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetAllowedActionsOrganizationParams, error) {
	var params ActionsSetAllowedActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsRepositoryParams(args map[string]string, r *http.Request) (ActionsSetAllowedActionsRepositoryParams, error) {
	var params ActionsSetAllowedActionsRepositoryParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsSetGithubActionsPermissionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(args map[string]string, r *http.Request) (ActionsSetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsSetGithubActionsPermissionsRepositoryParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelectedReposForOrgSecretParams(args map[string]string, r *http.Request) (ActionsSetSelectedReposForOrgSecretParams, error) {
	var params ActionsSetSelectedReposForOrgSecretParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args map[string]string, r *http.Request) (ActionsSetSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsSetSelfHostedRunnersInGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsUpdateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsUpdateSelfHostedRunnerGroupForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityCheckRepoIsStarredByAuthenticatedUserParams, error) {
	var params ActivityCheckRepoIsStarredByAuthenticatedUserParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityDeleteRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivityDeleteRepoSubscriptionParams, error) {
	var params ActivityDeleteRepoSubscriptionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityDeleteThreadSubscriptionParams(args map[string]string, r *http.Request) (ActivityDeleteThreadSubscriptionParams, error) {
	var params ActivityDeleteThreadSubscriptionParams
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivityGetRepoSubscriptionParams, error) {
	var params ActivityGetRepoSubscriptionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetThreadParams(args map[string]string, r *http.Request) (ActivityGetThreadParams, error) {
	var params ActivityGetThreadParams
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityGetThreadSubscriptionForAuthenticatedUserParams, error) {
	var params ActivityGetThreadSubscriptionForAuthenticatedUserParams
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityListEventsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListEventsForAuthenticatedUserParams, error) {
	var params ActivityListEventsForAuthenticatedUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListOrgEventsForAuthenticatedUserParams, error) {
	var params ActivityListOrgEventsForAuthenticatedUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsParams(args map[string]string, r *http.Request) (ActivityListPublicEventsParams, error) {
	var params ActivityListPublicEventsParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForRepoNetworkParams(args map[string]string, r *http.Request) (ActivityListPublicEventsForRepoNetworkParams, error) {
	var params ActivityListPublicEventsForRepoNetworkParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForUserParams(args map[string]string, r *http.Request) (ActivityListPublicEventsForUserParams, error) {
	var params ActivityListPublicEventsForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicOrgEventsParams(args map[string]string, r *http.Request) (ActivityListPublicOrgEventsParams, error) {
	var params ActivityListPublicOrgEventsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedEventsForUserParams(args map[string]string, r *http.Request) (ActivityListReceivedEventsForUserParams, error) {
	var params ActivityListReceivedEventsForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedPublicEventsForUserParams(args map[string]string, r *http.Request) (ActivityListReceivedPublicEventsForUserParams, error) {
	var params ActivityListReceivedPublicEventsForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoEventsParams(args map[string]string, r *http.Request) (ActivityListRepoEventsParams, error) {
	var params ActivityListRepoEventsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListRepoNotificationsForAuthenticatedUserParams, error) {
	var params ActivityListRepoNotificationsForAuthenticatedUserParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: all.
	{
		values, ok := r.URL.Query()["all"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAllVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsAllVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: all: parse`)
			}
		}
	}
	// Decode query: participating.
	{
		values, ok := r.URL.Query()["participating"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsParticipatingVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsParticipatingVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: participating: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := r.URL.Query()["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReposStarredByAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListReposStarredByAuthenticatedUserParams, error) {
	var params ActivityListReposStarredByAuthenticatedUserParams
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ActivityListReposStarredByAuthenticatedUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ActivityListReposStarredByAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ActivityListReposStarredByAuthenticatedUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ActivityListReposStarredByAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReposWatchedByUserParams(args map[string]string, r *http.Request) (ActivityListReposWatchedByUserParams, error) {
	var params ActivityListReposWatchedByUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListWatchedReposForAuthenticatedUserParams, error) {
	var params ActivityListWatchedReposForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchersForRepoParams(args map[string]string, r *http.Request) (ActivityListWatchersForRepoParams, error) {
	var params ActivityListWatchersForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityMarkRepoNotificationsAsReadParams(args map[string]string, r *http.Request) (ActivityMarkRepoNotificationsAsReadParams, error) {
	var params ActivityMarkRepoNotificationsAsReadParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityMarkThreadAsReadParams(args map[string]string, r *http.Request) (ActivityMarkThreadAsReadParams, error) {
	var params ActivityMarkThreadAsReadParams
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivitySetRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivitySetRepoSubscriptionParams, error) {
	var params ActivitySetRepoSubscriptionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivitySetThreadSubscriptionParams(args map[string]string, r *http.Request) (ActivitySetThreadSubscriptionParams, error) {
	var params ActivitySetThreadSubscriptionParams
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityStarRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityStarRepoForAuthenticatedUserParams, error) {
	var params ActivityStarRepoForAuthenticatedUserParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityUnstarRepoForAuthenticatedUserParams, error) {
	var params ActivityUnstarRepoForAuthenticatedUserParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeAppsAddRepoToInstallationParams(args map[string]string, r *http.Request) (AppsAddRepoToInstallationParams, error) {
	var params AppsAddRepoToInstallationParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsDeleteInstallationParams(args map[string]string, r *http.Request) (AppsDeleteInstallationParams, error) {
	var params AppsDeleteInstallationParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetBySlugParams(args map[string]string, r *http.Request) (AppsGetBySlugParams, error) {
	var params AppsGetBySlugParams
	// Decode path: app_slug.
	{
		param := args["app_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "app_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.AppSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: app_slug: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountParams(args map[string]string, r *http.Request) (AppsGetSubscriptionPlanForAccountParams, error) {
	var params AppsGetSubscriptionPlanForAccountParams
	// Decode path: account_id.
	{
		param := args["account_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: account_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(args map[string]string, r *http.Request) (AppsGetSubscriptionPlanForAccountStubbedParams, error) {
	var params AppsGetSubscriptionPlanForAccountStubbedParams
	// Decode path: account_id.
	{
		param := args["account_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: account_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsListAccountsForPlanStubbedParams(args map[string]string, r *http.Request) (AppsListAccountsForPlanStubbedParams, error) {
	var params AppsListAccountsForPlanStubbedParams
	// Decode path: plan_id.
	{
		param := args["plan_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: plan_id: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal AppsListAccountsForPlanStubbedSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = AppsListAccountsForPlanStubbedSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal AppsListAccountsForPlanStubbedDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = AppsListAccountsForPlanStubbedDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(args map[string]string, r *http.Request) (AppsListInstallationReposForAuthenticatedUserParams, error) {
	var params AppsListInstallationReposForAuthenticatedUserParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansParams(args map[string]string, r *http.Request) (AppsListPlansParams, error) {
	var params AppsListPlansParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansStubbedParams(args map[string]string, r *http.Request) (AppsListPlansStubbedParams, error) {
	var params AppsListPlansStubbedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListReposAccessibleToInstallationParams(args map[string]string, r *http.Request) (AppsListReposAccessibleToInstallationParams, error) {
	var params AppsListReposAccessibleToInstallationParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(args map[string]string, r *http.Request) (AppsListSubscriptionsForAuthenticatedUserParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args map[string]string, r *http.Request) (AppsListSubscriptionsForAuthenticatedUserStubbedParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserStubbedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsRemoveRepoFromInstallationParams(args map[string]string, r *http.Request) (AppsRemoveRepoFromInstallationParams, error) {
	var params AppsRemoveRepoFromInstallationParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsSuspendInstallationParams(args map[string]string, r *http.Request) (AppsSuspendInstallationParams, error) {
	var params AppsSuspendInstallationParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsUnsuspendInstallationParams(args map[string]string, r *http.Request) (AppsUnsuspendInstallationParams, error) {
	var params AppsUnsuspendInstallationParams
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingGheParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingGheParams, error) {
	var params BillingGetGithubActionsBillingGheParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingOrgParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingOrgParams, error) {
	var params BillingGetGithubActionsBillingOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingUserParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingUserParams, error) {
	var params BillingGetGithubActionsBillingUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingGheParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingGheParams, error) {
	var params BillingGetGithubPackagesBillingGheParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingOrgParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingOrgParams, error) {
	var params BillingGetGithubPackagesBillingOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingUserParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingUserParams, error) {
	var params BillingGetGithubPackagesBillingUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingGheParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingGheParams, error) {
	var params BillingGetSharedStorageBillingGheParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingOrgParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingOrgParams, error) {
	var params BillingGetSharedStorageBillingOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingUserParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingUserParams, error) {
	var params BillingGetSharedStorageBillingUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeChecksCreateSuiteParams(args map[string]string, r *http.Request) (ChecksCreateSuiteParams, error) {
	var params ChecksCreateSuiteParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeChecksGetParams(args map[string]string, r *http.Request) (ChecksGetParams, error) {
	var params ChecksGetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_run_id.
	{
		param := args["check_run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_run_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksGetSuiteParams(args map[string]string, r *http.Request) (ChecksGetSuiteParams, error) {
	var params ChecksGetSuiteParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksListAnnotationsParams(args map[string]string, r *http.Request) (ChecksListAnnotationsParams, error) {
	var params ChecksListAnnotationsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_run_id.
	{
		param := args["check_run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_run_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListForRefParams(args map[string]string, r *http.Request) (ChecksListForRefParams, error) {
	var params ChecksListForRefParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: check_name.
	{
		values, ok := r.URL.Query()["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := r.URL.Query()["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ChecksListForRefStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ChecksListForRefStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {

				if params.Status.Set {
					if err := func() error {

						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ChecksListForRefFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ChecksListForRefFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {

				if params.Filter.Set {
					if err := func() error {

						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: app_id.
	{
		values, ok := r.URL.Query()["app_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAppIDVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsAppIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: app_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListForSuiteParams(args map[string]string, r *http.Request) (ChecksListForSuiteParams, error) {
	var params ChecksListForSuiteParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	// Decode query: check_name.
	{
		values, ok := r.URL.Query()["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := r.URL.Query()["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ChecksListForSuiteStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ChecksListForSuiteStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {

				if params.Status.Set {
					if err := func() error {

						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ChecksListForSuiteFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ChecksListForSuiteFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {

				if params.Filter.Set {
					if err := func() error {

						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListSuitesForRefParams(args map[string]string, r *http.Request) (ChecksListSuitesForRefParams, error) {
	var params ChecksListSuitesForRefParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: app_id.
	{
		values, ok := r.URL.Query()["app_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAppIDVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsAppIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: app_id: parse`)
			}
		}
	}
	// Decode query: check_name.
	{
		values, ok := r.URL.Query()["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksRerequestSuiteParams(args map[string]string, r *http.Request) (ChecksRerequestSuiteParams, error) {
	var params ChecksRerequestSuiteParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksSetSuitesPreferencesParams(args map[string]string, r *http.Request) (ChecksSetSuitesPreferencesParams, error) {
	var params ChecksSetSuitesPreferencesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningDeleteAnalysisParams(args map[string]string, r *http.Request) (CodeScanningDeleteAnalysisParams, error) {
	var params CodeScanningDeleteAnalysisParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: analysis_id.
	{
		param := args["analysis_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: analysis_id: not specified`)
		}
	}
	// Decode query: confirm_delete.
	{
		values, ok := r.URL.Query()["confirm_delete"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsConfirmDeleteVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsConfirmDeleteVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ConfirmDelete.SetTo(paramsConfirmDeleteVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: confirm_delete: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningGetAlertParams(args map[string]string, r *http.Request) (CodeScanningGetAlertParams, error) {
	var params CodeScanningGetAlertParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningGetAnalysisParams(args map[string]string, r *http.Request) (CodeScanningGetAnalysisParams, error) {
	var params CodeScanningGetAnalysisParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: analysis_id.
	{
		param := args["analysis_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: analysis_id: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningGetSarifParams(args map[string]string, r *http.Request) (CodeScanningGetSarifParams, error) {
	var params CodeScanningGetSarifParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: sarif_id.
	{
		param := args["sarif_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sarif_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SarifID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: sarif_id: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertInstancesParams(args map[string]string, r *http.Request) (CodeScanningListAlertInstancesParams, error) {
	var params CodeScanningListAlertInstancesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := r.URL.Query()["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertsForRepoParams(args map[string]string, r *http.Request) (CodeScanningListAlertsForRepoParams, error) {
	var params CodeScanningListAlertsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: tool_name.
	{
		values, ok := r.URL.Query()["tool_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsToolNameValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolNameVal = CodeScanningAnalysisToolName(paramsToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsToolNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_name: parse`)
			}
		}
	}
	// Decode query: tool_guid.
	{
		values, ok := r.URL.Query()["tool_guid"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsToolGUIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolGUIDVal = CodeScanningAnalysisToolGUID(paramsToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsToolGUIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_guid: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := r.URL.Query()["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal CodeScanningAlertState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = CodeScanningAlertState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListRecentAnalysesParams(args map[string]string, r *http.Request) (CodeScanningListRecentAnalysesParams, error) {
	var params CodeScanningListRecentAnalysesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: tool_name.
	{
		values, ok := r.URL.Query()["tool_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsToolNameValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolNameVal = CodeScanningAnalysisToolName(paramsToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsToolNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_name: parse`)
			}
		}
	}
	// Decode query: tool_guid.
	{
		values, ok := r.URL.Query()["tool_guid"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsToolGUIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolGUIDVal = CodeScanningAnalysisToolGUID(paramsToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsToolGUIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_guid: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := r.URL.Query()["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	// Decode query: sarif_id.
	{
		values, ok := r.URL.Query()["sarif_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSarifIDVal CodeScanningAnalysisSarifID
				if err := func() error {
					var paramsSarifIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsSarifIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsSarifIDVal = CodeScanningAnalysisSarifID(paramsSarifIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.SarifID.SetTo(paramsSarifIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sarif_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningUpdateAlertParams(args map[string]string, r *http.Request) (CodeScanningUpdateAlertParams, error) {
	var params CodeScanningUpdateAlertParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningUploadSarifParams(args map[string]string, r *http.Request) (CodeScanningUploadSarifParams, error) {
	var params CodeScanningUploadSarifParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeCodesOfConductGetConductCodeParams(args map[string]string, r *http.Request) (CodesOfConductGetConductCodeParams, error) {
	var params CodesOfConductGetConductCodeParams
	// Decode path: key.
	{
		param := args["key"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, error) {
	var params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateRemoveTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRemoveTokenForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteScimGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteScimGroupFromEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteUserFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteUserFromEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminGetAllowedActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAuditLogParams(args map[string]string, r *http.Request) (EnterpriseAdminGetAuditLogParams, error) {
	var params EnterpriseAdminGetAuditLogParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: phrase.
	{
		values, ok := r.URL.Query()["phrase"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPhraseVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsPhraseVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: phrase: parse`)
			}
		}
	}
	// Decode query: include.
	{
		values, ok := r.URL.Query()["include"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsIncludeVal EnterpriseAdminGetAuditLogInclude
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsIncludeVal = EnterpriseAdminGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsIncludeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: parse`)
			}
			if err := func() error {

				if params.Include.Set {
					if err := func() error {

						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: invalid`)
			}
		}
	}
	// Decode query: after.
	{
		values, ok := r.URL.Query()["after"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAfterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsAfterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: after: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := r.URL.Query()["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := r.URL.Query()["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal EnterpriseAdminGetAuditLogOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = EnterpriseAdminGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {

				if params.Order.Set {
					if err := func() error {

						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	// Decode query: excludedAttributes.
	{
		values, ok := r.URL.Query()["excludedAttributes"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsExcludedAttributesVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsExcludedAttributesVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: excludedAttributes: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListProvisionedGroupsEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedGroupsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: startIndex.
	{
		values, ok := r.URL.Query()["startIndex"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStartIndexVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsStartIndexVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: startIndex: parse`)
			}
		}
	}
	// Decode query: count.
	{
		values, ok := r.URL.Query()["count"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCountVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsCountVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: count: parse`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
		}
	}
	// Decode query: excludedAttributes.
	{
		values, ok := r.URL.Query()["excludedAttributes"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsExcludedAttributesVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsExcludedAttributesVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: excludedAttributes: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: startIndex.
	{
		values, ok := r.URL.Query()["startIndex"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStartIndexVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsStartIndexVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: startIndex: parse`)
			}
		}
	}
	// Decode query: count.
	{
		values, ok := r.URL.Query()["count"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCountVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsCountVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: count: parse`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListRunnerApplicationsForEnterpriseParams, error) {
	var params EnterpriseAdminListRunnerApplicationsForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseUserParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseUserParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, error) {
	var params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetAllowedActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseUserParams, error) {
	var params EnterpriseAdminUpdateAttributeForEnterpriseUserParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsCheckIsStarredParams(args map[string]string, r *http.Request) (GistsCheckIsStarredParams, error) {
	var params GistsCheckIsStarredParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsCreateCommentParams(args map[string]string, r *http.Request) (GistsCreateCommentParams, error) {
	var params GistsCreateCommentParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsDeleteParams(args map[string]string, r *http.Request) (GistsDeleteParams, error) {
	var params GistsDeleteParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsDeleteCommentParams(args map[string]string, r *http.Request) (GistsDeleteCommentParams, error) {
	var params GistsDeleteCommentParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsGetParams(args map[string]string, r *http.Request) (GistsGetParams, error) {
	var params GistsGetParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsGetCommentParams(args map[string]string, r *http.Request) (GistsGetCommentParams, error) {
	var params GistsGetCommentParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsListParams(args map[string]string, r *http.Request) (GistsListParams, error) {
	var params GistsListParams
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListCommentsParams(args map[string]string, r *http.Request) (GistsListCommentsParams, error) {
	var params GistsListCommentsParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListCommitsParams(args map[string]string, r *http.Request) (GistsListCommitsParams, error) {
	var params GistsListCommitsParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListForksParams(args map[string]string, r *http.Request) (GistsListForksParams, error) {
	var params GistsListForksParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListStarredParams(args map[string]string, r *http.Request) (GistsListStarredParams, error) {
	var params GistsListStarredParams
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsStarParams(args map[string]string, r *http.Request) (GistsStarParams, error) {
	var params GistsStarParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsUnstarParams(args map[string]string, r *http.Request) (GistsUnstarParams, error) {
	var params GistsUnstarParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsUpdateCommentParams(args map[string]string, r *http.Request) (GistsUpdateCommentParams, error) {
	var params GistsUpdateCommentParams
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetCommitParams(args map[string]string, r *http.Request) (GitGetCommitParams, error) {
	var params GitGetCommitParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetRefParams(args map[string]string, r *http.Request) (GitGetRefParams, error) {
	var params GitGetRefParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetTagParams(args map[string]string, r *http.Request) (GitGetTagParams, error) {
	var params GitGetTagParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: tag_sha.
	{
		param := args["tag_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TagSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: tag_sha: not specified`)
		}
	}
	return params, nil
}

func decodeGitListMatchingRefsParams(args map[string]string, r *http.Request) (GitListMatchingRefsParams, error) {
	var params GitListMatchingRefsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGitignoreGetTemplateParams(args map[string]string, r *http.Request) (GitignoreGetTemplateParams, error) {
	var params GitignoreGetTemplateParams
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForOrgParams(args map[string]string, r *http.Request) (InteractionsRemoveRestrictionsForOrgParams, error) {
	var params InteractionsRemoveRestrictionsForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForRepoParams(args map[string]string, r *http.Request) (InteractionsRemoveRestrictionsForRepoParams, error) {
	var params InteractionsRemoveRestrictionsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsSetRestrictionsForRepoParams(args map[string]string, r *http.Request) (InteractionsSetRestrictionsForRepoParams, error) {
	var params InteractionsSetRestrictionsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesAddAssigneesParams(args map[string]string, r *http.Request) (IssuesAddAssigneesParams, error) {
	var params IssuesAddAssigneesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCheckUserCanBeAssignedParams(args map[string]string, r *http.Request) (IssuesCheckUserCanBeAssignedParams, error) {
	var params IssuesCheckUserCanBeAssignedParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: assignee.
	{
		param := args["assignee"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assignee",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Assignee = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: assignee: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteCommentParams(args map[string]string, r *http.Request) (IssuesDeleteCommentParams, error) {
	var params IssuesDeleteCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteLabelParams(args map[string]string, r *http.Request) (IssuesDeleteLabelParams, error) {
	var params IssuesDeleteLabelParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteMilestoneParams(args map[string]string, r *http.Request) (IssuesDeleteMilestoneParams, error) {
	var params IssuesDeleteMilestoneParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetCommentParams(args map[string]string, r *http.Request) (IssuesGetCommentParams, error) {
	var params IssuesGetCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetEventParams(args map[string]string, r *http.Request) (IssuesGetEventParams, error) {
	var params IssuesGetEventParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: event_id.
	{
		param := args["event_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: event_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetLabelParams(args map[string]string, r *http.Request) (IssuesGetLabelParams, error) {
	var params IssuesGetLabelParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetMilestoneParams(args map[string]string, r *http.Request) (IssuesGetMilestoneParams, error) {
	var params IssuesGetMilestoneParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesListAssigneesParams(args map[string]string, r *http.Request) (IssuesListAssigneesParams, error) {
	var params IssuesListAssigneesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListCommentsParams(args map[string]string, r *http.Request) (IssuesListCommentsParams, error) {
	var params IssuesListCommentsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForMilestoneParams(args map[string]string, r *http.Request) (IssuesListLabelsForMilestoneParams, error) {
	var params IssuesListLabelsForMilestoneParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForRepoParams(args map[string]string, r *http.Request) (IssuesListLabelsForRepoParams, error) {
	var params IssuesListLabelsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsOnIssueParams(args map[string]string, r *http.Request) (IssuesListLabelsOnIssueParams, error) {
	var params IssuesListLabelsOnIssueParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListMilestonesParams(args map[string]string, r *http.Request) (IssuesListMilestonesParams, error) {
	var params IssuesListMilestonesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListMilestonesState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListMilestonesState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListMilestonesSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListMilestonesSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListMilestonesDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListMilestonesDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesRemoveAllLabelsParams(args map[string]string, r *http.Request) (IssuesRemoveAllLabelsParams, error) {
	var params IssuesRemoveAllLabelsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesRemoveAssigneesParams(args map[string]string, r *http.Request) (IssuesRemoveAssigneesParams, error) {
	var params IssuesRemoveAssigneesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesRemoveLabelParams(args map[string]string, r *http.Request) (IssuesRemoveLabelParams, error) {
	var params IssuesRemoveLabelParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUnlockParams(args map[string]string, r *http.Request) (IssuesUnlockParams, error) {
	var params IssuesUnlockParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateLabelParams(args map[string]string, r *http.Request) (IssuesUpdateLabelParams, error) {
	var params IssuesUpdateLabelParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateMilestoneParams(args map[string]string, r *http.Request) (IssuesUpdateMilestoneParams, error) {
	var params IssuesUpdateMilestoneParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeLicensesGetParams(args map[string]string, r *http.Request) (LicensesGetParams, error) {
	var params LicensesGetParams
	// Decode path: license.
	{
		param := args["license"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "license",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.License = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: license: not specified`)
		}
	}
	return params, nil
}

func decodeLicensesGetAllCommonlyUsedParams(args map[string]string, r *http.Request) (LicensesGetAllCommonlyUsedParams, error) {
	var params LicensesGetAllCommonlyUsedParams
	// Decode query: featured.
	{
		values, ok := r.URL.Query()["featured"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFeaturedVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsFeaturedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Featured.SetTo(paramsFeaturedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: featured: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeLicensesGetForRepoParams(args map[string]string, r *http.Request) (LicensesGetForRepoParams, error) {
	var params LicensesGetForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsCancelImportParams(args map[string]string, r *http.Request) (MigrationsCancelImportParams, error) {
	var params MigrationsCancelImportParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsDeleteArchiveForAuthenticatedUserParams, error) {
	var params MigrationsDeleteArchiveForAuthenticatedUserParams
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForOrgParams(args map[string]string, r *http.Request) (MigrationsDeleteArchiveForOrgParams, error) {
	var params MigrationsDeleteArchiveForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDownloadArchiveForOrgParams(args map[string]string, r *http.Request) (MigrationsDownloadArchiveForOrgParams, error) {
	var params MigrationsDownloadArchiveForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsGetArchiveForAuthenticatedUserParams, error) {
	var params MigrationsGetArchiveForAuthenticatedUserParams
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetCommitAuthorsParams(args map[string]string, r *http.Request) (MigrationsGetCommitAuthorsParams, error) {
	var params MigrationsGetCommitAuthorsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetImportStatusParams(args map[string]string, r *http.Request) (MigrationsGetImportStatusParams, error) {
	var params MigrationsGetImportStatusParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetLargeFilesParams(args map[string]string, r *http.Request) (MigrationsGetLargeFilesParams, error) {
	var params MigrationsGetLargeFilesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsGetStatusForAuthenticatedUserParams, error) {
	var params MigrationsGetStatusForAuthenticatedUserParams
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: exclude.
	{
		values, ok := r.URL.Query()["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForOrgParams(args map[string]string, r *http.Request) (MigrationsGetStatusForOrgParams, error) {
	var params MigrationsGetStatusForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: exclude.
	{
		values, ok := r.URL.Query()["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal MigrationsGetStatusForOrgExcludeItem
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = MigrationsGetStatusForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
			if err := func() error {

				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {

						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: invalid`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsListForAuthenticatedUserParams, error) {
	var params MigrationsListForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForOrgParams(args map[string]string, r *http.Request) (MigrationsListForOrgParams, error) {
	var params MigrationsListForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: exclude.
	{
		values, ok := r.URL.Query()["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal MigrationsListForOrgExcludeItem
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = MigrationsListForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
			if err := func() error {

				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {

						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: invalid`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForOrgParams(args map[string]string, r *http.Request) (MigrationsListReposForOrgParams, error) {
	var params MigrationsListReposForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForUserParams(args map[string]string, r *http.Request) (MigrationsListReposForUserParams, error) {
	var params MigrationsListReposForUserParams
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsUnlockRepoForAuthenticatedUserParams, error) {
	var params MigrationsUnlockRepoForAuthenticatedUserParams
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode path: repo_name.
	{
		param := args["repo_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo_name: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForOrgParams(args map[string]string, r *http.Request) (MigrationsUnlockRepoForOrgParams, error) {
	var params MigrationsUnlockRepoForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode path: repo_name.
	{
		param := args["repo_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo_name: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsUpdateImportParams(args map[string]string, r *http.Request) (MigrationsUpdateImportParams, error) {
	var params MigrationsUpdateImportParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(args map[string]string, r *http.Request) (OAuthAuthorizationsDeleteAuthorizationParams, error) {
	var params OAuthAuthorizationsDeleteAuthorizationParams
	// Decode path: authorization_id.
	{
		param := args["authorization_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: authorization_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteGrantParams(args map[string]string, r *http.Request) (OAuthAuthorizationsDeleteGrantParams, error) {
	var params OAuthAuthorizationsDeleteGrantParams
	// Decode path: grant_id.
	{
		param := args["grant_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: grant_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetAuthorizationParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetAuthorizationParams, error) {
	var params OAuthAuthorizationsGetAuthorizationParams
	// Decode path: authorization_id.
	{
		param := args["authorization_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: authorization_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetGrantParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetGrantParams, error) {
	var params OAuthAuthorizationsGetGrantParams
	// Decode path: grant_id.
	{
		param := args["grant_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: grant_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListAuthorizationsParams(args map[string]string, r *http.Request) (OAuthAuthorizationsListAuthorizationsParams, error) {
	var params OAuthAuthorizationsListAuthorizationsParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: client_id.
	{
		values, ok := r.URL.Query()["client_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsClientIDVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsClientIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: client_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListGrantsParams(args map[string]string, r *http.Request) (OAuthAuthorizationsListGrantsParams, error) {
	var params OAuthAuthorizationsListGrantsParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: client_id.
	{
		values, ok := r.URL.Query()["client_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsClientIDVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsClientIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: client_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsCheckBlockedUserParams(args map[string]string, r *http.Request) (OrgsCheckBlockedUserParams, error) {
	var params OrgsCheckBlockedUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCheckMembershipForUserParams(args map[string]string, r *http.Request) (OrgsCheckMembershipForUserParams, error) {
	var params OrgsCheckMembershipForUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCheckPublicMembershipForUserParams(args map[string]string, r *http.Request) (OrgsCheckPublicMembershipForUserParams, error) {
	var params OrgsCheckPublicMembershipForUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(args map[string]string, r *http.Request) (OrgsConvertMemberToOutsideCollaboratorParams, error) {
	var params OrgsConvertMemberToOutsideCollaboratorParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsDeleteWebhookParams(args map[string]string, r *http.Request) (OrgsDeleteWebhookParams, error) {
	var params OrgsDeleteWebhookParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetParams(args map[string]string, r *http.Request) (OrgsGetParams, error) {
	var params OrgsGetParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetAuditLogParams(args map[string]string, r *http.Request) (OrgsGetAuditLogParams, error) {
	var params OrgsGetAuditLogParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: phrase.
	{
		values, ok := r.URL.Query()["phrase"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPhraseVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsPhraseVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: phrase: parse`)
			}
		}
	}
	// Decode query: include.
	{
		values, ok := r.URL.Query()["include"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsIncludeVal OrgsGetAuditLogInclude
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsIncludeVal = OrgsGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsIncludeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: parse`)
			}
			if err := func() error {

				if params.Include.Set {
					if err := func() error {

						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: invalid`)
			}
		}
	}
	// Decode query: after.
	{
		values, ok := r.URL.Query()["after"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAfterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsAfterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: after: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := r.URL.Query()["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := r.URL.Query()["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal OrgsGetAuditLogOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = OrgsGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {

				if params.Order.Set {
					if err := func() error {

						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsGetMembershipForAuthenticatedUserParams, error) {
	var params OrgsGetMembershipForAuthenticatedUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForUserParams(args map[string]string, r *http.Request) (OrgsGetMembershipForUserParams, error) {
	var params OrgsGetMembershipForUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookParams(args map[string]string, r *http.Request) (OrgsGetWebhookParams, error) {
	var params OrgsGetWebhookParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookConfigForOrgParams(args map[string]string, r *http.Request) (OrgsGetWebhookConfigForOrgParams, error) {
	var params OrgsGetWebhookConfigForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListParams(args map[string]string, r *http.Request) (OrgsListParams, error) {
	var params OrgsListParams
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListBlockedUsersParams(args map[string]string, r *http.Request) (OrgsListBlockedUsersParams, error) {
	var params OrgsListBlockedUsersParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListFailedInvitationsParams(args map[string]string, r *http.Request) (OrgsListFailedInvitationsParams, error) {
	var params OrgsListFailedInvitationsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsListForAuthenticatedUserParams, error) {
	var params OrgsListForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListForUserParams(args map[string]string, r *http.Request) (OrgsListForUserParams, error) {
	var params OrgsListForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListInvitationTeamsParams(args map[string]string, r *http.Request) (OrgsListInvitationTeamsParams, error) {
	var params OrgsListInvitationTeamsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListOutsideCollaboratorsParams(args map[string]string, r *http.Request) (OrgsListOutsideCollaboratorsParams, error) {
	var params OrgsListOutsideCollaboratorsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := r.URL.Query()["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal OrgsListOutsideCollaboratorsFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = OrgsListOutsideCollaboratorsFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {

				if params.Filter.Set {
					if err := func() error {

						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListPendingInvitationsParams(args map[string]string, r *http.Request) (OrgsListPendingInvitationsParams, error) {
	var params OrgsListPendingInvitationsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListPublicMembersParams(args map[string]string, r *http.Request) (OrgsListPublicMembersParams, error) {
	var params OrgsListPublicMembersParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListSamlSSOAuthorizationsParams(args map[string]string, r *http.Request) (OrgsListSamlSSOAuthorizationsParams, error) {
	var params OrgsListSamlSSOAuthorizationsParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListWebhooksParams(args map[string]string, r *http.Request) (OrgsListWebhooksParams, error) {
	var params OrgsListWebhooksParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsPingWebhookParams(args map[string]string, r *http.Request) (OrgsPingWebhookParams, error) {
	var params OrgsPingWebhookParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveMemberParams(args map[string]string, r *http.Request) (OrgsRemoveMemberParams, error) {
	var params OrgsRemoveMemberParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveMembershipForUserParams(args map[string]string, r *http.Request) (OrgsRemoveMembershipForUserParams, error) {
	var params OrgsRemoveMembershipForUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveOutsideCollaboratorParams(args map[string]string, r *http.Request) (OrgsRemoveOutsideCollaboratorParams, error) {
	var params OrgsRemoveOutsideCollaboratorParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsRemovePublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsRemovePublicMembershipForAuthenticatedUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(args map[string]string, r *http.Request) (OrgsRemoveSamlSSOAuthorizationParams, error) {
	var params OrgsRemoveSamlSSOAuthorizationParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: credential_id.
	{
		param := args["credential_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "credential_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CredentialID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: credential_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsSetPublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsSetPublicMembershipForAuthenticatedUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUnblockUserParams(args map[string]string, r *http.Request) (OrgsUnblockUserParams, error) {
	var params OrgsUnblockUserParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUpdateWebhookConfigForOrgParams(args map[string]string, r *http.Request) (OrgsUpdateWebhookConfigForOrgParams, error) {
	var params OrgsUpdateWebhookConfigForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageForAuthenticatedUserParams, error) {
	var params PackagesDeletePackageForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForOrgParams(args map[string]string, r *http.Request) (PackagesDeletePackageForOrgParams, error) {
	var params PackagesDeletePackageForOrgParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageForUserParams, error) {
	var params PackagesDeletePackageForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForAuthenticatedUserParams, error) {
	var params PackagesDeletePackageVersionForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForOrgParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForOrgParams, error) {
	var params PackagesDeletePackageVersionForOrgParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForUserParams, error) {
	var params PackagesDeletePackageVersionForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByOrgParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal PackagesGetAllPackageVersionsForPackageOwnedByOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByUserParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetPackageForAuthenticatedUserParams, error) {
	var params PackagesGetPackageForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForOrganizationParams(args map[string]string, r *http.Request) (PackagesGetPackageForOrganizationParams, error) {
	var params PackagesGetPackageForOrganizationParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForUserParams(args map[string]string, r *http.Request) (PackagesGetPackageForUserParams, error) {
	var params PackagesGetPackageForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForAuthenticatedUserParams, error) {
	var params PackagesGetPackageVersionForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForOrganizationParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForOrganizationParams, error) {
	var params PackagesGetPackageVersionForOrganizationParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForUserParams, error) {
	var params PackagesGetPackageVersionForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesListPackagesForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesListPackagesForAuthenticatedUserParams, error) {
	var params PackagesListPackagesForAuthenticatedUserParams
	// Decode query: package_type.
	{
		values, ok := r.URL.Query()["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {

				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := r.URL.Query()["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForAuthenticatedUserVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {

				if params.Visibility.Set {
					if err := func() error {

						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForOrganizationParams(args map[string]string, r *http.Request) (PackagesListPackagesForOrganizationParams, error) {
	var params PackagesListPackagesForOrganizationParams
	// Decode query: package_type.
	{
		values, ok := r.URL.Query()["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {

				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := r.URL.Query()["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForOrganizationVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForOrganizationVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {

				if params.Visibility.Set {
					if err := func() error {

						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForUserParams(args map[string]string, r *http.Request) (PackagesListPackagesForUserParams, error) {
	var params PackagesListPackagesForUserParams
	// Decode query: package_type.
	{
		values, ok := r.URL.Query()["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {

				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := r.URL.Query()["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForUserVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {

				if params.Visibility.Set {
					if err := func() error {

						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageForAuthenticatedUserParams, error) {
	var params PackagesRestorePackageForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := r.URL.Query()["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForOrgParams(args map[string]string, r *http.Request) (PackagesRestorePackageForOrgParams, error) {
	var params PackagesRestorePackageForOrgParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := r.URL.Query()["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageForUserParams, error) {
	var params PackagesRestorePackageForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := r.URL.Query()["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForAuthenticatedUserParams, error) {
	var params PackagesRestorePackageVersionForAuthenticatedUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForOrgParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForOrgParams, error) {
	var params PackagesRestorePackageVersionForOrgParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForUserParams, error) {
	var params PackagesRestorePackageVersionForUserParams
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateColumnParams(args map[string]string, r *http.Request) (ProjectsCreateColumnParams, error) {
	var params ProjectsCreateColumnParams
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateForOrgParams(args map[string]string, r *http.Request) (ProjectsCreateForOrgParams, error) {
	var params ProjectsCreateForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateForRepoParams(args map[string]string, r *http.Request) (ProjectsCreateForRepoParams, error) {
	var params ProjectsCreateForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteParams(args map[string]string, r *http.Request) (ProjectsDeleteParams, error) {
	var params ProjectsDeleteParams
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteCardParams(args map[string]string, r *http.Request) (ProjectsDeleteCardParams, error) {
	var params ProjectsDeleteCardParams
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteColumnParams(args map[string]string, r *http.Request) (ProjectsDeleteColumnParams, error) {
	var params ProjectsDeleteColumnParams
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetParams(args map[string]string, r *http.Request) (ProjectsGetParams, error) {
	var params ProjectsGetParams
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetCardParams(args map[string]string, r *http.Request) (ProjectsGetCardParams, error) {
	var params ProjectsGetCardParams
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetColumnParams(args map[string]string, r *http.Request) (ProjectsGetColumnParams, error) {
	var params ProjectsGetColumnParams
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsListCardsParams(args map[string]string, r *http.Request) (ProjectsListCardsParams, error) {
	var params ProjectsListCardsParams
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	// Decode query: archived_state.
	{
		values, ok := r.URL.Query()["archived_state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsArchivedStateVal ProjectsListCardsArchivedState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsArchivedStateVal = ProjectsListCardsArchivedState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.ArchivedState.SetTo(paramsArchivedStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: archived_state: parse`)
			}
			if err := func() error {

				if params.ArchivedState.Set {
					if err := func() error {

						if err := params.ArchivedState.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: archived_state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListColumnsParams(args map[string]string, r *http.Request) (ProjectsListColumnsParams, error) {
	var params ProjectsListColumnsParams
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListForOrgParams(args map[string]string, r *http.Request) (ProjectsListForOrgParams, error) {
	var params ProjectsListForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal ProjectsListForOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = ProjectsListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListForRepoParams(args map[string]string, r *http.Request) (ProjectsListForRepoParams, error) {
	var params ProjectsListForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal ProjectsListForRepoState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = ProjectsListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsMoveColumnParams(args map[string]string, r *http.Request) (ProjectsMoveColumnParams, error) {
	var params ProjectsMoveColumnParams
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateParams(args map[string]string, r *http.Request) (ProjectsUpdateParams, error) {
	var params ProjectsUpdateParams
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateCardParams(args map[string]string, r *http.Request) (ProjectsUpdateCardParams, error) {
	var params ProjectsUpdateCardParams
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateColumnParams(args map[string]string, r *http.Request) (ProjectsUpdateColumnParams, error) {
	var params ProjectsUpdateColumnParams
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsCheckIfMergedParams(args map[string]string, r *http.Request) (PullsCheckIfMergedParams, error) {
	var params PullsCheckIfMergedParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateReplyForReviewCommentParams(args map[string]string, r *http.Request) (PullsCreateReplyForReviewCommentParams, error) {
	var params PullsCreateReplyForReviewCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateReviewParams(args map[string]string, r *http.Request) (PullsCreateReviewParams, error) {
	var params PullsCreateReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsDeletePendingReviewParams(args map[string]string, r *http.Request) (PullsDeletePendingReviewParams, error) {
	var params PullsDeletePendingReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsDeleteReviewCommentParams(args map[string]string, r *http.Request) (PullsDeleteReviewCommentParams, error) {
	var params PullsDeleteReviewCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsDismissReviewParams(args map[string]string, r *http.Request) (PullsDismissReviewParams, error) {
	var params PullsDismissReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetParams(args map[string]string, r *http.Request) (PullsGetParams, error) {
	var params PullsGetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetReviewParams(args map[string]string, r *http.Request) (PullsGetReviewParams, error) {
	var params PullsGetReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetReviewCommentParams(args map[string]string, r *http.Request) (PullsGetReviewCommentParams, error) {
	var params PullsGetReviewCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsListCommentsForReviewParams(args map[string]string, r *http.Request) (PullsListCommentsForReviewParams, error) {
	var params PullsListCommentsForReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListCommitsParams(args map[string]string, r *http.Request) (PullsListCommitsParams, error) {
	var params PullsListCommitsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListRequestedReviewersParams(args map[string]string, r *http.Request) (PullsListRequestedReviewersParams, error) {
	var params PullsListRequestedReviewersParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsParams(args map[string]string, r *http.Request) (PullsListReviewCommentsParams, error) {
	var params PullsListReviewCommentsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal PullsListReviewCommentsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = PullsListReviewCommentsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal PullsListReviewCommentsDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = PullsListReviewCommentsDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsForRepoParams(args map[string]string, r *http.Request) (PullsListReviewCommentsForRepoParams, error) {
	var params PullsListReviewCommentsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal PullsListReviewCommentsForRepoSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = PullsListReviewCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal PullsListReviewCommentsForRepoDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = PullsListReviewCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewsParams(args map[string]string, r *http.Request) (PullsListReviewsParams, error) {
	var params PullsListReviewsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsSubmitReviewParams(args map[string]string, r *http.Request) (PullsSubmitReviewParams, error) {
	var params PullsSubmitReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateReviewParams(args map[string]string, r *http.Request) (PullsUpdateReviewParams, error) {
	var params PullsUpdateReviewParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateReviewCommentParams(args map[string]string, r *http.Request) (PullsUpdateReviewCommentParams, error) {
	var params PullsUpdateReviewCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionCommentInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionCommentLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForCommitCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForCommitCommentParams, error) {
	var params ReactionsDeleteForCommitCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueParams(args map[string]string, r *http.Request) (ReactionsDeleteForIssueParams, error) {
	var params ReactionsDeleteForIssueParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForIssueCommentParams, error) {
	var params ReactionsDeleteForIssueCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForPullRequestCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForPullRequestCommentParams, error) {
	var params ReactionsDeleteForPullRequestCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionParams(args map[string]string, r *http.Request) (ReactionsDeleteForTeamDiscussionParams, error) {
	var params ReactionsDeleteForTeamDiscussionParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForTeamDiscussionCommentParams, error) {
	var params ReactionsDeleteForTeamDiscussionCommentParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteLegacyParams(args map[string]string, r *http.Request) (ReactionsDeleteLegacyParams, error) {
	var params ReactionsDeleteLegacyParams
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsListForCommitCommentParams(args map[string]string, r *http.Request) (ReactionsListForCommitCommentParams, error) {
	var params ReactionsListForCommitCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForCommitCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForCommitCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueParams(args map[string]string, r *http.Request) (ReactionsListForIssueParams, error) {
	var params ReactionsListForIssueParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForIssueContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForIssueContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueCommentParams(args map[string]string, r *http.Request) (ReactionsListForIssueCommentParams, error) {
	var params ReactionsListForIssueCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForIssueCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForIssueCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForPullRequestReviewCommentParams(args map[string]string, r *http.Request) (ReactionsListForPullRequestReviewCommentParams, error) {
	var params ReactionsListForPullRequestReviewCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForPullRequestReviewCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForPullRequestReviewCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionCommentInOrgParams, error) {
	var params ReactionsListForTeamDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionCommentInOrgContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionCommentInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionCommentLegacyParams, error) {
	var params ReactionsListForTeamDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionCommentLegacyContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionCommentLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionInOrgParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionInOrgParams, error) {
	var params ReactionsListForTeamDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionInOrgContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionLegacyParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionLegacyParams, error) {
	var params ReactionsListForTeamDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := r.URL.Query()["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionLegacyContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {

				if params.Content.Set {
					if err := func() error {

						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposAcceptInvitationParams(args map[string]string, r *http.Request) (ReposAcceptInvitationParams, error) {
	var params ReposAcceptInvitationParams
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposCheckCollaboratorParams(args map[string]string, r *http.Request) (ReposCheckCollaboratorParams, error) {
	var params ReposCheckCollaboratorParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposCheckVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposCheckVulnerabilityAlertsParams, error) {
	var params ReposCheckVulnerabilityAlertsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCompareCommitsParams(args map[string]string, r *http.Request) (ReposCompareCommitsParams, error) {
	var params ReposCompareCommitsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode path: basehead.
	{
		param := args["basehead"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "basehead",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Basehead = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: basehead: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposCreateCommitSignatureProtectionParams, error) {
	var params ReposCreateCommitSignatureProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateCommitStatusParams(args map[string]string, r *http.Request) (ReposCreateCommitStatusParams, error) {
	var params ReposCreateCommitStatusParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: sha.
	{
		param := args["sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: sha: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateUsingTemplateParams(args map[string]string, r *http.Request) (ReposCreateUsingTemplateParams, error) {
	var params ReposCreateUsingTemplateParams
	// Decode path: template_owner.
	{
		param := args["template_owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TemplateOwner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: template_owner: not specified`)
		}
	}
	// Decode path: template_repo.
	{
		param := args["template_repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TemplateRepo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: template_repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeclineInvitationParams(args map[string]string, r *http.Request) (ReposDeclineInvitationParams, error) {
	var params ReposDeclineInvitationParams
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteParams(args map[string]string, r *http.Request) (ReposDeleteParams, error) {
	var params ReposDeleteParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposDeleteAccessRestrictionsParams, error) {
	var params ReposDeleteAccessRestrictionsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposDeleteAdminBranchProtectionParams, error) {
	var params ReposDeleteAdminBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAnEnvironmentParams(args map[string]string, r *http.Request) (ReposDeleteAnEnvironmentParams, error) {
	var params ReposDeleteAnEnvironmentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAutolinkParams(args map[string]string, r *http.Request) (ReposDeleteAutolinkParams, error) {
	var params ReposDeleteAutolinkParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: autolink_id.
	{
		param := args["autolink_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: autolink_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteBranchProtectionParams(args map[string]string, r *http.Request) (ReposDeleteBranchProtectionParams, error) {
	var params ReposDeleteBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteCommitCommentParams(args map[string]string, r *http.Request) (ReposDeleteCommitCommentParams, error) {
	var params ReposDeleteCommitCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposDeleteCommitSignatureProtectionParams, error) {
	var params ReposDeleteCommitSignatureProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteDeployKeyParams(args map[string]string, r *http.Request) (ReposDeleteDeployKeyParams, error) {
	var params ReposDeleteDeployKeyParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteDeploymentParams(args map[string]string, r *http.Request) (ReposDeleteDeploymentParams, error) {
	var params ReposDeleteDeploymentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteInvitationParams(args map[string]string, r *http.Request) (ReposDeleteInvitationParams, error) {
	var params ReposDeleteInvitationParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeletePullRequestReviewProtectionParams(args map[string]string, r *http.Request) (ReposDeletePullRequestReviewProtectionParams, error) {
	var params ReposDeletePullRequestReviewProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseParams(args map[string]string, r *http.Request) (ReposDeleteReleaseParams, error) {
	var params ReposDeleteReleaseParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseAssetParams(args map[string]string, r *http.Request) (ReposDeleteReleaseAssetParams, error) {
	var params ReposDeleteReleaseAssetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteWebhookParams(args map[string]string, r *http.Request) (ReposDeleteWebhookParams, error) {
	var params ReposDeleteWebhookParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableAutomatedSecurityFixesParams(args map[string]string, r *http.Request) (ReposDisableAutomatedSecurityFixesParams, error) {
	var params ReposDisableAutomatedSecurityFixesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableLfsForRepoParams(args map[string]string, r *http.Request) (ReposDisableLfsForRepoParams, error) {
	var params ReposDisableLfsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposDisableVulnerabilityAlertsParams, error) {
	var params ReposDisableVulnerabilityAlertsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDownloadTarballArchiveParams(args map[string]string, r *http.Request) (ReposDownloadTarballArchiveParams, error) {
	var params ReposDownloadTarballArchiveParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeReposDownloadZipballArchiveParams(args map[string]string, r *http.Request) (ReposDownloadZipballArchiveParams, error) {
	var params ReposDownloadZipballArchiveParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableAutomatedSecurityFixesParams(args map[string]string, r *http.Request) (ReposEnableAutomatedSecurityFixesParams, error) {
	var params ReposEnableAutomatedSecurityFixesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableLfsForRepoParams(args map[string]string, r *http.Request) (ReposEnableLfsForRepoParams, error) {
	var params ReposEnableLfsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposEnableVulnerabilityAlertsParams, error) {
	var params ReposEnableVulnerabilityAlertsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetParams(args map[string]string, r *http.Request) (ReposGetParams, error) {
	var params ReposGetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposGetAccessRestrictionsParams, error) {
	var params ReposGetAccessRestrictionsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposGetAdminBranchProtectionParams, error) {
	var params ReposGetAdminBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAllStatusCheckContextsParams(args map[string]string, r *http.Request) (ReposGetAllStatusCheckContextsParams, error) {
	var params ReposGetAllStatusCheckContextsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAllTopicsParams(args map[string]string, r *http.Request) (ReposGetAllTopicsParams, error) {
	var params ReposGetAllTopicsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetAppsWithAccessToProtectedBranchParams, error) {
	var params ReposGetAppsWithAccessToProtectedBranchParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAutolinkParams(args map[string]string, r *http.Request) (ReposGetAutolinkParams, error) {
	var params ReposGetAutolinkParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: autolink_id.
	{
		param := args["autolink_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: autolink_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetBranchParams(args map[string]string, r *http.Request) (ReposGetBranchParams, error) {
	var params ReposGetBranchParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetBranchProtectionParams(args map[string]string, r *http.Request) (ReposGetBranchProtectionParams, error) {
	var params ReposGetBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetClonesParams(args map[string]string, r *http.Request) (ReposGetClonesParams, error) {
	var params ReposGetClonesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per.
	{
		values, ok := r.URL.Query()["per"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerVal ReposGetClonesPer
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPerVal = ReposGetClonesPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsPerVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: parse`)
			}
			if err := func() error {

				if params.Per.Set {
					if err := func() error {

						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: invalid`)
			}
		}
	}
	return params, nil
}

func decodeReposGetCodeFrequencyStatsParams(args map[string]string, r *http.Request) (ReposGetCodeFrequencyStatsParams, error) {
	var params ReposGetCodeFrequencyStatsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCollaboratorPermissionLevelParams(args map[string]string, r *http.Request) (ReposGetCollaboratorPermissionLevelParams, error) {
	var params ReposGetCollaboratorPermissionLevelParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCombinedStatusForRefParams(args map[string]string, r *http.Request) (ReposGetCombinedStatusForRefParams, error) {
	var params ReposGetCombinedStatusForRefParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetCommitActivityStatsParams(args map[string]string, r *http.Request) (ReposGetCommitActivityStatsParams, error) {
	var params ReposGetCommitActivityStatsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommitCommentParams(args map[string]string, r *http.Request) (ReposGetCommitCommentParams, error) {
	var params ReposGetCommitCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposGetCommitSignatureProtectionParams, error) {
	var params ReposGetCommitSignatureProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommunityProfileMetricsParams(args map[string]string, r *http.Request) (ReposGetCommunityProfileMetricsParams, error) {
	var params ReposGetCommunityProfileMetricsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetContributorsStatsParams(args map[string]string, r *http.Request) (ReposGetContributorsStatsParams, error) {
	var params ReposGetContributorsStatsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetDeployKeyParams(args map[string]string, r *http.Request) (ReposGetDeployKeyParams, error) {
	var params ReposGetDeployKeyParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetDeploymentStatusParams(args map[string]string, r *http.Request) (ReposGetDeploymentStatusParams, error) {
	var params ReposGetDeploymentStatusParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	// Decode path: status_id.
	{
		param := args["status_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "status_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.StatusID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: status_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetLatestPagesBuildParams(args map[string]string, r *http.Request) (ReposGetLatestPagesBuildParams, error) {
	var params ReposGetLatestPagesBuildParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetLatestReleaseParams(args map[string]string, r *http.Request) (ReposGetLatestReleaseParams, error) {
	var params ReposGetLatestReleaseParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesParams(args map[string]string, r *http.Request) (ReposGetPagesParams, error) {
	var params ReposGetPagesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesBuildParams(args map[string]string, r *http.Request) (ReposGetPagesBuildParams, error) {
	var params ReposGetPagesBuildParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: build_id.
	{
		param := args["build_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "build_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.BuildID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: build_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesHealthCheckParams(args map[string]string, r *http.Request) (ReposGetPagesHealthCheckParams, error) {
	var params ReposGetPagesHealthCheckParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetParticipationStatsParams(args map[string]string, r *http.Request) (ReposGetParticipationStatsParams, error) {
	var params ReposGetParticipationStatsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPullRequestReviewProtectionParams(args map[string]string, r *http.Request) (ReposGetPullRequestReviewProtectionParams, error) {
	var params ReposGetPullRequestReviewProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPunchCardStatsParams(args map[string]string, r *http.Request) (ReposGetPunchCardStatsParams, error) {
	var params ReposGetPunchCardStatsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReleaseParams(args map[string]string, r *http.Request) (ReposGetReleaseParams, error) {
	var params ReposGetReleaseParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReleaseAssetParams(args map[string]string, r *http.Request) (ReposGetReleaseAssetParams, error) {
	var params ReposGetReleaseAssetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReleaseByTagParams(args map[string]string, r *http.Request) (ReposGetReleaseByTagParams, error) {
	var params ReposGetReleaseByTagParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: tag.
	{
		param := args["tag"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Tag = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: tag: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetStatusChecksProtectionParams(args map[string]string, r *http.Request) (ReposGetStatusChecksProtectionParams, error) {
	var params ReposGetStatusChecksProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetTeamsWithAccessToProtectedBranchParams, error) {
	var params ReposGetTeamsWithAccessToProtectedBranchParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTopPathsParams(args map[string]string, r *http.Request) (ReposGetTopPathsParams, error) {
	var params ReposGetTopPathsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTopReferrersParams(args map[string]string, r *http.Request) (ReposGetTopReferrersParams, error) {
	var params ReposGetTopReferrersParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetUsersWithAccessToProtectedBranchParams, error) {
	var params ReposGetUsersWithAccessToProtectedBranchParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetViewsParams(args map[string]string, r *http.Request) (ReposGetViewsParams, error) {
	var params ReposGetViewsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per.
	{
		values, ok := r.URL.Query()["per"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerVal ReposGetViewsPer
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPerVal = ReposGetViewsPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsPerVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: parse`)
			}
			if err := func() error {

				if params.Per.Set {
					if err := func() error {

						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: invalid`)
			}
		}
	}
	return params, nil
}

func decodeReposGetWebhookParams(args map[string]string, r *http.Request) (ReposGetWebhookParams, error) {
	var params ReposGetWebhookParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetWebhookConfigForRepoParams(args map[string]string, r *http.Request) (ReposGetWebhookConfigForRepoParams, error) {
	var params ReposGetWebhookConfigForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposListAutolinksParams(args map[string]string, r *http.Request) (ReposListAutolinksParams, error) {
	var params ReposListAutolinksParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListBranchesParams(args map[string]string, r *http.Request) (ReposListBranchesParams, error) {
	var params ReposListBranchesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: protected.
	{
		values, ok := r.URL.Query()["protected"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsProtectedVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsProtectedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Protected.SetTo(paramsProtectedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: protected: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCollaboratorsParams(args map[string]string, r *http.Request) (ReposListCollaboratorsParams, error) {
	var params ReposListCollaboratorsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: affiliation.
	{
		values, ok := r.URL.Query()["affiliation"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAffiliationVal ReposListCollaboratorsAffiliation
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAffiliationVal = ReposListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsAffiliationVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: parse`)
			}
			if err := func() error {

				if params.Affiliation.Set {
					if err := func() error {

						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommentsForCommitParams(args map[string]string, r *http.Request) (ReposListCommentsForCommitParams, error) {
	var params ReposListCommentsForCommitParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitCommentsForRepoParams(args map[string]string, r *http.Request) (ReposListCommitCommentsForRepoParams, error) {
	var params ReposListCommitCommentsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitStatusesForRefParams(args map[string]string, r *http.Request) (ReposListCommitStatusesForRefParams, error) {
	var params ReposListCommitStatusesForRefParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitsParams(args map[string]string, r *http.Request) (ReposListCommitsParams, error) {
	var params ReposListCommitsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sha.
	{
		values, ok := r.URL.Query()["sha"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsShaVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsShaVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sha: parse`)
			}
		}
	}
	// Decode query: path.
	{
		values, ok := r.URL.Query()["path"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPathVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Path.SetTo(paramsPathVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: path: parse`)
			}
		}
	}
	// Decode query: author.
	{
		values, ok := r.URL.Query()["author"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAuthorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAuthorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Author.SetTo(paramsAuthorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: author: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: until.
	{
		values, ok := r.URL.Query()["until"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsUntilVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsUntilVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Until.SetTo(paramsUntilVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: until: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListContributorsParams(args map[string]string, r *http.Request) (ReposListContributorsParams, error) {
	var params ReposListContributorsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: anon.
	{
		values, ok := r.URL.Query()["anon"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAnonVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAnonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Anon.SetTo(paramsAnonVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: anon: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListDeployKeysParams(args map[string]string, r *http.Request) (ReposListDeployKeysParams, error) {
	var params ReposListDeployKeysParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListDeploymentStatusesParams(args map[string]string, r *http.Request) (ReposListDeploymentStatusesParams, error) {
	var params ReposListDeploymentStatusesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForOrgParams(args map[string]string, r *http.Request) (ReposListForOrgParams, error) {
	var params ReposListForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: type.
	{
		values, ok := r.URL.Query()["type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTypeVal ReposListForOrgType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTypeVal = ReposListForOrgType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: parse`)
			}
			if err := func() error {

				if params.Type.Set {
					if err := func() error {

						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForOrgSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ReposListForOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ReposListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForUserParams(args map[string]string, r *http.Request) (ReposListForUserParams, error) {
	var params ReposListForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: type.
	{
		values, ok := r.URL.Query()["type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTypeVal ReposListForUserType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTypeVal = ReposListForUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: parse`)
			}
			if err := func() error {

				if params.Type.Set {
					if err := func() error {

						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ReposListForUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ReposListForUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForksParams(args map[string]string, r *http.Request) (ReposListForksParams, error) {
	var params ReposListForksParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForksSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForksSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsParams(args map[string]string, r *http.Request) (ReposListInvitationsParams, error) {
	var params ReposListInvitationsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ReposListInvitationsForAuthenticatedUserParams, error) {
	var params ReposListInvitationsForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListLanguagesParams(args map[string]string, r *http.Request) (ReposListLanguagesParams, error) {
	var params ReposListLanguagesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposListPagesBuildsParams(args map[string]string, r *http.Request) (ReposListPagesBuildsParams, error) {
	var params ReposListPagesBuildsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListPullRequestsAssociatedWithCommitParams(args map[string]string, r *http.Request) (ReposListPullRequestsAssociatedWithCommitParams, error) {
	var params ReposListPullRequestsAssociatedWithCommitParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListReleaseAssetsParams(args map[string]string, r *http.Request) (ReposListReleaseAssetsParams, error) {
	var params ReposListReleaseAssetsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListReleasesParams(args map[string]string, r *http.Request) (ReposListReleasesParams, error) {
	var params ReposListReleasesParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListTagsParams(args map[string]string, r *http.Request) (ReposListTagsParams, error) {
	var params ReposListTagsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListTeamsParams(args map[string]string, r *http.Request) (ReposListTeamsParams, error) {
	var params ReposListTeamsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListWebhooksParams(args map[string]string, r *http.Request) (ReposListWebhooksParams, error) {
	var params ReposListWebhooksParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposMergeUpstreamParams(args map[string]string, r *http.Request) (ReposMergeUpstreamParams, error) {
	var params ReposMergeUpstreamParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposPingWebhookParams(args map[string]string, r *http.Request) (ReposPingWebhookParams, error) {
	var params ReposPingWebhookParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveCollaboratorParams(args map[string]string, r *http.Request) (ReposRemoveCollaboratorParams, error) {
	var params ReposRemoveCollaboratorParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveStatusCheckProtectionParams(args map[string]string, r *http.Request) (ReposRemoveStatusCheckProtectionParams, error) {
	var params ReposRemoveStatusCheckProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposReplaceAllTopicsParams(args map[string]string, r *http.Request) (ReposReplaceAllTopicsParams, error) {
	var params ReposReplaceAllTopicsParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposRequestPagesBuildParams(args map[string]string, r *http.Request) (ReposRequestPagesBuildParams, error) {
	var params ReposRequestPagesBuildParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposSetAdminBranchProtectionParams, error) {
	var params ReposSetAdminBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposTestPushWebhookParams(args map[string]string, r *http.Request) (ReposTestPushWebhookParams, error) {
	var params ReposTestPushWebhookParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposTransferParams(args map[string]string, r *http.Request) (ReposTransferParams, error) {
	var params ReposTransferParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateBranchProtectionParams(args map[string]string, r *http.Request) (ReposUpdateBranchProtectionParams, error) {
	var params ReposUpdateBranchProtectionParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateCommitCommentParams(args map[string]string, r *http.Request) (ReposUpdateCommitCommentParams, error) {
	var params ReposUpdateCommitCommentParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateInvitationParams(args map[string]string, r *http.Request) (ReposUpdateInvitationParams, error) {
	var params ReposUpdateInvitationParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseParams(args map[string]string, r *http.Request) (ReposUpdateReleaseParams, error) {
	var params ReposUpdateReleaseParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseAssetParams(args map[string]string, r *http.Request) (ReposUpdateReleaseAssetParams, error) {
	var params ReposUpdateReleaseAssetParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateWebhookConfigForRepoParams(args map[string]string, r *http.Request) (ReposUpdateWebhookConfigForRepoParams, error) {
	var params ReposUpdateWebhookConfigForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeScimDeleteUserFromOrgParams(args map[string]string, r *http.Request) (ScimDeleteUserFromOrgParams, error) {
	var params ScimDeleteUserFromOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeSearchCommitsParams(args map[string]string, r *http.Request) (SearchCommitsParams, error) {
	var params SearchCommitsParams
	// Decode query: q.
	{
		values, ok := r.URL.Query()["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := r.URL.Query()["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchCommitsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchCommitsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {

				if params.Sort.Set {
					if err := func() error {

						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := r.URL.Query()["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchCommitsOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchCommitsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {

				if params.Order.Set {
					if err := func() error {

						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchTopicsParams(args map[string]string, r *http.Request) (SearchTopicsParams, error) {
	var params SearchTopicsParams
	// Decode query: q.
	{
		values, ok := r.URL.Query()["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningGetAlertParams(args map[string]string, r *http.Request) (SecretScanningGetAlertParams, error) {
	var params SecretScanningGetAlertParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForOrgParams(args map[string]string, r *http.Request) (SecretScanningListAlertsForOrgParams, error) {
	var params SecretScanningListAlertsForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal SecretScanningListAlertsForOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = SecretScanningListAlertsForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: secret_type.
	{
		values, ok := r.URL.Query()["secret_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSecretTypeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsSecretTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: secret_type: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForRepoParams(args map[string]string, r *http.Request) (SecretScanningListAlertsForRepoParams, error) {
	var params SecretScanningListAlertsForRepoParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := r.URL.Query()["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal SecretScanningListAlertsForRepoState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = SecretScanningListAlertsForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {

				if params.State.Set {
					if err := func() error {

						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: secret_type.
	{
		values, ok := r.URL.Query()["secret_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSecretTypeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsSecretTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: secret_type: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningUpdateAlertParams(args map[string]string, r *http.Request) (SecretScanningUpdateAlertParams, error) {
	var params SecretScanningUpdateAlertParams
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddMemberLegacyParams(args map[string]string, r *http.Request) (TeamsAddMemberLegacyParams, error) {
	var params TeamsAddMemberLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateMembershipForUserInOrgParams, error) {
	var params TeamsAddOrUpdateMembershipForUserInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateMembershipForUserLegacyParams, error) {
	var params TeamsAddOrUpdateMembershipForUserLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateProjectPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateProjectPermissionsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateRepoPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateRepoPermissionsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForProjectInOrgParams, error) {
	var params TeamsCheckPermissionsForProjectInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForProjectLegacyParams, error) {
	var params TeamsCheckPermissionsForProjectLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForRepoInOrgParams, error) {
	var params TeamsCheckPermissionsForRepoInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForRepoLegacyParams, error) {
	var params TeamsCheckPermissionsForRepoLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionCommentInOrgParams, error) {
	var params TeamsCreateDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionCommentLegacyParams, error) {
	var params TeamsCreateDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionInOrgParams, error) {
	var params TeamsCreateDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionLegacyParams, error) {
	var params TeamsCreateDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args map[string]string, r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, error) {
	var params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionCommentInOrgParams, error) {
	var params TeamsDeleteDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionCommentLegacyParams, error) {
	var params TeamsDeleteDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionInOrgParams, error) {
	var params TeamsDeleteDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionLegacyParams, error) {
	var params TeamsDeleteDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteInOrgParams, error) {
	var params TeamsDeleteInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetByNameParams(args map[string]string, r *http.Request) (TeamsGetByNameParams, error) {
	var params TeamsGetByNameParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsGetDiscussionCommentInOrgParams, error) {
	var params TeamsGetDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsGetDiscussionCommentLegacyParams, error) {
	var params TeamsGetDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsGetDiscussionInOrgParams, error) {
	var params TeamsGetDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsGetDiscussionLegacyParams, error) {
	var params TeamsGetDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetLegacyParams(args map[string]string, r *http.Request) (TeamsGetLegacyParams, error) {
	var params TeamsGetLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMemberLegacyParams(args map[string]string, r *http.Request) (TeamsGetMemberLegacyParams, error) {
	var params TeamsGetMemberLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsGetMembershipForUserInOrgParams, error) {
	var params TeamsGetMembershipForUserInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsGetMembershipForUserLegacyParams, error) {
	var params TeamsGetMembershipForUserLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListParams(args map[string]string, r *http.Request) (TeamsListParams, error) {
	var params TeamsListParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListChildInOrgParams(args map[string]string, r *http.Request) (TeamsListChildInOrgParams, error) {
	var params TeamsListChildInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsInOrgParams(args map[string]string, r *http.Request) (TeamsListDiscussionCommentsInOrgParams, error) {
	var params TeamsListDiscussionCommentsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionCommentsInOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionCommentsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsLegacyParams(args map[string]string, r *http.Request) (TeamsListDiscussionCommentsLegacyParams, error) {
	var params TeamsListDiscussionCommentsLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionCommentsLegacyDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionCommentsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsInOrgParams(args map[string]string, r *http.Request) (TeamsListDiscussionsInOrgParams, error) {
	var params TeamsListDiscussionsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionsInOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: pinned.
	{
		values, ok := r.URL.Query()["pinned"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPinnedVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPinnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pinned.SetTo(paramsPinnedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: pinned: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsLegacyParams(args map[string]string, r *http.Request) (TeamsListDiscussionsLegacyParams, error) {
	var params TeamsListDiscussionsLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := r.URL.Query()["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionsLegacyDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {

				if params.Direction.Set {
					if err := func() error {

						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (TeamsListForAuthenticatedUserParams, error) {
	var params TeamsListForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForLegacyParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsForLegacyParams, error) {
	var params TeamsListIdpGroupsForLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForOrgParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsForOrgParams, error) {
	var params TeamsListIdpGroupsForOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsInOrgParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsInOrgParams, error) {
	var params TeamsListIdpGroupsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListMembersInOrgParams(args map[string]string, r *http.Request) (TeamsListMembersInOrgParams, error) {
	var params TeamsListMembersInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: role.
	{
		values, ok := r.URL.Query()["role"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRoleVal TeamsListMembersInOrgRole
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRoleVal = TeamsListMembersInOrgRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsRoleVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: parse`)
			}
			if err := func() error {

				if params.Role.Set {
					if err := func() error {

						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListMembersLegacyParams(args map[string]string, r *http.Request) (TeamsListMembersLegacyParams, error) {
	var params TeamsListMembersLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: role.
	{
		values, ok := r.URL.Query()["role"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRoleVal TeamsListMembersLegacyRole
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRoleVal = TeamsListMembersLegacyRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsRoleVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: parse`)
			}
			if err := func() error {

				if params.Role.Set {
					if err := func() error {

						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil

				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsInOrgParams(args map[string]string, r *http.Request) (TeamsListPendingInvitationsInOrgParams, error) {
	var params TeamsListPendingInvitationsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsLegacyParams(args map[string]string, r *http.Request) (TeamsListPendingInvitationsLegacyParams, error) {
	var params TeamsListPendingInvitationsLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsInOrgParams(args map[string]string, r *http.Request) (TeamsListProjectsInOrgParams, error) {
	var params TeamsListProjectsInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsLegacyParams(args map[string]string, r *http.Request) (TeamsListProjectsLegacyParams, error) {
	var params TeamsListProjectsLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposInOrgParams(args map[string]string, r *http.Request) (TeamsListReposInOrgParams, error) {
	var params TeamsListReposInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposLegacyParams(args map[string]string, r *http.Request) (TeamsListReposLegacyParams, error) {
	var params TeamsListReposLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsRemoveMemberLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveMemberLegacyParams, error) {
	var params TeamsRemoveMemberLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveMembershipForUserInOrgParams, error) {
	var params TeamsRemoveMembershipForUserInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveMembershipForUserLegacyParams, error) {
	var params TeamsRemoveMembershipForUserLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveProjectInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveProjectInOrgParams, error) {
	var params TeamsRemoveProjectInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveRepoInOrgParams, error) {
	var params TeamsRemoveRepoInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveRepoLegacyParams, error) {
	var params TeamsRemoveRepoLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionCommentInOrgParams, error) {
	var params TeamsUpdateDiscussionCommentInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionCommentLegacyParams, error) {
	var params TeamsUpdateDiscussionCommentLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionInOrgParams, error) {
	var params TeamsUpdateDiscussionInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionLegacyParams, error) {
	var params TeamsUpdateDiscussionLegacyParams
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateInOrgParams, error) {
	var params TeamsUpdateInOrgParams
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckBlockedParams(args map[string]string, r *http.Request) (UsersCheckBlockedParams, error) {
	var params UsersCheckBlockedParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckFollowingForUserParams(args map[string]string, r *http.Request) (UsersCheckFollowingForUserParams, error) {
	var params UsersCheckFollowingForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: target_user.
	{
		param := args["target_user"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "target_user",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TargetUser = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: target_user: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args map[string]string, r *http.Request) (UsersCheckPersonIsFollowedByAuthenticatedParams, error) {
	var params UsersCheckPersonIsFollowedByAuthenticatedParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersDeletePublicSSHKeyForAuthenticatedParams, error) {
	var params UsersDeletePublicSSHKeyForAuthenticatedParams
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersFollowParams(args map[string]string, r *http.Request) (UsersFollowParams, error) {
	var params UsersFollowParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetByUsernameParams(args map[string]string, r *http.Request) (UsersGetByUsernameParams, error) {
	var params UsersGetByUsernameParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetGpgKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersGetGpgKeyForAuthenticatedParams, error) {
	var params UsersGetGpgKeyForAuthenticatedParams
	// Decode path: gpg_key_id.
	{
		param := args["gpg_key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gpg_key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersGetPublicSSHKeyForAuthenticatedParams, error) {
	var params UsersGetPublicSSHKeyForAuthenticatedParams
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersListParams(args map[string]string, r *http.Request) (UsersListParams, error) {
	var params UsersListParams
	// Decode query: since.
	{
		values, ok := r.URL.Query()["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListEmailsForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListEmailsForAuthenticatedParams, error) {
	var params UsersListEmailsForAuthenticatedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowedByAuthenticatedParams(args map[string]string, r *http.Request) (UsersListFollowedByAuthenticatedParams, error) {
	var params UsersListFollowedByAuthenticatedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForAuthenticatedUserParams(args map[string]string, r *http.Request) (UsersListFollowersForAuthenticatedUserParams, error) {
	var params UsersListFollowersForAuthenticatedUserParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForUserParams(args map[string]string, r *http.Request) (UsersListFollowersForUserParams, error) {
	var params UsersListFollowersForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowingForUserParams(args map[string]string, r *http.Request) (UsersListFollowingForUserParams, error) {
	var params UsersListFollowingForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListGpgKeysForAuthenticatedParams, error) {
	var params UsersListGpgKeysForAuthenticatedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForUserParams(args map[string]string, r *http.Request) (UsersListGpgKeysForUserParams, error) {
	var params UsersListGpgKeysForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicEmailsForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListPublicEmailsForAuthenticatedParams, error) {
	var params UsersListPublicEmailsForAuthenticatedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicKeysForUserParams(args map[string]string, r *http.Request) (UsersListPublicKeysForUserParams, error) {
	var params UsersListPublicKeysForUserParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListPublicSSHKeysForAuthenticatedParams, error) {
	var params UsersListPublicSSHKeysForAuthenticatedParams
	// Decode query: per_page.
	{
		values, ok := r.URL.Query()["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := r.URL.Query()["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersUnblockParams(args map[string]string, r *http.Request) (UsersUnblockParams, error) {
	var params UsersUnblockParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersUnfollowParams(args map[string]string, r *http.Request) (UsersUnfollowParams, error) {
	var params UsersUnfollowParams
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}
