// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var (
		params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsAddSelectedRepoToOrgSecretParams(args map[string]string, r *http.Request) (ActionsAddSelectedRepoToOrgSecretParams, error) {
	var (
		params ActionsAddSelectedRepoToOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args map[string]string, r *http.Request) (ActionsAddSelfHostedRunnerToGroupForOrgParams, error) {
	var (
		params ActionsAddSelfHostedRunnerToGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsApproveWorkflowRunParams(args map[string]string, r *http.Request) (ActionsApproveWorkflowRunParams, error) {
	var (
		params ActionsApproveWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCancelWorkflowRunParams(args map[string]string, r *http.Request) (ActionsCancelWorkflowRunParams, error) {
	var (
		params ActionsCancelWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateEnvironmentSecretParams, error) {
	var (
		params ActionsCreateOrUpdateEnvironmentSecretParams
	)
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateOrgSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateOrgSecretParams, error) {
	var (
		params ActionsCreateOrUpdateOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateRepoSecretParams(args map[string]string, r *http.Request) (ActionsCreateOrUpdateRepoSecretParams, error) {
	var (
		params ActionsCreateOrUpdateRepoSecretParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForOrgParams(args map[string]string, r *http.Request) (ActionsCreateRegistrationTokenForOrgParams, error) {
	var (
		params ActionsCreateRegistrationTokenForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForRepoParams(args map[string]string, r *http.Request) (ActionsCreateRegistrationTokenForRepoParams, error) {
	var (
		params ActionsCreateRegistrationTokenForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForOrgParams(args map[string]string, r *http.Request) (ActionsCreateRemoveTokenForOrgParams, error) {
	var (
		params ActionsCreateRemoveTokenForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForRepoParams(args map[string]string, r *http.Request) (ActionsCreateRemoveTokenForRepoParams, error) {
	var (
		params ActionsCreateRemoveTokenForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsCreateSelfHostedRunnerGroupForOrgParams, error) {
	var (
		params ActionsCreateSelfHostedRunnerGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteArtifactParams(args map[string]string, r *http.Request) (ActionsDeleteArtifactParams, error) {
	var (
		params ActionsDeleteArtifactParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsDeleteEnvironmentSecretParams, error) {
	var (
		params ActionsDeleteEnvironmentSecretParams
	)
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteOrgSecretParams(args map[string]string, r *http.Request) (ActionsDeleteOrgSecretParams, error) {
	var (
		params ActionsDeleteOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteRepoSecretParams(args map[string]string, r *http.Request) (ActionsDeleteRepoSecretParams, error) {
	var (
		params ActionsDeleteRepoSecretParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerFromOrgParams, error) {
	var (
		params ActionsDeleteSelfHostedRunnerFromOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerFromRepoParams, error) {
	var (
		params ActionsDeleteSelfHostedRunnerFromRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args map[string]string, r *http.Request) (ActionsDeleteSelfHostedRunnerGroupFromOrgParams, error) {
	var (
		params ActionsDeleteSelfHostedRunnerGroupFromOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunParams(args map[string]string, r *http.Request) (ActionsDeleteWorkflowRunParams, error) {
	var (
		params ActionsDeleteWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunLogsParams(args map[string]string, r *http.Request) (ActionsDeleteWorkflowRunLogsParams, error) {
	var (
		params ActionsDeleteWorkflowRunLogsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var (
		params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadArtifactParams(args map[string]string, r *http.Request) (ActionsDownloadArtifactParams, error) {
	var (
		params ActionsDownloadArtifactParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	// Decode path: archive_format.
	{
		param := args["archive_format"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "archive_format",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ArchiveFormat = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: archive_format: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsDownloadJobLogsForWorkflowRunParams, error) {
	var (
		params ActionsDownloadJobLogsForWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: job_id.
	{
		param := args["job_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: job_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsDownloadWorkflowRunLogsParams(args map[string]string, r *http.Request) (ActionsDownloadWorkflowRunLogsParams, error) {
	var (
		params ActionsDownloadWorkflowRunLogsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var (
		params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsGetAllowedActionsOrganizationParams, error) {
	var (
		params ActionsGetAllowedActionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsRepositoryParams(args map[string]string, r *http.Request) (ActionsGetAllowedActionsRepositoryParams, error) {
	var (
		params ActionsGetAllowedActionsRepositoryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetArtifactParams(args map[string]string, r *http.Request) (ActionsGetArtifactParams, error) {
	var (
		params ActionsGetArtifactParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: artifact_id.
	{
		param := args["artifact_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: artifact_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetEnvironmentPublicKeyParams, error) {
	var (
		params ActionsGetEnvironmentPublicKeyParams
	)
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentSecretParams(args map[string]string, r *http.Request) (ActionsGetEnvironmentSecretParams, error) {
	var (
		params ActionsGetEnvironmentSecretParams
	)
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(args map[string]string, r *http.Request) (ActionsGetGithubActionsPermissionsOrganizationParams, error) {
	var (
		params ActionsGetGithubActionsPermissionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(args map[string]string, r *http.Request) (ActionsGetGithubActionsPermissionsRepositoryParams, error) {
	var (
		params ActionsGetGithubActionsPermissionsRepositoryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetJobForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsGetJobForWorkflowRunParams, error) {
	var (
		params ActionsGetJobForWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: job_id.
	{
		param := args["job_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: job_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetOrgPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetOrgPublicKeyParams, error) {
	var (
		params ActionsGetOrgPublicKeyParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetOrgSecretParams(args map[string]string, r *http.Request) (ActionsGetOrgSecretParams, error) {
	var (
		params ActionsGetOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetRepoPublicKeyParams(args map[string]string, r *http.Request) (ActionsGetRepoPublicKeyParams, error) {
	var (
		params ActionsGetRepoPublicKeyParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetRepoSecretParams(args map[string]string, r *http.Request) (ActionsGetRepoSecretParams, error) {
	var (
		params ActionsGetRepoSecretParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetReviewsForRunParams(args map[string]string, r *http.Request) (ActionsGetReviewsForRunParams, error) {
	var (
		params ActionsGetReviewsForRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForOrgParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerForOrgParams, error) {
	var (
		params ActionsGetSelfHostedRunnerForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForRepoParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerForRepoParams, error) {
	var (
		params ActionsGetSelfHostedRunnerForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsGetSelfHostedRunnerGroupForOrgParams, error) {
	var (
		params ActionsGetSelfHostedRunnerGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunParams(args map[string]string, r *http.Request) (ActionsGetWorkflowRunParams, error) {
	var (
		params ActionsGetWorkflowRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunUsageParams(args map[string]string, r *http.Request) (ActionsGetWorkflowRunUsageParams, error) {
	var (
		params ActionsGetWorkflowRunUsageParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListArtifactsForRepoParams(args map[string]string, r *http.Request) (ActionsListArtifactsForRepoParams, error) {
	var (
		params    ActionsListArtifactsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListEnvironmentSecretsParams(args map[string]string, r *http.Request) (ActionsListEnvironmentSecretsParams, error) {
	var (
		params    ActionsListEnvironmentSecretsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListJobsForWorkflowRunParams(args map[string]string, r *http.Request) (ActionsListJobsForWorkflowRunParams, error) {
	var (
		params    ActionsListJobsForWorkflowRunParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ActionsListJobsForWorkflowRunFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ActionsListJobsForWorkflowRunFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListOrgSecretsParams(args map[string]string, r *http.Request) (ActionsListOrgSecretsParams, error) {
	var (
		params    ActionsListOrgSecretsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var (
		params    ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoSecretsParams(args map[string]string, r *http.Request) (ActionsListRepoSecretsParams, error) {
	var (
		params    ActionsListRepoSecretsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoWorkflowsParams(args map[string]string, r *http.Request) (ActionsListRepoWorkflowsParams, error) {
	var (
		params    ActionsListRepoWorkflowsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForOrgParams(args map[string]string, r *http.Request) (ActionsListRunnerApplicationsForOrgParams, error) {
	var (
		params ActionsListRunnerApplicationsForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForRepoParams(args map[string]string, r *http.Request) (ActionsListRunnerApplicationsForRepoParams, error) {
	var (
		params ActionsListRunnerApplicationsForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsListSelectedReposForOrgSecretParams(args map[string]string, r *http.Request) (ActionsListSelectedReposForOrgSecretParams, error) {
	var (
		params    ActionsListSelectedReposForOrgSecretParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var (
		params    ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnerGroupsForOrgParams, error) {
	var (
		params    ActionsListSelfHostedRunnerGroupsForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersForOrgParams, error) {
	var (
		params    ActionsListSelfHostedRunnersForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForRepoParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersForRepoParams, error) {
	var (
		params    ActionsListSelfHostedRunnersForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(args map[string]string, r *http.Request) (ActionsListSelfHostedRunnersInGroupForOrgParams, error) {
	var (
		params    ActionsListSelfHostedRunnersInGroupForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunArtifactsParams(args map[string]string, r *http.Request) (ActionsListWorkflowRunArtifactsParams, error) {
	var (
		params    ActionsListWorkflowRunArtifactsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunsForRepoParams(args map[string]string, r *http.Request) (ActionsListWorkflowRunsForRepoParams, error) {
	var (
		params    ActionsListWorkflowRunsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: actor.
	{
		values, ok := queryArgs["actor"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsActorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsActorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Actor.SetTo(paramsActorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: actor: parse`)
			}
		}
	}
	// Decode query: branch.
	{
		values, ok := queryArgs["branch"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBranchVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBranchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Branch.SetTo(paramsBranchVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: branch: parse`)
			}
		}
	}
	// Decode query: event.
	{
		values, ok := queryArgs["event"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsEventVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsEventVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Event.SetTo(paramsEventVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: event: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := queryArgs["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ActionsListWorkflowRunsForRepoStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ActionsListWorkflowRunsForRepoStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: created.
	{
		values, ok := queryArgs["created"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCreatedVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsCreatedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Created.SetTo(paramsCreatedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: created: parse`)
			}
		}
	}
	return params, nil
}

func decodeActionsReRunWorkflowParams(args map[string]string, r *http.Request) (ActionsReRunWorkflowParams, error) {
	var (
		params ActionsReRunWorkflowParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var (
		params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(args map[string]string, r *http.Request) (ActionsRemoveSelectedRepoFromOrgSecretParams, error) {
	var (
		params ActionsRemoveSelectedRepoFromOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args map[string]string, r *http.Request) (ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, error) {
	var (
		params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsRetryWorkflowParams(args map[string]string, r *http.Request) (ActionsRetryWorkflowParams, error) {
	var (
		params ActionsRetryWorkflowParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsReviewPendingDeploymentsForRunParams(args map[string]string, r *http.Request) (ActionsReviewPendingDeploymentsForRunParams, error) {
	var (
		params ActionsReviewPendingDeploymentsForRunParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: run_id.
	{
		param := args["run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: run_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetAllowedActionsOrganizationParams, error) {
	var (
		params ActionsSetAllowedActionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsRepositoryParams(args map[string]string, r *http.Request) (ActionsSetAllowedActionsRepositoryParams, error) {
	var (
		params ActionsSetAllowedActionsRepositoryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetGithubActionsPermissionsOrganizationParams, error) {
	var (
		params ActionsSetGithubActionsPermissionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(args map[string]string, r *http.Request) (ActionsSetGithubActionsPermissionsRepositoryParams, error) {
	var (
		params ActionsSetGithubActionsPermissionsRepositoryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args map[string]string, r *http.Request) (ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var (
		params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelectedReposForOrgSecretParams(args map[string]string, r *http.Request) (ActionsSetSelectedReposForOrgSecretParams, error) {
	var (
		params ActionsSetSelectedReposForOrgSecretParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: secret_name.
	{
		param := args["secret_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: secret_name: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args map[string]string, r *http.Request) (ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var (
		params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args map[string]string, r *http.Request) (ActionsSetSelfHostedRunnersInGroupForOrgParams, error) {
	var (
		params ActionsSetSelfHostedRunnersInGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args map[string]string, r *http.Request) (ActionsUpdateSelfHostedRunnerGroupForOrgParams, error) {
	var (
		params ActionsUpdateSelfHostedRunnerGroupForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityCheckRepoIsStarredByAuthenticatedUserParams, error) {
	var (
		params ActivityCheckRepoIsStarredByAuthenticatedUserParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityDeleteRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivityDeleteRepoSubscriptionParams, error) {
	var (
		params ActivityDeleteRepoSubscriptionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityDeleteThreadSubscriptionParams(args map[string]string, r *http.Request) (ActivityDeleteThreadSubscriptionParams, error) {
	var (
		params ActivityDeleteThreadSubscriptionParams
	)
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivityGetRepoSubscriptionParams, error) {
	var (
		params ActivityGetRepoSubscriptionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetThreadParams(args map[string]string, r *http.Request) (ActivityGetThreadParams, error) {
	var (
		params ActivityGetThreadParams
	)
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityGetThreadSubscriptionForAuthenticatedUserParams, error) {
	var (
		params ActivityGetThreadSubscriptionForAuthenticatedUserParams
	)
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityListEventsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListEventsForAuthenticatedUserParams, error) {
	var (
		params    ActivityListEventsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListNotificationsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListNotificationsForAuthenticatedUserParams, error) {
	var (
		params    ActivityListNotificationsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: all.
	{
		values, ok := queryArgs["all"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAllVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsAllVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: all: parse`)
			}
		}
	}
	// Decode query: participating.
	{
		values, ok := queryArgs["participating"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsParticipatingVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsParticipatingVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: participating: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := queryArgs["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListOrgEventsForAuthenticatedUserParams, error) {
	var (
		params    ActivityListOrgEventsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsParams(args map[string]string, r *http.Request) (ActivityListPublicEventsParams, error) {
	var (
		params    ActivityListPublicEventsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForRepoNetworkParams(args map[string]string, r *http.Request) (ActivityListPublicEventsForRepoNetworkParams, error) {
	var (
		params    ActivityListPublicEventsForRepoNetworkParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForUserParams(args map[string]string, r *http.Request) (ActivityListPublicEventsForUserParams, error) {
	var (
		params    ActivityListPublicEventsForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicOrgEventsParams(args map[string]string, r *http.Request) (ActivityListPublicOrgEventsParams, error) {
	var (
		params    ActivityListPublicOrgEventsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedEventsForUserParams(args map[string]string, r *http.Request) (ActivityListReceivedEventsForUserParams, error) {
	var (
		params    ActivityListReceivedEventsForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedPublicEventsForUserParams(args map[string]string, r *http.Request) (ActivityListReceivedPublicEventsForUserParams, error) {
	var (
		params    ActivityListReceivedPublicEventsForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoEventsParams(args map[string]string, r *http.Request) (ActivityListRepoEventsParams, error) {
	var (
		params    ActivityListRepoEventsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListRepoNotificationsForAuthenticatedUserParams, error) {
	var (
		params    ActivityListRepoNotificationsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: all.
	{
		values, ok := queryArgs["all"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAllVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsAllVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: all: parse`)
			}
		}
	}
	// Decode query: participating.
	{
		values, ok := queryArgs["participating"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsParticipatingVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsParticipatingVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: participating: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := queryArgs["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReposStarredByAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListReposStarredByAuthenticatedUserParams, error) {
	var (
		params    ActivityListReposStarredByAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ActivityListReposStarredByAuthenticatedUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ActivityListReposStarredByAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ActivityListReposStarredByAuthenticatedUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ActivityListReposStarredByAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListReposWatchedByUserParams(args map[string]string, r *http.Request) (ActivityListReposWatchedByUserParams, error) {
	var (
		params    ActivityListReposWatchedByUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityListWatchedReposForAuthenticatedUserParams, error) {
	var (
		params    ActivityListWatchedReposForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchersForRepoParams(args map[string]string, r *http.Request) (ActivityListWatchersForRepoParams, error) {
	var (
		params    ActivityListWatchersForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeActivityMarkRepoNotificationsAsReadParams(args map[string]string, r *http.Request) (ActivityMarkRepoNotificationsAsReadParams, error) {
	var (
		params ActivityMarkRepoNotificationsAsReadParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityMarkThreadAsReadParams(args map[string]string, r *http.Request) (ActivityMarkThreadAsReadParams, error) {
	var (
		params ActivityMarkThreadAsReadParams
	)
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivitySetRepoSubscriptionParams(args map[string]string, r *http.Request) (ActivitySetRepoSubscriptionParams, error) {
	var (
		params ActivitySetRepoSubscriptionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivitySetThreadSubscriptionParams(args map[string]string, r *http.Request) (ActivitySetThreadSubscriptionParams, error) {
	var (
		params ActivitySetThreadSubscriptionParams
	)
	// Decode path: thread_id.
	{
		param := args["thread_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: thread_id: not specified`)
		}
	}
	return params, nil
}

func decodeActivityStarRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityStarRepoForAuthenticatedUserParams, error) {
	var (
		params ActivityStarRepoForAuthenticatedUserParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (ActivityUnstarRepoForAuthenticatedUserParams, error) {
	var (
		params ActivityUnstarRepoForAuthenticatedUserParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeAppsAddRepoToInstallationParams(args map[string]string, r *http.Request) (AppsAddRepoToInstallationParams, error) {
	var (
		params AppsAddRepoToInstallationParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsCheckTokenParams(args map[string]string, r *http.Request) (AppsCheckTokenParams, error) {
	var (
		params AppsCheckTokenParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsCreateContentAttachmentParams(args map[string]string, r *http.Request) (AppsCreateContentAttachmentParams, error) {
	var (
		params AppsCreateContentAttachmentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: content_reference_id.
	{
		param := args["content_reference_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "content_reference_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ContentReferenceID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: content_reference_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsCreateInstallationAccessTokenParams(args map[string]string, r *http.Request) (AppsCreateInstallationAccessTokenParams, error) {
	var (
		params AppsCreateInstallationAccessTokenParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsDeleteAuthorizationParams(args map[string]string, r *http.Request) (AppsDeleteAuthorizationParams, error) {
	var (
		params AppsDeleteAuthorizationParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsDeleteInstallationParams(args map[string]string, r *http.Request) (AppsDeleteInstallationParams, error) {
	var (
		params AppsDeleteInstallationParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsDeleteTokenParams(args map[string]string, r *http.Request) (AppsDeleteTokenParams, error) {
	var (
		params AppsDeleteTokenParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetBySlugParams(args map[string]string, r *http.Request) (AppsGetBySlugParams, error) {
	var (
		params AppsGetBySlugParams
	)
	// Decode path: app_slug.
	{
		param := args["app_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "app_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.AppSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: app_slug: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountParams(args map[string]string, r *http.Request) (AppsGetSubscriptionPlanForAccountParams, error) {
	var (
		params AppsGetSubscriptionPlanForAccountParams
	)
	// Decode path: account_id.
	{
		param := args["account_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: account_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(args map[string]string, r *http.Request) (AppsGetSubscriptionPlanForAccountStubbedParams, error) {
	var (
		params AppsGetSubscriptionPlanForAccountStubbedParams
	)
	// Decode path: account_id.
	{
		param := args["account_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: account_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsGetWebhookDeliveryParams(args map[string]string, r *http.Request) (AppsGetWebhookDeliveryParams, error) {
	var (
		params AppsGetWebhookDeliveryParams
	)
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsListAccountsForPlanParams(args map[string]string, r *http.Request) (AppsListAccountsForPlanParams, error) {
	var (
		params    AppsListAccountsForPlanParams
		queryArgs = r.URL.Query()
	)
	// Decode path: plan_id.
	{
		param := args["plan_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: plan_id: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal AppsListAccountsForPlanSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = AppsListAccountsForPlanSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal AppsListAccountsForPlanDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = AppsListAccountsForPlanDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListAccountsForPlanStubbedParams(args map[string]string, r *http.Request) (AppsListAccountsForPlanStubbedParams, error) {
	var (
		params    AppsListAccountsForPlanStubbedParams
		queryArgs = r.URL.Query()
	)
	// Decode path: plan_id.
	{
		param := args["plan_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: plan_id: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal AppsListAccountsForPlanStubbedSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = AppsListAccountsForPlanStubbedSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal AppsListAccountsForPlanStubbedDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = AppsListAccountsForPlanStubbedDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(args map[string]string, r *http.Request) (AppsListInstallationReposForAuthenticatedUserParams, error) {
	var (
		params    AppsListInstallationReposForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansParams(args map[string]string, r *http.Request) (AppsListPlansParams, error) {
	var (
		params    AppsListPlansParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansStubbedParams(args map[string]string, r *http.Request) (AppsListPlansStubbedParams, error) {
	var (
		params    AppsListPlansStubbedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListReposAccessibleToInstallationParams(args map[string]string, r *http.Request) (AppsListReposAccessibleToInstallationParams, error) {
	var (
		params    AppsListReposAccessibleToInstallationParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(args map[string]string, r *http.Request) (AppsListSubscriptionsForAuthenticatedUserParams, error) {
	var (
		params    AppsListSubscriptionsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args map[string]string, r *http.Request) (AppsListSubscriptionsForAuthenticatedUserStubbedParams, error) {
	var (
		params    AppsListSubscriptionsForAuthenticatedUserStubbedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsListWebhookDeliveriesParams(args map[string]string, r *http.Request) (AppsListWebhookDeliveriesParams, error) {
	var (
		params    AppsListWebhookDeliveriesParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: cursor.
	{
		values, ok := queryArgs["cursor"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCursorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsCursorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: cursor: parse`)
			}
		}
	}
	return params, nil
}

func decodeAppsRedeliverWebhookDeliveryParams(args map[string]string, r *http.Request) (AppsRedeliverWebhookDeliveryParams, error) {
	var (
		params AppsRedeliverWebhookDeliveryParams
	)
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsRemoveRepoFromInstallationParams(args map[string]string, r *http.Request) (AppsRemoveRepoFromInstallationParams, error) {
	var (
		params AppsRemoveRepoFromInstallationParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	// Decode path: repository_id.
	{
		param := args["repository_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repository_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsResetTokenParams(args map[string]string, r *http.Request) (AppsResetTokenParams, error) {
	var (
		params AppsResetTokenParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsScopeTokenParams(args map[string]string, r *http.Request) (AppsScopeTokenParams, error) {
	var (
		params AppsScopeTokenParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsSuspendInstallationParams(args map[string]string, r *http.Request) (AppsSuspendInstallationParams, error) {
	var (
		params AppsSuspendInstallationParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeAppsUnsuspendInstallationParams(args map[string]string, r *http.Request) (AppsUnsuspendInstallationParams, error) {
	var (
		params AppsUnsuspendInstallationParams
	)
	// Decode path: installation_id.
	{
		param := args["installation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: installation_id: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingGheParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingGheParams, error) {
	var (
		params BillingGetGithubActionsBillingGheParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingOrgParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingOrgParams, error) {
	var (
		params BillingGetGithubActionsBillingOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingUserParams(args map[string]string, r *http.Request) (BillingGetGithubActionsBillingUserParams, error) {
	var (
		params BillingGetGithubActionsBillingUserParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingGheParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingGheParams, error) {
	var (
		params BillingGetGithubPackagesBillingGheParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingOrgParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingOrgParams, error) {
	var (
		params BillingGetGithubPackagesBillingOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingUserParams(args map[string]string, r *http.Request) (BillingGetGithubPackagesBillingUserParams, error) {
	var (
		params BillingGetGithubPackagesBillingUserParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingGheParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingGheParams, error) {
	var (
		params BillingGetSharedStorageBillingGheParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingOrgParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingOrgParams, error) {
	var (
		params BillingGetSharedStorageBillingOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingUserParams(args map[string]string, r *http.Request) (BillingGetSharedStorageBillingUserParams, error) {
	var (
		params BillingGetSharedStorageBillingUserParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeChecksCreateSuiteParams(args map[string]string, r *http.Request) (ChecksCreateSuiteParams, error) {
	var (
		params ChecksCreateSuiteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeChecksGetParams(args map[string]string, r *http.Request) (ChecksGetParams, error) {
	var (
		params ChecksGetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_run_id.
	{
		param := args["check_run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_run_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksGetSuiteParams(args map[string]string, r *http.Request) (ChecksGetSuiteParams, error) {
	var (
		params ChecksGetSuiteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksListAnnotationsParams(args map[string]string, r *http.Request) (ChecksListAnnotationsParams, error) {
	var (
		params    ChecksListAnnotationsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_run_id.
	{
		param := args["check_run_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_run_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListForRefParams(args map[string]string, r *http.Request) (ChecksListForRefParams, error) {
	var (
		params    ChecksListForRefParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: check_name.
	{
		values, ok := queryArgs["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := queryArgs["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ChecksListForRefStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ChecksListForRefStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ChecksListForRefFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ChecksListForRefFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: app_id.
	{
		values, ok := queryArgs["app_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAppIDVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsAppIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: app_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListForSuiteParams(args map[string]string, r *http.Request) (ChecksListForSuiteParams, error) {
	var (
		params    ChecksListForSuiteParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	// Decode query: check_name.
	{
		values, ok := queryArgs["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: status.
	{
		values, ok := queryArgs["status"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStatusVal ChecksListForSuiteStatus
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStatusVal = ChecksListForSuiteStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsStatusVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: parse`)
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: status: invalid`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal ChecksListForSuiteFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = ChecksListForSuiteFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksListSuitesForRefParams(args map[string]string, r *http.Request) (ChecksListSuitesForRefParams, error) {
	var (
		params    ChecksListSuitesForRefParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: app_id.
	{
		values, ok := queryArgs["app_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAppIDVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsAppIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: app_id: parse`)
			}
		}
	}
	// Decode query: check_name.
	{
		values, ok := queryArgs["check_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCheckNameVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsCheckNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: check_name: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeChecksRerequestSuiteParams(args map[string]string, r *http.Request) (ChecksRerequestSuiteParams, error) {
	var (
		params ChecksRerequestSuiteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: check_suite_id.
	{
		param := args["check_suite_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: check_suite_id: not specified`)
		}
	}
	return params, nil
}

func decodeChecksSetSuitesPreferencesParams(args map[string]string, r *http.Request) (ChecksSetSuitesPreferencesParams, error) {
	var (
		params ChecksSetSuitesPreferencesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningDeleteAnalysisParams(args map[string]string, r *http.Request) (CodeScanningDeleteAnalysisParams, error) {
	var (
		params    CodeScanningDeleteAnalysisParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: analysis_id.
	{
		param := args["analysis_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: analysis_id: not specified`)
		}
	}
	// Decode query: confirm_delete.
	{
		values, ok := queryArgs["confirm_delete"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsConfirmDeleteVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsConfirmDeleteVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ConfirmDelete.SetTo(paramsConfirmDeleteVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: confirm_delete: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningGetAlertParams(args map[string]string, r *http.Request) (CodeScanningGetAlertParams, error) {
	var (
		params CodeScanningGetAlertParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningGetAnalysisParams(args map[string]string, r *http.Request) (CodeScanningGetAnalysisParams, error) {
	var (
		params CodeScanningGetAnalysisParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: analysis_id.
	{
		param := args["analysis_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: analysis_id: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningGetSarifParams(args map[string]string, r *http.Request) (CodeScanningGetSarifParams, error) {
	var (
		params CodeScanningGetSarifParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: sarif_id.
	{
		param := args["sarif_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sarif_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.SarifID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: sarif_id: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertInstancesParams(args map[string]string, r *http.Request) (CodeScanningListAlertInstancesParams, error) {
	var (
		params    CodeScanningListAlertInstancesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertsForRepoParams(args map[string]string, r *http.Request) (CodeScanningListAlertsForRepoParams, error) {
	var (
		params    CodeScanningListAlertsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: tool_name.
	{
		values, ok := queryArgs["tool_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsToolNameValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolNameVal = CodeScanningAnalysisToolName(paramsToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsToolNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_name: parse`)
			}
		}
	}
	// Decode query: tool_guid.
	{
		values, ok := queryArgs["tool_guid"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsToolGUIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolGUIDVal = CodeScanningAnalysisToolGUID(paramsToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsToolGUIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_guid: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal CodeScanningAlertState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = CodeScanningAlertState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListRecentAnalysesParams(args map[string]string, r *http.Request) (CodeScanningListRecentAnalysesParams, error) {
	var (
		params    CodeScanningListRecentAnalysesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: tool_name.
	{
		values, ok := queryArgs["tool_name"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsToolNameValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolNameVal = CodeScanningAnalysisToolName(paramsToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsToolNameVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_name: parse`)
			}
		}
	}
	// Decode query: tool_guid.
	{
		values, ok := queryArgs["tool_guid"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsToolGUIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsToolGUIDVal = CodeScanningAnalysisToolGUID(paramsToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsToolGUIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: tool_guid: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal CodeScanningRef
				if err := func() error {
					var paramsRefValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsRefVal = CodeScanningRef(paramsRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	// Decode query: sarif_id.
	{
		values, ok := queryArgs["sarif_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSarifIDVal CodeScanningAnalysisSarifID
				if err := func() error {
					var paramsSarifIDValVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsSarifIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsSarifIDVal = CodeScanningAnalysisSarifID(paramsSarifIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.SarifID.SetTo(paramsSarifIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sarif_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeCodeScanningUpdateAlertParams(args map[string]string, r *http.Request) (CodeScanningUpdateAlertParams, error) {
	var (
		params CodeScanningUpdateAlertParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeCodeScanningUploadSarifParams(args map[string]string, r *http.Request) (CodeScanningUploadSarifParams, error) {
	var (
		params CodeScanningUploadSarifParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeCodesOfConductGetConductCodeParams(args map[string]string, r *http.Request) (CodesOfConductGetConductCodeParams, error) {
	var (
		params CodesOfConductGetConductCodeParams
	)
	// Decode path: key.
	{
		param := args["key"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var (
		params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, error) {
	var (
		params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateRemoveTokenForEnterpriseParams, error) {
	var (
		params EnterpriseAdminCreateRemoveTokenForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteScimGroupFromEnterpriseParams, error) {
	var (
		params EnterpriseAdminDeleteScimGroupFromEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, error) {
	var (
		params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, error) {
	var (
		params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDeleteUserFromEnterpriseParams, error) {
	var (
		params EnterpriseAdminDeleteUserFromEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetAllowedActionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminGetAllowedActionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAuditLogParams(args map[string]string, r *http.Request) (EnterpriseAdminGetAuditLogParams, error) {
	var (
		params    EnterpriseAdminGetAuditLogParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: phrase.
	{
		values, ok := queryArgs["phrase"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPhraseVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsPhraseVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: phrase: parse`)
			}
		}
	}
	// Decode query: include.
	{
		values, ok := queryArgs["include"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsIncludeVal EnterpriseAdminGetAuditLogInclude
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsIncludeVal = EnterpriseAdminGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsIncludeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: parse`)
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: invalid`)
			}
		}
	}
	// Decode query: after.
	{
		values, ok := queryArgs["after"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAfterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsAfterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: after: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := queryArgs["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal EnterpriseAdminGetAuditLogOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = EnterpriseAdminGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, error) {
	var (
		params    EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	// Decode query: excludedAttributes.
	{
		values, ok := queryArgs["excludedAttributes"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsExcludedAttributesVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsExcludedAttributesVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: excludedAttributes: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, error) {
	var (
		params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, error) {
	var (
		params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListProvisionedGroupsEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListProvisionedGroupsEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: startIndex.
	{
		values, ok := queryArgs["startIndex"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStartIndexVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsStartIndexVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: startIndex: parse`)
			}
		}
	}
	// Decode query: count.
	{
		values, ok := queryArgs["count"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCountVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsCountVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: count: parse`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
		}
	}
	// Decode query: excludedAttributes.
	{
		values, ok := queryArgs["excludedAttributes"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsExcludedAttributesVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsExcludedAttributesVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: excludedAttributes: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: startIndex.
	{
		values, ok := queryArgs["startIndex"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStartIndexVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsStartIndexVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: startIndex: parse`)
			}
		}
	}
	// Decode query: count.
	{
		values, ok := queryArgs["count"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCountVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsCountVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: count: parse`)
			}
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListRunnerApplicationsForEnterpriseParams, error) {
	var (
		params EnterpriseAdminListRunnerApplicationsForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var (
		params    EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
		queryArgs = r.URL.Query()
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, error) {
	var (
		params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseUserParams, error) {
	var (
		params EnterpriseAdminProvisionAndInviteEnterpriseUserParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var (
		params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: org_id.
	{
		param := args["org_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	// Decode path: runner_id.
	{
		param := args["runner_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetAllowedActionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminSetAllowedActionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, error) {
	var (
		params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, error) {
	var (
		params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var (
		params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var (
		params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args map[string]string, r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseGroupParams, error) {
	var (
		params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_group_id.
	{
		param := args["scim_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args map[string]string, r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseUserParams, error) {
	var (
		params EnterpriseAdminUpdateAttributeForEnterpriseUserParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args map[string]string, r *http.Request) (EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var (
		params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
	)
	// Decode path: enterprise.
	{
		param := args["enterprise"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: enterprise: not specified`)
		}
	}
	// Decode path: runner_group_id.
	{
		param := args["runner_group_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: runner_group_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsCheckIsStarredParams(args map[string]string, r *http.Request) (GistsCheckIsStarredParams, error) {
	var (
		params GistsCheckIsStarredParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsCreateCommentParams(args map[string]string, r *http.Request) (GistsCreateCommentParams, error) {
	var (
		params GistsCreateCommentParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsDeleteParams(args map[string]string, r *http.Request) (GistsDeleteParams, error) {
	var (
		params GistsDeleteParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsDeleteCommentParams(args map[string]string, r *http.Request) (GistsDeleteCommentParams, error) {
	var (
		params GistsDeleteCommentParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsForkParams(args map[string]string, r *http.Request) (GistsForkParams, error) {
	var (
		params GistsForkParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsGetParams(args map[string]string, r *http.Request) (GistsGetParams, error) {
	var (
		params GistsGetParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsGetCommentParams(args map[string]string, r *http.Request) (GistsGetCommentParams, error) {
	var (
		params GistsGetCommentParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsGetRevisionParams(args map[string]string, r *http.Request) (GistsGetRevisionParams, error) {
	var (
		params GistsGetRevisionParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: sha.
	{
		param := args["sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: sha: not specified`)
		}
	}
	return params, nil
}

func decodeGistsListParams(args map[string]string, r *http.Request) (GistsListParams, error) {
	var (
		params    GistsListParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListCommentsParams(args map[string]string, r *http.Request) (GistsListCommentsParams, error) {
	var (
		params    GistsListCommentsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListCommitsParams(args map[string]string, r *http.Request) (GistsListCommitsParams, error) {
	var (
		params    GistsListCommitsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListForUserParams(args map[string]string, r *http.Request) (GistsListForUserParams, error) {
	var (
		params    GistsListForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListForksParams(args map[string]string, r *http.Request) (GistsListForksParams, error) {
	var (
		params    GistsListForksParams
		queryArgs = r.URL.Query()
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListPublicParams(args map[string]string, r *http.Request) (GistsListPublicParams, error) {
	var (
		params    GistsListPublicParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsListStarredParams(args map[string]string, r *http.Request) (GistsListStarredParams, error) {
	var (
		params    GistsListStarredParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGistsStarParams(args map[string]string, r *http.Request) (GistsStarParams, error) {
	var (
		params GistsStarParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsUnstarParams(args map[string]string, r *http.Request) (GistsUnstarParams, error) {
	var (
		params GistsUnstarParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	return params, nil
}

func decodeGistsUpdateCommentParams(args map[string]string, r *http.Request) (GistsUpdateCommentParams, error) {
	var (
		params GistsUpdateCommentParams
	)
	// Decode path: gist_id.
	{
		param := args["gist_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gist_id: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeGitCreateBlobParams(args map[string]string, r *http.Request) (GitCreateBlobParams, error) {
	var (
		params GitCreateBlobParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeGitCreateCommitParams(args map[string]string, r *http.Request) (GitCreateCommitParams, error) {
	var (
		params GitCreateCommitParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeGitCreateRefParams(args map[string]string, r *http.Request) (GitCreateRefParams, error) {
	var (
		params GitCreateRefParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeGitCreateTagParams(args map[string]string, r *http.Request) (GitCreateTagParams, error) {
	var (
		params GitCreateTagParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeGitCreateTreeParams(args map[string]string, r *http.Request) (GitCreateTreeParams, error) {
	var (
		params GitCreateTreeParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeGitDeleteRefParams(args map[string]string, r *http.Request) (GitDeleteRefParams, error) {
	var (
		params GitDeleteRefParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetBlobParams(args map[string]string, r *http.Request) (GitGetBlobParams, error) {
	var (
		params GitGetBlobParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: file_sha.
	{
		param := args["file_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.FileSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: file_sha: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetCommitParams(args map[string]string, r *http.Request) (GitGetCommitParams, error) {
	var (
		params GitGetCommitParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetRefParams(args map[string]string, r *http.Request) (GitGetRefParams, error) {
	var (
		params GitGetRefParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetTagParams(args map[string]string, r *http.Request) (GitGetTagParams, error) {
	var (
		params GitGetTagParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: tag_sha.
	{
		param := args["tag_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TagSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: tag_sha: not specified`)
		}
	}
	return params, nil
}

func decodeGitGetTreeParams(args map[string]string, r *http.Request) (GitGetTreeParams, error) {
	var (
		params    GitGetTreeParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: tree_sha.
	{
		param := args["tree_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tree_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TreeSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: tree_sha: not specified`)
		}
	}
	// Decode query: recursive.
	{
		values, ok := queryArgs["recursive"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRecursiveVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRecursiveVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Recursive.SetTo(paramsRecursiveVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: recursive: parse`)
			}
		}
	}
	return params, nil
}

func decodeGitListMatchingRefsParams(args map[string]string, r *http.Request) (GitListMatchingRefsParams, error) {
	var (
		params    GitListMatchingRefsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeGitUpdateRefParams(args map[string]string, r *http.Request) (GitUpdateRefParams, error) {
	var (
		params GitUpdateRefParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeGitignoreGetTemplateParams(args map[string]string, r *http.Request) (GitignoreGetTemplateParams, error) {
	var (
		params GitignoreGetTemplateParams
	)
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForOrgParams(args map[string]string, r *http.Request) (InteractionsRemoveRestrictionsForOrgParams, error) {
	var (
		params InteractionsRemoveRestrictionsForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForRepoParams(args map[string]string, r *http.Request) (InteractionsRemoveRestrictionsForRepoParams, error) {
	var (
		params InteractionsRemoveRestrictionsForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsSetRestrictionsForOrgParams(args map[string]string, r *http.Request) (InteractionsSetRestrictionsForOrgParams, error) {
	var (
		params InteractionsSetRestrictionsForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeInteractionsSetRestrictionsForRepoParams(args map[string]string, r *http.Request) (InteractionsSetRestrictionsForRepoParams, error) {
	var (
		params InteractionsSetRestrictionsForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesAddAssigneesParams(args map[string]string, r *http.Request) (IssuesAddAssigneesParams, error) {
	var (
		params IssuesAddAssigneesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCheckUserCanBeAssignedParams(args map[string]string, r *http.Request) (IssuesCheckUserCanBeAssignedParams, error) {
	var (
		params IssuesCheckUserCanBeAssignedParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: assignee.
	{
		param := args["assignee"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assignee",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Assignee = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: assignee: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCreateParams(args map[string]string, r *http.Request) (IssuesCreateParams, error) {
	var (
		params IssuesCreateParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCreateCommentParams(args map[string]string, r *http.Request) (IssuesCreateCommentParams, error) {
	var (
		params IssuesCreateCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCreateLabelParams(args map[string]string, r *http.Request) (IssuesCreateLabelParams, error) {
	var (
		params IssuesCreateLabelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesCreateMilestoneParams(args map[string]string, r *http.Request) (IssuesCreateMilestoneParams, error) {
	var (
		params IssuesCreateMilestoneParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteCommentParams(args map[string]string, r *http.Request) (IssuesDeleteCommentParams, error) {
	var (
		params IssuesDeleteCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteLabelParams(args map[string]string, r *http.Request) (IssuesDeleteLabelParams, error) {
	var (
		params IssuesDeleteLabelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesDeleteMilestoneParams(args map[string]string, r *http.Request) (IssuesDeleteMilestoneParams, error) {
	var (
		params IssuesDeleteMilestoneParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetParams(args map[string]string, r *http.Request) (IssuesGetParams, error) {
	var (
		params IssuesGetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetCommentParams(args map[string]string, r *http.Request) (IssuesGetCommentParams, error) {
	var (
		params IssuesGetCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetEventParams(args map[string]string, r *http.Request) (IssuesGetEventParams, error) {
	var (
		params IssuesGetEventParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: event_id.
	{
		param := args["event_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: event_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetLabelParams(args map[string]string, r *http.Request) (IssuesGetLabelParams, error) {
	var (
		params IssuesGetLabelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesGetMilestoneParams(args map[string]string, r *http.Request) (IssuesGetMilestoneParams, error) {
	var (
		params IssuesGetMilestoneParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesListParams(args map[string]string, r *http.Request) (IssuesListParams, error) {
	var (
		params    IssuesListParams
		queryArgs = r.URL.Query()
	)
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal IssuesListFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = IssuesListFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: labels.
	{
		values, ok := queryArgs["labels"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsLabelsVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsLabelsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: labels: parse`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: collab.
	{
		values, ok := queryArgs["collab"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCollabVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsCollabVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Collab.SetTo(paramsCollabVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: collab: parse`)
			}
		}
	}
	// Decode query: orgs.
	{
		values, ok := queryArgs["orgs"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrgsVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsOrgsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orgs.SetTo(paramsOrgsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: orgs: parse`)
			}
		}
	}
	// Decode query: owned.
	{
		values, ok := queryArgs["owned"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOwnedVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsOwnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Owned.SetTo(paramsOwnedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: owned: parse`)
			}
		}
	}
	// Decode query: pulls.
	{
		values, ok := queryArgs["pulls"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPullsVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsPullsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pulls.SetTo(paramsPullsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: pulls: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListAssigneesParams(args map[string]string, r *http.Request) (IssuesListAssigneesParams, error) {
	var (
		params    IssuesListAssigneesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListCommentsParams(args map[string]string, r *http.Request) (IssuesListCommentsParams, error) {
	var (
		params    IssuesListCommentsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListCommentsForRepoParams(args map[string]string, r *http.Request) (IssuesListCommentsForRepoParams, error) {
	var (
		params    IssuesListCommentsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListCommentsForRepoSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListCommentsForRepoDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListEventsForRepoParams(args map[string]string, r *http.Request) (IssuesListEventsForRepoParams, error) {
	var (
		params    IssuesListEventsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListForAuthenticatedUserParams(args map[string]string, r *http.Request) (IssuesListForAuthenticatedUserParams, error) {
	var (
		params    IssuesListForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal IssuesListForAuthenticatedUserFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = IssuesListForAuthenticatedUserFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListForAuthenticatedUserState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: labels.
	{
		values, ok := queryArgs["labels"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsLabelsVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsLabelsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: labels: parse`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListForAuthenticatedUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListForAuthenticatedUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListForOrgParams(args map[string]string, r *http.Request) (IssuesListForOrgParams, error) {
	var (
		params    IssuesListForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal IssuesListForOrgFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = IssuesListForOrgFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListForOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: labels.
	{
		values, ok := queryArgs["labels"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsLabelsVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsLabelsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: labels: parse`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListForOrgSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListForOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListForRepoParams(args map[string]string, r *http.Request) (IssuesListForRepoParams, error) {
	var (
		params    IssuesListForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: milestone.
	{
		values, ok := queryArgs["milestone"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsMilestoneVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsMilestoneVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Milestone.SetTo(paramsMilestoneVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: milestone: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListForRepoState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: assignee.
	{
		values, ok := queryArgs["assignee"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAssigneeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAssigneeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Assignee.SetTo(paramsAssigneeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: assignee: parse`)
			}
		}
	}
	// Decode query: creator.
	{
		values, ok := queryArgs["creator"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCreatorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCreatorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Creator.SetTo(paramsCreatorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: creator: parse`)
			}
		}
	}
	// Decode query: mentioned.
	{
		values, ok := queryArgs["mentioned"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsMentionedVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsMentionedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mentioned.SetTo(paramsMentionedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: mentioned: parse`)
			}
		}
	}
	// Decode query: labels.
	{
		values, ok := queryArgs["labels"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsLabelsVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsLabelsVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: labels: parse`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListForRepoSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListForRepoDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForMilestoneParams(args map[string]string, r *http.Request) (IssuesListLabelsForMilestoneParams, error) {
	var (
		params    IssuesListLabelsForMilestoneParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForRepoParams(args map[string]string, r *http.Request) (IssuesListLabelsForRepoParams, error) {
	var (
		params    IssuesListLabelsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsOnIssueParams(args map[string]string, r *http.Request) (IssuesListLabelsOnIssueParams, error) {
	var (
		params    IssuesListLabelsOnIssueParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesListMilestonesParams(args map[string]string, r *http.Request) (IssuesListMilestonesParams, error) {
	var (
		params    IssuesListMilestonesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal IssuesListMilestonesState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = IssuesListMilestonesState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal IssuesListMilestonesSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = IssuesListMilestonesSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal IssuesListMilestonesDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = IssuesListMilestonesDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeIssuesLockParams(args map[string]string, r *http.Request) (IssuesLockParams, error) {
	var (
		params IssuesLockParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesRemoveAllLabelsParams(args map[string]string, r *http.Request) (IssuesRemoveAllLabelsParams, error) {
	var (
		params IssuesRemoveAllLabelsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesRemoveAssigneesParams(args map[string]string, r *http.Request) (IssuesRemoveAssigneesParams, error) {
	var (
		params IssuesRemoveAssigneesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesRemoveLabelParams(args map[string]string, r *http.Request) (IssuesRemoveLabelParams, error) {
	var (
		params IssuesRemoveLabelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUnlockParams(args map[string]string, r *http.Request) (IssuesUnlockParams, error) {
	var (
		params IssuesUnlockParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateParams(args map[string]string, r *http.Request) (IssuesUpdateParams, error) {
	var (
		params IssuesUpdateParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateCommentParams(args map[string]string, r *http.Request) (IssuesUpdateCommentParams, error) {
	var (
		params IssuesUpdateCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateLabelParams(args map[string]string, r *http.Request) (IssuesUpdateLabelParams, error) {
	var (
		params IssuesUpdateLabelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: name.
	{
		param := args["name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: name: not specified`)
		}
	}
	return params, nil
}

func decodeIssuesUpdateMilestoneParams(args map[string]string, r *http.Request) (IssuesUpdateMilestoneParams, error) {
	var (
		params IssuesUpdateMilestoneParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: milestone_number.
	{
		param := args["milestone_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: milestone_number: not specified`)
		}
	}
	return params, nil
}

func decodeLicensesGetParams(args map[string]string, r *http.Request) (LicensesGetParams, error) {
	var (
		params LicensesGetParams
	)
	// Decode path: license.
	{
		param := args["license"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "license",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.License = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: license: not specified`)
		}
	}
	return params, nil
}

func decodeLicensesGetAllCommonlyUsedParams(args map[string]string, r *http.Request) (LicensesGetAllCommonlyUsedParams, error) {
	var (
		params    LicensesGetAllCommonlyUsedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: featured.
	{
		values, ok := queryArgs["featured"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFeaturedVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsFeaturedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Featured.SetTo(paramsFeaturedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: featured: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeLicensesGetForRepoParams(args map[string]string, r *http.Request) (LicensesGetForRepoParams, error) {
	var (
		params LicensesGetForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsCancelImportParams(args map[string]string, r *http.Request) (MigrationsCancelImportParams, error) {
	var (
		params MigrationsCancelImportParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsDeleteArchiveForAuthenticatedUserParams, error) {
	var (
		params MigrationsDeleteArchiveForAuthenticatedUserParams
	)
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForOrgParams(args map[string]string, r *http.Request) (MigrationsDeleteArchiveForOrgParams, error) {
	var (
		params MigrationsDeleteArchiveForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsDownloadArchiveForOrgParams(args map[string]string, r *http.Request) (MigrationsDownloadArchiveForOrgParams, error) {
	var (
		params MigrationsDownloadArchiveForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsGetArchiveForAuthenticatedUserParams, error) {
	var (
		params MigrationsGetArchiveForAuthenticatedUserParams
	)
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetCommitAuthorsParams(args map[string]string, r *http.Request) (MigrationsGetCommitAuthorsParams, error) {
	var (
		params    MigrationsGetCommitAuthorsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetImportStatusParams(args map[string]string, r *http.Request) (MigrationsGetImportStatusParams, error) {
	var (
		params MigrationsGetImportStatusParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetLargeFilesParams(args map[string]string, r *http.Request) (MigrationsGetLargeFilesParams, error) {
	var (
		params MigrationsGetLargeFilesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsGetStatusForAuthenticatedUserParams, error) {
	var (
		params    MigrationsGetStatusForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: exclude.
	{
		values, ok := queryArgs["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal string
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForOrgParams(args map[string]string, r *http.Request) (MigrationsGetStatusForOrgParams, error) {
	var (
		params    MigrationsGetStatusForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: exclude.
	{
		values, ok := queryArgs["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal MigrationsGetStatusForOrgExcludeItem
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = MigrationsGetStatusForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: invalid`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsListForAuthenticatedUserParams, error) {
	var (
		params    MigrationsListForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForOrgParams(args map[string]string, r *http.Request) (MigrationsListForOrgParams, error) {
	var (
		params    MigrationsListForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: exclude.
	{
		values, ok := queryArgs["exclude"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsExcludeVal MigrationsListForOrgExcludeItem
					if err := func() error {
						s, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(s)
						if err != nil {
							return err
						}

						paramsExcludeVal = MigrationsListForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsExcludeVal)
					return nil
				})
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: parse`)
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: exclude: invalid`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForOrgParams(args map[string]string, r *http.Request) (MigrationsListReposForOrgParams, error) {
	var (
		params    MigrationsListReposForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForUserParams(args map[string]string, r *http.Request) (MigrationsListReposForUserParams, error) {
	var (
		params    MigrationsListReposForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeMigrationsMapCommitAuthorParams(args map[string]string, r *http.Request) (MigrationsMapCommitAuthorParams, error) {
	var (
		params MigrationsMapCommitAuthorParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: author_id.
	{
		param := args["author_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "author_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: author_id: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsSetLfsPreferenceParams(args map[string]string, r *http.Request) (MigrationsSetLfsPreferenceParams, error) {
	var (
		params MigrationsSetLfsPreferenceParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsStartForOrgParams(args map[string]string, r *http.Request) (MigrationsStartForOrgParams, error) {
	var (
		params MigrationsStartForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsStartImportParams(args map[string]string, r *http.Request) (MigrationsStartImportParams, error) {
	var (
		params MigrationsStartImportParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(args map[string]string, r *http.Request) (MigrationsUnlockRepoForAuthenticatedUserParams, error) {
	var (
		params MigrationsUnlockRepoForAuthenticatedUserParams
	)
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode path: repo_name.
	{
		param := args["repo_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo_name: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForOrgParams(args map[string]string, r *http.Request) (MigrationsUnlockRepoForOrgParams, error) {
	var (
		params MigrationsUnlockRepoForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: migration_id.
	{
		param := args["migration_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: migration_id: not specified`)
		}
	}
	// Decode path: repo_name.
	{
		param := args["repo_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo_name: not specified`)
		}
	}
	return params, nil
}

func decodeMigrationsUpdateImportParams(args map[string]string, r *http.Request) (MigrationsUpdateImportParams, error) {
	var (
		params MigrationsUpdateImportParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(args map[string]string, r *http.Request) (OAuthAuthorizationsDeleteAuthorizationParams, error) {
	var (
		params OAuthAuthorizationsDeleteAuthorizationParams
	)
	// Decode path: authorization_id.
	{
		param := args["authorization_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: authorization_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteGrantParams(args map[string]string, r *http.Request) (OAuthAuthorizationsDeleteGrantParams, error) {
	var (
		params OAuthAuthorizationsDeleteGrantParams
	)
	// Decode path: grant_id.
	{
		param := args["grant_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: grant_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetAuthorizationParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetAuthorizationParams, error) {
	var (
		params OAuthAuthorizationsGetAuthorizationParams
	)
	// Decode path: authorization_id.
	{
		param := args["authorization_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: authorization_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetGrantParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetGrantParams, error) {
	var (
		params OAuthAuthorizationsGetGrantParams
	)
	// Decode path: grant_id.
	{
		param := args["grant_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: grant_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetOrCreateAuthorizationForAppParams, error) {
	var (
		params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args map[string]string, r *http.Request) (OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams, error) {
	var (
		params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams
	)
	// Decode path: client_id.
	{
		param := args["client_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: client_id: not specified`)
		}
	}
	// Decode path: fingerprint.
	{
		param := args["fingerprint"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fingerprint",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Fingerprint = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: fingerprint: not specified`)
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListAuthorizationsParams(args map[string]string, r *http.Request) (OAuthAuthorizationsListAuthorizationsParams, error) {
	var (
		params    OAuthAuthorizationsListAuthorizationsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: client_id.
	{
		values, ok := queryArgs["client_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsClientIDVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsClientIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: client_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListGrantsParams(args map[string]string, r *http.Request) (OAuthAuthorizationsListGrantsParams, error) {
	var (
		params    OAuthAuthorizationsListGrantsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: client_id.
	{
		values, ok := queryArgs["client_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsClientIDVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsClientIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: client_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsUpdateAuthorizationParams(args map[string]string, r *http.Request) (OAuthAuthorizationsUpdateAuthorizationParams, error) {
	var (
		params OAuthAuthorizationsUpdateAuthorizationParams
	)
	// Decode path: authorization_id.
	{
		param := args["authorization_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: authorization_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsBlockUserParams(args map[string]string, r *http.Request) (OrgsBlockUserParams, error) {
	var (
		params OrgsBlockUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCancelInvitationParams(args map[string]string, r *http.Request) (OrgsCancelInvitationParams, error) {
	var (
		params OrgsCancelInvitationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCheckBlockedUserParams(args map[string]string, r *http.Request) (OrgsCheckBlockedUserParams, error) {
	var (
		params OrgsCheckBlockedUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCheckMembershipForUserParams(args map[string]string, r *http.Request) (OrgsCheckMembershipForUserParams, error) {
	var (
		params OrgsCheckMembershipForUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCheckPublicMembershipForUserParams(args map[string]string, r *http.Request) (OrgsCheckPublicMembershipForUserParams, error) {
	var (
		params OrgsCheckPublicMembershipForUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(args map[string]string, r *http.Request) (OrgsConvertMemberToOutsideCollaboratorParams, error) {
	var (
		params OrgsConvertMemberToOutsideCollaboratorParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCreateInvitationParams(args map[string]string, r *http.Request) (OrgsCreateInvitationParams, error) {
	var (
		params OrgsCreateInvitationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsCreateWebhookParams(args map[string]string, r *http.Request) (OrgsCreateWebhookParams, error) {
	var (
		params OrgsCreateWebhookParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsDeleteWebhookParams(args map[string]string, r *http.Request) (OrgsDeleteWebhookParams, error) {
	var (
		params OrgsDeleteWebhookParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetParams(args map[string]string, r *http.Request) (OrgsGetParams, error) {
	var (
		params OrgsGetParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetAuditLogParams(args map[string]string, r *http.Request) (OrgsGetAuditLogParams, error) {
	var (
		params    OrgsGetAuditLogParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: phrase.
	{
		values, ok := queryArgs["phrase"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPhraseVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsPhraseVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: phrase: parse`)
			}
		}
	}
	// Decode query: include.
	{
		values, ok := queryArgs["include"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsIncludeVal OrgsGetAuditLogInclude
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsIncludeVal = OrgsGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsIncludeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: parse`)
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: include: invalid`)
			}
		}
	}
	// Decode query: after.
	{
		values, ok := queryArgs["after"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAfterVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsAfterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: after: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := queryArgs["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal OrgsGetAuditLogOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = OrgsGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsGetMembershipForAuthenticatedUserParams, error) {
	var (
		params OrgsGetMembershipForAuthenticatedUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForUserParams(args map[string]string, r *http.Request) (OrgsGetMembershipForUserParams, error) {
	var (
		params OrgsGetMembershipForUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookParams(args map[string]string, r *http.Request) (OrgsGetWebhookParams, error) {
	var (
		params OrgsGetWebhookParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookConfigForOrgParams(args map[string]string, r *http.Request) (OrgsGetWebhookConfigForOrgParams, error) {
	var (
		params OrgsGetWebhookConfigForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookDeliveryParams(args map[string]string, r *http.Request) (OrgsGetWebhookDeliveryParams, error) {
	var (
		params OrgsGetWebhookDeliveryParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListParams(args map[string]string, r *http.Request) (OrgsListParams, error) {
	var (
		params    OrgsListParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListBlockedUsersParams(args map[string]string, r *http.Request) (OrgsListBlockedUsersParams, error) {
	var (
		params OrgsListBlockedUsersParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListFailedInvitationsParams(args map[string]string, r *http.Request) (OrgsListFailedInvitationsParams, error) {
	var (
		params    OrgsListFailedInvitationsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsListForAuthenticatedUserParams, error) {
	var (
		params    OrgsListForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListForUserParams(args map[string]string, r *http.Request) (OrgsListForUserParams, error) {
	var (
		params    OrgsListForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListInvitationTeamsParams(args map[string]string, r *http.Request) (OrgsListInvitationTeamsParams, error) {
	var (
		params    OrgsListInvitationTeamsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListMembersParams(args map[string]string, r *http.Request) (OrgsListMembersParams, error) {
	var (
		params    OrgsListMembersParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal OrgsListMembersFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = OrgsListMembersFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: role.
	{
		values, ok := queryArgs["role"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRoleVal OrgsListMembersRole
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRoleVal = OrgsListMembersRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsRoleVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: parse`)
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListMembershipsForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsListMembershipsForAuthenticatedUserParams, error) {
	var (
		params    OrgsListMembershipsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal OrgsListMembershipsForAuthenticatedUserState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = OrgsListMembershipsForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListOutsideCollaboratorsParams(args map[string]string, r *http.Request) (OrgsListOutsideCollaboratorsParams, error) {
	var (
		params    OrgsListOutsideCollaboratorsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: filter.
	{
		values, ok := queryArgs["filter"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsFilterVal OrgsListOutsideCollaboratorsFilter
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsFilterVal = OrgsListOutsideCollaboratorsFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsFilterVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: parse`)
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: filter: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListPendingInvitationsParams(args map[string]string, r *http.Request) (OrgsListPendingInvitationsParams, error) {
	var (
		params    OrgsListPendingInvitationsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListPublicMembersParams(args map[string]string, r *http.Request) (OrgsListPublicMembersParams, error) {
	var (
		params    OrgsListPublicMembersParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListSamlSSOAuthorizationsParams(args map[string]string, r *http.Request) (OrgsListSamlSSOAuthorizationsParams, error) {
	var (
		params OrgsListSamlSSOAuthorizationsParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsListWebhookDeliveriesParams(args map[string]string, r *http.Request) (OrgsListWebhookDeliveriesParams, error) {
	var (
		params    OrgsListWebhookDeliveriesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: cursor.
	{
		values, ok := queryArgs["cursor"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCursorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsCursorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: cursor: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsListWebhooksParams(args map[string]string, r *http.Request) (OrgsListWebhooksParams, error) {
	var (
		params    OrgsListWebhooksParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeOrgsPingWebhookParams(args map[string]string, r *http.Request) (OrgsPingWebhookParams, error) {
	var (
		params OrgsPingWebhookParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRedeliverWebhookDeliveryParams(args map[string]string, r *http.Request) (OrgsRedeliverWebhookDeliveryParams, error) {
	var (
		params OrgsRedeliverWebhookDeliveryParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveMemberParams(args map[string]string, r *http.Request) (OrgsRemoveMemberParams, error) {
	var (
		params OrgsRemoveMemberParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveMembershipForUserParams(args map[string]string, r *http.Request) (OrgsRemoveMembershipForUserParams, error) {
	var (
		params OrgsRemoveMembershipForUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveOutsideCollaboratorParams(args map[string]string, r *http.Request) (OrgsRemoveOutsideCollaboratorParams, error) {
	var (
		params OrgsRemoveOutsideCollaboratorParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsRemovePublicMembershipForAuthenticatedUserParams, error) {
	var (
		params OrgsRemovePublicMembershipForAuthenticatedUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(args map[string]string, r *http.Request) (OrgsRemoveSamlSSOAuthorizationParams, error) {
	var (
		params OrgsRemoveSamlSSOAuthorizationParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: credential_id.
	{
		param := args["credential_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "credential_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CredentialID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: credential_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsSetMembershipForUserParams(args map[string]string, r *http.Request) (OrgsSetMembershipForUserParams, error) {
	var (
		params OrgsSetMembershipForUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsSetPublicMembershipForAuthenticatedUserParams, error) {
	var (
		params OrgsSetPublicMembershipForAuthenticatedUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUnblockUserParams(args map[string]string, r *http.Request) (OrgsUnblockUserParams, error) {
	var (
		params OrgsUnblockUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUpdateMembershipForAuthenticatedUserParams(args map[string]string, r *http.Request) (OrgsUpdateMembershipForAuthenticatedUserParams, error) {
	var (
		params OrgsUpdateMembershipForAuthenticatedUserParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUpdateWebhookParams(args map[string]string, r *http.Request) (OrgsUpdateWebhookParams, error) {
	var (
		params OrgsUpdateWebhookParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeOrgsUpdateWebhookConfigForOrgParams(args map[string]string, r *http.Request) (OrgsUpdateWebhookConfigForOrgParams, error) {
	var (
		params OrgsUpdateWebhookConfigForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageForAuthenticatedUserParams, error) {
	var (
		params PackagesDeletePackageForAuthenticatedUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForOrgParams(args map[string]string, r *http.Request) (PackagesDeletePackageForOrgParams, error) {
	var (
		params PackagesDeletePackageForOrgParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageForUserParams, error) {
	var (
		params PackagesDeletePackageForUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForAuthenticatedUserParams, error) {
	var (
		params PackagesDeletePackageVersionForAuthenticatedUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForOrgParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForOrgParams, error) {
	var (
		params PackagesDeletePackageVersionForOrgParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesDeletePackageVersionForUserParams, error) {
	var (
		params PackagesDeletePackageVersionForUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, error) {
	var (
		params    PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByOrgParams, error) {
	var (
		params    PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal PackagesGetAllPackageVersionsForPackageOwnedByOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args map[string]string, r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByUserParams, error) {
	var (
		params PackagesGetAllPackageVersionsForPackageOwnedByUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetPackageForAuthenticatedUserParams, error) {
	var (
		params PackagesGetPackageForAuthenticatedUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForOrganizationParams(args map[string]string, r *http.Request) (PackagesGetPackageForOrganizationParams, error) {
	var (
		params PackagesGetPackageForOrganizationParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageForUserParams(args map[string]string, r *http.Request) (PackagesGetPackageForUserParams, error) {
	var (
		params PackagesGetPackageForUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForAuthenticatedUserParams, error) {
	var (
		params PackagesGetPackageVersionForAuthenticatedUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForOrganizationParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForOrganizationParams, error) {
	var (
		params PackagesGetPackageVersionForOrganizationParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesGetPackageVersionForUserParams, error) {
	var (
		params PackagesGetPackageVersionForUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesListPackagesForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesListPackagesForAuthenticatedUserParams, error) {
	var (
		params    PackagesListPackagesForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: package_type.
	{
		values, ok := queryArgs["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := queryArgs["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForAuthenticatedUserVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForOrganizationParams(args map[string]string, r *http.Request) (PackagesListPackagesForOrganizationParams, error) {
	var (
		params    PackagesListPackagesForOrganizationParams
		queryArgs = r.URL.Query()
	)
	// Decode query: package_type.
	{
		values, ok := queryArgs["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := queryArgs["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForOrganizationVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForOrganizationVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForUserParams(args map[string]string, r *http.Request) (PackagesListPackagesForUserParams, error) {
	var (
		params    PackagesListPackagesForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: package_type.
	{
		values, ok := queryArgs["package_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: parse`)
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: package_type: invalid`)
			}
		} else {
			return params, errors.New(`query: package_type: not specified`)
		}
	}
	// Decode query: visibility.
	{
		values, ok := queryArgs["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal PackagesListPackagesForUserVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = PackagesListPackagesForUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageForAuthenticatedUserParams, error) {
	var (
		params    PackagesRestorePackageForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := queryArgs["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForOrgParams(args map[string]string, r *http.Request) (PackagesRestorePackageForOrgParams, error) {
	var (
		params    PackagesRestorePackageForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := queryArgs["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageForUserParams, error) {
	var (
		params    PackagesRestorePackageForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: token.
	{
		values, ok := queryArgs["token"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTokenVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsTokenVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: token: parse`)
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForAuthenticatedUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForAuthenticatedUserParams, error) {
	var (
		params PackagesRestorePackageVersionForAuthenticatedUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForOrgParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForOrgParams, error) {
	var (
		params PackagesRestorePackageVersionForOrgParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForUserParams(args map[string]string, r *http.Request) (PackagesRestorePackageVersionForUserParams, error) {
	var (
		params PackagesRestorePackageVersionForUserParams
	)
	// Decode path: package_type.
	{
		param := args["package_type"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_type: not specified`)
		}
	}
	// Decode path: package_name.
	{
		param := args["package_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_name: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: package_version_id.
	{
		param := args["package_version_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: package_version_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsAddCollaboratorParams(args map[string]string, r *http.Request) (ProjectsAddCollaboratorParams, error) {
	var (
		params ProjectsAddCollaboratorParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateColumnParams(args map[string]string, r *http.Request) (ProjectsCreateColumnParams, error) {
	var (
		params ProjectsCreateColumnParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateForOrgParams(args map[string]string, r *http.Request) (ProjectsCreateForOrgParams, error) {
	var (
		params ProjectsCreateForOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsCreateForRepoParams(args map[string]string, r *http.Request) (ProjectsCreateForRepoParams, error) {
	var (
		params ProjectsCreateForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteParams(args map[string]string, r *http.Request) (ProjectsDeleteParams, error) {
	var (
		params ProjectsDeleteParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteCardParams(args map[string]string, r *http.Request) (ProjectsDeleteCardParams, error) {
	var (
		params ProjectsDeleteCardParams
	)
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsDeleteColumnParams(args map[string]string, r *http.Request) (ProjectsDeleteColumnParams, error) {
	var (
		params ProjectsDeleteColumnParams
	)
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetParams(args map[string]string, r *http.Request) (ProjectsGetParams, error) {
	var (
		params ProjectsGetParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetCardParams(args map[string]string, r *http.Request) (ProjectsGetCardParams, error) {
	var (
		params ProjectsGetCardParams
	)
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetColumnParams(args map[string]string, r *http.Request) (ProjectsGetColumnParams, error) {
	var (
		params ProjectsGetColumnParams
	)
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsGetPermissionForUserParams(args map[string]string, r *http.Request) (ProjectsGetPermissionForUserParams, error) {
	var (
		params ProjectsGetPermissionForUserParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsListCardsParams(args map[string]string, r *http.Request) (ProjectsListCardsParams, error) {
	var (
		params    ProjectsListCardsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	// Decode query: archived_state.
	{
		values, ok := queryArgs["archived_state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsArchivedStateVal ProjectsListCardsArchivedState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsArchivedStateVal = ProjectsListCardsArchivedState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.ArchivedState.SetTo(paramsArchivedStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: archived_state: parse`)
			}
			if err := func() error {
				if params.ArchivedState.Set {
					if err := func() error {
						if err := params.ArchivedState.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: archived_state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListCollaboratorsParams(args map[string]string, r *http.Request) (ProjectsListCollaboratorsParams, error) {
	var (
		params    ProjectsListCollaboratorsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode query: affiliation.
	{
		values, ok := queryArgs["affiliation"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAffiliationVal ProjectsListCollaboratorsAffiliation
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAffiliationVal = ProjectsListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsAffiliationVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: parse`)
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListColumnsParams(args map[string]string, r *http.Request) (ProjectsListColumnsParams, error) {
	var (
		params    ProjectsListColumnsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListForOrgParams(args map[string]string, r *http.Request) (ProjectsListForOrgParams, error) {
	var (
		params    ProjectsListForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal ProjectsListForOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = ProjectsListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListForRepoParams(args map[string]string, r *http.Request) (ProjectsListForRepoParams, error) {
	var (
		params    ProjectsListForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal ProjectsListForRepoState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = ProjectsListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsListForUserParams(args map[string]string, r *http.Request) (ProjectsListForUserParams, error) {
	var (
		params    ProjectsListForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal ProjectsListForUserState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = ProjectsListForUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeProjectsMoveCardParams(args map[string]string, r *http.Request) (ProjectsMoveCardParams, error) {
	var (
		params ProjectsMoveCardParams
	)
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsMoveColumnParams(args map[string]string, r *http.Request) (ProjectsMoveColumnParams, error) {
	var (
		params ProjectsMoveColumnParams
	)
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsRemoveCollaboratorParams(args map[string]string, r *http.Request) (ProjectsRemoveCollaboratorParams, error) {
	var (
		params ProjectsRemoveCollaboratorParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateParams(args map[string]string, r *http.Request) (ProjectsUpdateParams, error) {
	var (
		params ProjectsUpdateParams
	)
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateCardParams(args map[string]string, r *http.Request) (ProjectsUpdateCardParams, error) {
	var (
		params ProjectsUpdateCardParams
	)
	// Decode path: card_id.
	{
		param := args["card_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: card_id: not specified`)
		}
	}
	return params, nil
}

func decodeProjectsUpdateColumnParams(args map[string]string, r *http.Request) (ProjectsUpdateColumnParams, error) {
	var (
		params ProjectsUpdateColumnParams
	)
	// Decode path: column_id.
	{
		param := args["column_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: column_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsCheckIfMergedParams(args map[string]string, r *http.Request) (PullsCheckIfMergedParams, error) {
	var (
		params PullsCheckIfMergedParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateParams(args map[string]string, r *http.Request) (PullsCreateParams, error) {
	var (
		params PullsCreateParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateReplyForReviewCommentParams(args map[string]string, r *http.Request) (PullsCreateReplyForReviewCommentParams, error) {
	var (
		params PullsCreateReplyForReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateReviewParams(args map[string]string, r *http.Request) (PullsCreateReviewParams, error) {
	var (
		params PullsCreateReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsCreateReviewCommentParams(args map[string]string, r *http.Request) (PullsCreateReviewCommentParams, error) {
	var (
		params PullsCreateReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsDeletePendingReviewParams(args map[string]string, r *http.Request) (PullsDeletePendingReviewParams, error) {
	var (
		params PullsDeletePendingReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsDeleteReviewCommentParams(args map[string]string, r *http.Request) (PullsDeleteReviewCommentParams, error) {
	var (
		params PullsDeleteReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsDismissReviewParams(args map[string]string, r *http.Request) (PullsDismissReviewParams, error) {
	var (
		params PullsDismissReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetParams(args map[string]string, r *http.Request) (PullsGetParams, error) {
	var (
		params PullsGetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetReviewParams(args map[string]string, r *http.Request) (PullsGetReviewParams, error) {
	var (
		params PullsGetReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsGetReviewCommentParams(args map[string]string, r *http.Request) (PullsGetReviewCommentParams, error) {
	var (
		params PullsGetReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsListParams(args map[string]string, r *http.Request) (PullsListParams, error) {
	var (
		params    PullsListParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal PullsListState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = PullsListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: head.
	{
		values, ok := queryArgs["head"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsHeadVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsHeadVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Head.SetTo(paramsHeadVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: head: parse`)
			}
		}
	}
	// Decode query: base.
	{
		values, ok := queryArgs["base"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBaseVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsBaseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Base.SetTo(paramsBaseVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: base: parse`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal PullsListSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = PullsListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal PullsListDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = PullsListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListCommentsForReviewParams(args map[string]string, r *http.Request) (PullsListCommentsForReviewParams, error) {
	var (
		params    PullsListCommentsForReviewParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListCommitsParams(args map[string]string, r *http.Request) (PullsListCommitsParams, error) {
	var (
		params    PullsListCommitsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListFilesParams(args map[string]string, r *http.Request) (PullsListFilesParams, error) {
	var (
		params    PullsListFilesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListRequestedReviewersParams(args map[string]string, r *http.Request) (PullsListRequestedReviewersParams, error) {
	var (
		params    PullsListRequestedReviewersParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsParams(args map[string]string, r *http.Request) (PullsListReviewCommentsParams, error) {
	var (
		params    PullsListReviewCommentsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal PullsListReviewCommentsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = PullsListReviewCommentsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal PullsListReviewCommentsDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = PullsListReviewCommentsDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsForRepoParams(args map[string]string, r *http.Request) (PullsListReviewCommentsForRepoParams, error) {
	var (
		params    PullsListReviewCommentsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal PullsListReviewCommentsForRepoSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = PullsListReviewCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal PullsListReviewCommentsForRepoDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = PullsListReviewCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsListReviewsParams(args map[string]string, r *http.Request) (PullsListReviewsParams, error) {
	var (
		params    PullsListReviewsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodePullsMergeParams(args map[string]string, r *http.Request) (PullsMergeParams, error) {
	var (
		params PullsMergeParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsRemoveRequestedReviewersParams(args map[string]string, r *http.Request) (PullsRemoveRequestedReviewersParams, error) {
	var (
		params PullsRemoveRequestedReviewersParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsSubmitReviewParams(args map[string]string, r *http.Request) (PullsSubmitReviewParams, error) {
	var (
		params PullsSubmitReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateParams(args map[string]string, r *http.Request) (PullsUpdateParams, error) {
	var (
		params PullsUpdateParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateBranchParams(args map[string]string, r *http.Request) (PullsUpdateBranchParams, error) {
	var (
		params PullsUpdateBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateReviewParams(args map[string]string, r *http.Request) (PullsUpdateReviewParams, error) {
	var (
		params PullsUpdateReviewParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: pull_number.
	{
		param := args["pull_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: pull_number: not specified`)
		}
	}
	// Decode path: review_id.
	{
		param := args["review_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: review_id: not specified`)
		}
	}
	return params, nil
}

func decodePullsUpdateReviewCommentParams(args map[string]string, r *http.Request) (PullsUpdateReviewCommentParams, error) {
	var (
		params PullsUpdateReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForCommitCommentParams(args map[string]string, r *http.Request) (ReactionsCreateForCommitCommentParams, error) {
	var (
		params ReactionsCreateForCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForIssueParams(args map[string]string, r *http.Request) (ReactionsCreateForIssueParams, error) {
	var (
		params ReactionsCreateForIssueParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForIssueCommentParams(args map[string]string, r *http.Request) (ReactionsCreateForIssueCommentParams, error) {
	var (
		params ReactionsCreateForIssueCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForPullRequestReviewCommentParams(args map[string]string, r *http.Request) (ReactionsCreateForPullRequestReviewCommentParams, error) {
	var (
		params ReactionsCreateForPullRequestReviewCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForReleaseParams(args map[string]string, r *http.Request) (ReactionsCreateForReleaseParams, error) {
	var (
		params ReactionsCreateForReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionCommentInOrgParams, error) {
	var (
		params ReactionsCreateForTeamDiscussionCommentInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionCommentLegacyParams, error) {
	var (
		params ReactionsCreateForTeamDiscussionCommentLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionInOrgParams, error) {
	var (
		params ReactionsCreateForTeamDiscussionInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(args map[string]string, r *http.Request) (ReactionsCreateForTeamDiscussionLegacyParams, error) {
	var (
		params ReactionsCreateForTeamDiscussionLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForCommitCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForCommitCommentParams, error) {
	var (
		params ReactionsDeleteForCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueParams(args map[string]string, r *http.Request) (ReactionsDeleteForIssueParams, error) {
	var (
		params ReactionsDeleteForIssueParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForIssueCommentParams, error) {
	var (
		params ReactionsDeleteForIssueCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForPullRequestCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForPullRequestCommentParams, error) {
	var (
		params ReactionsDeleteForPullRequestCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionParams(args map[string]string, r *http.Request) (ReactionsDeleteForTeamDiscussionParams, error) {
	var (
		params ReactionsDeleteForTeamDiscussionParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(args map[string]string, r *http.Request) (ReactionsDeleteForTeamDiscussionCommentParams, error) {
	var (
		params ReactionsDeleteForTeamDiscussionCommentParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsDeleteLegacyParams(args map[string]string, r *http.Request) (ReactionsDeleteLegacyParams, error) {
	var (
		params ReactionsDeleteLegacyParams
	)
	// Decode path: reaction_id.
	{
		param := args["reaction_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: reaction_id: not specified`)
		}
	}
	return params, nil
}

func decodeReactionsListForCommitCommentParams(args map[string]string, r *http.Request) (ReactionsListForCommitCommentParams, error) {
	var (
		params    ReactionsListForCommitCommentParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForCommitCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForCommitCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueParams(args map[string]string, r *http.Request) (ReactionsListForIssueParams, error) {
	var (
		params    ReactionsListForIssueParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: issue_number.
	{
		param := args["issue_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: issue_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForIssueContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForIssueContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueCommentParams(args map[string]string, r *http.Request) (ReactionsListForIssueCommentParams, error) {
	var (
		params    ReactionsListForIssueCommentParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForIssueCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForIssueCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForPullRequestReviewCommentParams(args map[string]string, r *http.Request) (ReactionsListForPullRequestReviewCommentParams, error) {
	var (
		params    ReactionsListForPullRequestReviewCommentParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForPullRequestReviewCommentContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForPullRequestReviewCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionCommentInOrgParams, error) {
	var (
		params    ReactionsListForTeamDiscussionCommentInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionCommentInOrgContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionCommentInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionCommentLegacyParams, error) {
	var (
		params    ReactionsListForTeamDiscussionCommentLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionCommentLegacyContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionCommentLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionInOrgParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionInOrgParams, error) {
	var (
		params    ReactionsListForTeamDiscussionInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionInOrgContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionLegacyParams(args map[string]string, r *http.Request) (ReactionsListForTeamDiscussionLegacyParams, error) {
	var (
		params    ReactionsListForTeamDiscussionLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: content.
	{
		values, ok := queryArgs["content"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsContentVal ReactionsListForTeamDiscussionLegacyContent
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsContentVal = ReactionsListForTeamDiscussionLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsContentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: parse`)
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: content: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposAcceptInvitationParams(args map[string]string, r *http.Request) (ReposAcceptInvitationParams, error) {
	var (
		params ReposAcceptInvitationParams
	)
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposAddAppAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposAddAppAccessRestrictionsParams, error) {
	var (
		params ReposAddAppAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposAddCollaboratorParams(args map[string]string, r *http.Request) (ReposAddCollaboratorParams, error) {
	var (
		params ReposAddCollaboratorParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposAddStatusCheckContextsParams(args map[string]string, r *http.Request) (ReposAddStatusCheckContextsParams, error) {
	var (
		params ReposAddStatusCheckContextsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposAddTeamAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposAddTeamAccessRestrictionsParams, error) {
	var (
		params ReposAddTeamAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposAddUserAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposAddUserAccessRestrictionsParams, error) {
	var (
		params ReposAddUserAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposCheckCollaboratorParams(args map[string]string, r *http.Request) (ReposCheckCollaboratorParams, error) {
	var (
		params ReposCheckCollaboratorParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposCheckVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposCheckVulnerabilityAlertsParams, error) {
	var (
		params ReposCheckVulnerabilityAlertsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCompareCommitsParams(args map[string]string, r *http.Request) (ReposCompareCommitsParams, error) {
	var (
		params    ReposCompareCommitsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode path: basehead.
	{
		param := args["basehead"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "basehead",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Basehead = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: basehead: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateAutolinkParams(args map[string]string, r *http.Request) (ReposCreateAutolinkParams, error) {
	var (
		params ReposCreateAutolinkParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateCommitCommentParams(args map[string]string, r *http.Request) (ReposCreateCommitCommentParams, error) {
	var (
		params ReposCreateCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposCreateCommitSignatureProtectionParams, error) {
	var (
		params ReposCreateCommitSignatureProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateCommitStatusParams(args map[string]string, r *http.Request) (ReposCreateCommitStatusParams, error) {
	var (
		params ReposCreateCommitStatusParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: sha.
	{
		param := args["sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: sha: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateDeployKeyParams(args map[string]string, r *http.Request) (ReposCreateDeployKeyParams, error) {
	var (
		params ReposCreateDeployKeyParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateDeploymentParams(args map[string]string, r *http.Request) (ReposCreateDeploymentParams, error) {
	var (
		params ReposCreateDeploymentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateDeploymentStatusParams(args map[string]string, r *http.Request) (ReposCreateDeploymentStatusParams, error) {
	var (
		params ReposCreateDeploymentStatusParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateDispatchEventParams(args map[string]string, r *http.Request) (ReposCreateDispatchEventParams, error) {
	var (
		params ReposCreateDispatchEventParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateForkParams(args map[string]string, r *http.Request) (ReposCreateForkParams, error) {
	var (
		params ReposCreateForkParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateInOrgParams(args map[string]string, r *http.Request) (ReposCreateInOrgParams, error) {
	var (
		params ReposCreateInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateOrUpdateFileContentsParams(args map[string]string, r *http.Request) (ReposCreateOrUpdateFileContentsParams, error) {
	var (
		params ReposCreateOrUpdateFileContentsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: path.
	{
		param := args["path"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: path: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreatePagesSiteParams(args map[string]string, r *http.Request) (ReposCreatePagesSiteParams, error) {
	var (
		params ReposCreatePagesSiteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateReleaseParams(args map[string]string, r *http.Request) (ReposCreateReleaseParams, error) {
	var (
		params ReposCreateReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateUsingTemplateParams(args map[string]string, r *http.Request) (ReposCreateUsingTemplateParams, error) {
	var (
		params ReposCreateUsingTemplateParams
	)
	// Decode path: template_owner.
	{
		param := args["template_owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TemplateOwner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: template_owner: not specified`)
		}
	}
	// Decode path: template_repo.
	{
		param := args["template_repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TemplateRepo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: template_repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposCreateWebhookParams(args map[string]string, r *http.Request) (ReposCreateWebhookParams, error) {
	var (
		params ReposCreateWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeclineInvitationParams(args map[string]string, r *http.Request) (ReposDeclineInvitationParams, error) {
	var (
		params ReposDeclineInvitationParams
	)
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteParams(args map[string]string, r *http.Request) (ReposDeleteParams, error) {
	var (
		params ReposDeleteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposDeleteAccessRestrictionsParams, error) {
	var (
		params ReposDeleteAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposDeleteAdminBranchProtectionParams, error) {
	var (
		params ReposDeleteAdminBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAnEnvironmentParams(args map[string]string, r *http.Request) (ReposDeleteAnEnvironmentParams, error) {
	var (
		params ReposDeleteAnEnvironmentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: environment_name.
	{
		param := args["environment_name"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: environment_name: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteAutolinkParams(args map[string]string, r *http.Request) (ReposDeleteAutolinkParams, error) {
	var (
		params ReposDeleteAutolinkParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: autolink_id.
	{
		param := args["autolink_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: autolink_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteBranchProtectionParams(args map[string]string, r *http.Request) (ReposDeleteBranchProtectionParams, error) {
	var (
		params ReposDeleteBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteCommitCommentParams(args map[string]string, r *http.Request) (ReposDeleteCommitCommentParams, error) {
	var (
		params ReposDeleteCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposDeleteCommitSignatureProtectionParams, error) {
	var (
		params ReposDeleteCommitSignatureProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteDeployKeyParams(args map[string]string, r *http.Request) (ReposDeleteDeployKeyParams, error) {
	var (
		params ReposDeleteDeployKeyParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteDeploymentParams(args map[string]string, r *http.Request) (ReposDeleteDeploymentParams, error) {
	var (
		params ReposDeleteDeploymentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteFileParams(args map[string]string, r *http.Request) (ReposDeleteFileParams, error) {
	var (
		params ReposDeleteFileParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: path.
	{
		param := args["path"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: path: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteInvitationParams(args map[string]string, r *http.Request) (ReposDeleteInvitationParams, error) {
	var (
		params ReposDeleteInvitationParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeletePagesSiteParams(args map[string]string, r *http.Request) (ReposDeletePagesSiteParams, error) {
	var (
		params ReposDeletePagesSiteParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeletePullRequestReviewProtectionParams(args map[string]string, r *http.Request) (ReposDeletePullRequestReviewProtectionParams, error) {
	var (
		params ReposDeletePullRequestReviewProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseParams(args map[string]string, r *http.Request) (ReposDeleteReleaseParams, error) {
	var (
		params ReposDeleteReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseAssetParams(args map[string]string, r *http.Request) (ReposDeleteReleaseAssetParams, error) {
	var (
		params ReposDeleteReleaseAssetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDeleteWebhookParams(args map[string]string, r *http.Request) (ReposDeleteWebhookParams, error) {
	var (
		params ReposDeleteWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableAutomatedSecurityFixesParams(args map[string]string, r *http.Request) (ReposDisableAutomatedSecurityFixesParams, error) {
	var (
		params ReposDisableAutomatedSecurityFixesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableLfsForRepoParams(args map[string]string, r *http.Request) (ReposDisableLfsForRepoParams, error) {
	var (
		params ReposDisableLfsForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDisableVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposDisableVulnerabilityAlertsParams, error) {
	var (
		params ReposDisableVulnerabilityAlertsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposDownloadTarballArchiveParams(args map[string]string, r *http.Request) (ReposDownloadTarballArchiveParams, error) {
	var (
		params ReposDownloadTarballArchiveParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeReposDownloadZipballArchiveParams(args map[string]string, r *http.Request) (ReposDownloadZipballArchiveParams, error) {
	var (
		params ReposDownloadZipballArchiveParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableAutomatedSecurityFixesParams(args map[string]string, r *http.Request) (ReposEnableAutomatedSecurityFixesParams, error) {
	var (
		params ReposEnableAutomatedSecurityFixesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableLfsForRepoParams(args map[string]string, r *http.Request) (ReposEnableLfsForRepoParams, error) {
	var (
		params ReposEnableLfsForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposEnableVulnerabilityAlertsParams(args map[string]string, r *http.Request) (ReposEnableVulnerabilityAlertsParams, error) {
	var (
		params ReposEnableVulnerabilityAlertsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetParams(args map[string]string, r *http.Request) (ReposGetParams, error) {
	var (
		params ReposGetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposGetAccessRestrictionsParams, error) {
	var (
		params ReposGetAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposGetAdminBranchProtectionParams, error) {
	var (
		params ReposGetAdminBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAllStatusCheckContextsParams(args map[string]string, r *http.Request) (ReposGetAllStatusCheckContextsParams, error) {
	var (
		params ReposGetAllStatusCheckContextsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAllTopicsParams(args map[string]string, r *http.Request) (ReposGetAllTopicsParams, error) {
	var (
		params    ReposGetAllTopicsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetAppsWithAccessToProtectedBranchParams, error) {
	var (
		params ReposGetAppsWithAccessToProtectedBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetAutolinkParams(args map[string]string, r *http.Request) (ReposGetAutolinkParams, error) {
	var (
		params ReposGetAutolinkParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: autolink_id.
	{
		param := args["autolink_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: autolink_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetBranchParams(args map[string]string, r *http.Request) (ReposGetBranchParams, error) {
	var (
		params ReposGetBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetBranchProtectionParams(args map[string]string, r *http.Request) (ReposGetBranchProtectionParams, error) {
	var (
		params ReposGetBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetClonesParams(args map[string]string, r *http.Request) (ReposGetClonesParams, error) {
	var (
		params    ReposGetClonesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per.
	{
		values, ok := queryArgs["per"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerVal ReposGetClonesPer
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPerVal = ReposGetClonesPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsPerVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: parse`)
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: invalid`)
			}
		}
	}
	return params, nil
}

func decodeReposGetCodeFrequencyStatsParams(args map[string]string, r *http.Request) (ReposGetCodeFrequencyStatsParams, error) {
	var (
		params ReposGetCodeFrequencyStatsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCollaboratorPermissionLevelParams(args map[string]string, r *http.Request) (ReposGetCollaboratorPermissionLevelParams, error) {
	var (
		params ReposGetCollaboratorPermissionLevelParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCombinedStatusForRefParams(args map[string]string, r *http.Request) (ReposGetCombinedStatusForRefParams, error) {
	var (
		params    ReposGetCombinedStatusForRefParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetCommitParams(args map[string]string, r *http.Request) (ReposGetCommitParams, error) {
	var (
		params    ReposGetCommitParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommitActivityStatsParams(args map[string]string, r *http.Request) (ReposGetCommitActivityStatsParams, error) {
	var (
		params ReposGetCommitActivityStatsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommitCommentParams(args map[string]string, r *http.Request) (ReposGetCommitCommentParams, error) {
	var (
		params ReposGetCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommitSignatureProtectionParams(args map[string]string, r *http.Request) (ReposGetCommitSignatureProtectionParams, error) {
	var (
		params ReposGetCommitSignatureProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetCommunityProfileMetricsParams(args map[string]string, r *http.Request) (ReposGetCommunityProfileMetricsParams, error) {
	var (
		params ReposGetCommunityProfileMetricsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetContributorsStatsParams(args map[string]string, r *http.Request) (ReposGetContributorsStatsParams, error) {
	var (
		params ReposGetContributorsStatsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetDeployKeyParams(args map[string]string, r *http.Request) (ReposGetDeployKeyParams, error) {
	var (
		params ReposGetDeployKeyParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetDeploymentParams(args map[string]string, r *http.Request) (ReposGetDeploymentParams, error) {
	var (
		params ReposGetDeploymentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetDeploymentStatusParams(args map[string]string, r *http.Request) (ReposGetDeploymentStatusParams, error) {
	var (
		params ReposGetDeploymentStatusParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	// Decode path: status_id.
	{
		param := args["status_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "status_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.StatusID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: status_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetLatestPagesBuildParams(args map[string]string, r *http.Request) (ReposGetLatestPagesBuildParams, error) {
	var (
		params ReposGetLatestPagesBuildParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetLatestReleaseParams(args map[string]string, r *http.Request) (ReposGetLatestReleaseParams, error) {
	var (
		params ReposGetLatestReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesParams(args map[string]string, r *http.Request) (ReposGetPagesParams, error) {
	var (
		params ReposGetPagesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesBuildParams(args map[string]string, r *http.Request) (ReposGetPagesBuildParams, error) {
	var (
		params ReposGetPagesBuildParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: build_id.
	{
		param := args["build_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "build_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.BuildID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: build_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPagesHealthCheckParams(args map[string]string, r *http.Request) (ReposGetPagesHealthCheckParams, error) {
	var (
		params ReposGetPagesHealthCheckParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetParticipationStatsParams(args map[string]string, r *http.Request) (ReposGetParticipationStatsParams, error) {
	var (
		params ReposGetParticipationStatsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPullRequestReviewProtectionParams(args map[string]string, r *http.Request) (ReposGetPullRequestReviewProtectionParams, error) {
	var (
		params ReposGetPullRequestReviewProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetPunchCardStatsParams(args map[string]string, r *http.Request) (ReposGetPunchCardStatsParams, error) {
	var (
		params ReposGetPunchCardStatsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReadmeParams(args map[string]string, r *http.Request) (ReposGetReadmeParams, error) {
	var (
		params    ReposGetReadmeParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetReadmeInDirectoryParams(args map[string]string, r *http.Request) (ReposGetReadmeInDirectoryParams, error) {
	var (
		params    ReposGetReadmeInDirectoryParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: dir.
	{
		param := args["dir"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dir",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Dir = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: dir: not specified`)
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposGetReleaseParams(args map[string]string, r *http.Request) (ReposGetReleaseParams, error) {
	var (
		params ReposGetReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReleaseAssetParams(args map[string]string, r *http.Request) (ReposGetReleaseAssetParams, error) {
	var (
		params ReposGetReleaseAssetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetReleaseByTagParams(args map[string]string, r *http.Request) (ReposGetReleaseByTagParams, error) {
	var (
		params ReposGetReleaseByTagParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: tag.
	{
		param := args["tag"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Tag = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: tag: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetStatusChecksProtectionParams(args map[string]string, r *http.Request) (ReposGetStatusChecksProtectionParams, error) {
	var (
		params ReposGetStatusChecksProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetTeamsWithAccessToProtectedBranchParams, error) {
	var (
		params ReposGetTeamsWithAccessToProtectedBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTopPathsParams(args map[string]string, r *http.Request) (ReposGetTopPathsParams, error) {
	var (
		params ReposGetTopPathsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetTopReferrersParams(args map[string]string, r *http.Request) (ReposGetTopReferrersParams, error) {
	var (
		params ReposGetTopReferrersParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(args map[string]string, r *http.Request) (ReposGetUsersWithAccessToProtectedBranchParams, error) {
	var (
		params ReposGetUsersWithAccessToProtectedBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetViewsParams(args map[string]string, r *http.Request) (ReposGetViewsParams, error) {
	var (
		params    ReposGetViewsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per.
	{
		values, ok := queryArgs["per"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerVal ReposGetViewsPer
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPerVal = ReposGetViewsPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsPerVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: parse`)
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per: invalid`)
			}
		}
	}
	return params, nil
}

func decodeReposGetWebhookParams(args map[string]string, r *http.Request) (ReposGetWebhookParams, error) {
	var (
		params ReposGetWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetWebhookConfigForRepoParams(args map[string]string, r *http.Request) (ReposGetWebhookConfigForRepoParams, error) {
	var (
		params ReposGetWebhookConfigForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposGetWebhookDeliveryParams(args map[string]string, r *http.Request) (ReposGetWebhookDeliveryParams, error) {
	var (
		params ReposGetWebhookDeliveryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposListAutolinksParams(args map[string]string, r *http.Request) (ReposListAutolinksParams, error) {
	var (
		params    ReposListAutolinksParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListBranchesParams(args map[string]string, r *http.Request) (ReposListBranchesParams, error) {
	var (
		params    ReposListBranchesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: protected.
	{
		values, ok := queryArgs["protected"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsProtectedVal bool
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(s)
					if err != nil {
						return err
					}

					paramsProtectedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Protected.SetTo(paramsProtectedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: protected: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListBranchesForHeadCommitParams(args map[string]string, r *http.Request) (ReposListBranchesForHeadCommitParams, error) {
	var (
		params ReposListBranchesForHeadCommitParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	return params, nil
}

func decodeReposListCollaboratorsParams(args map[string]string, r *http.Request) (ReposListCollaboratorsParams, error) {
	var (
		params    ReposListCollaboratorsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: affiliation.
	{
		values, ok := queryArgs["affiliation"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAffiliationVal ReposListCollaboratorsAffiliation
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAffiliationVal = ReposListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsAffiliationVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: parse`)
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommentsForCommitParams(args map[string]string, r *http.Request) (ReposListCommentsForCommitParams, error) {
	var (
		params    ReposListCommentsForCommitParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitCommentsForRepoParams(args map[string]string, r *http.Request) (ReposListCommitCommentsForRepoParams, error) {
	var (
		params    ReposListCommitCommentsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitStatusesForRefParams(args map[string]string, r *http.Request) (ReposListCommitStatusesForRefParams, error) {
	var (
		params    ReposListCommitStatusesForRefParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: ref.
	{
		param := args["ref"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: ref: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListCommitsParams(args map[string]string, r *http.Request) (ReposListCommitsParams, error) {
	var (
		params    ReposListCommitsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sha.
	{
		values, ok := queryArgs["sha"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsShaVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsShaVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sha: parse`)
			}
		}
	}
	// Decode query: path.
	{
		values, ok := queryArgs["path"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPathVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Path.SetTo(paramsPathVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: path: parse`)
			}
		}
	}
	// Decode query: author.
	{
		values, ok := queryArgs["author"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAuthorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAuthorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Author.SetTo(paramsAuthorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: author: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: until.
	{
		values, ok := queryArgs["until"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsUntilVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsUntilVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Until.SetTo(paramsUntilVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: until: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListContributorsParams(args map[string]string, r *http.Request) (ReposListContributorsParams, error) {
	var (
		params    ReposListContributorsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: anon.
	{
		values, ok := queryArgs["anon"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAnonVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAnonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Anon.SetTo(paramsAnonVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: anon: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListDeployKeysParams(args map[string]string, r *http.Request) (ReposListDeployKeysParams, error) {
	var (
		params    ReposListDeployKeysParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListDeploymentStatusesParams(args map[string]string, r *http.Request) (ReposListDeploymentStatusesParams, error) {
	var (
		params    ReposListDeploymentStatusesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: deployment_id.
	{
		param := args["deployment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: deployment_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListDeploymentsParams(args map[string]string, r *http.Request) (ReposListDeploymentsParams, error) {
	var (
		params    ReposListDeploymentsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sha.
	{
		values, ok := queryArgs["sha"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsShaVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsShaVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sha: parse`)
			}
		}
	}
	// Decode query: ref.
	{
		values, ok := queryArgs["ref"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRefVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsRefVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: ref: parse`)
			}
		}
	}
	// Decode query: task.
	{
		values, ok := queryArgs["task"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTaskVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTaskVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Task.SetTo(paramsTaskVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: task: parse`)
			}
		}
	}
	// Decode query: environment.
	{
		values, ok := queryArgs["environment"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsEnvironmentVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsEnvironmentVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Environment.SetTo(paramsEnvironmentVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: environment: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForAuthenticatedUserParams(args map[string]string, r *http.Request) (ReposListForAuthenticatedUserParams, error) {
	var (
		params    ReposListForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: visibility.
	{
		values, ok := queryArgs["visibility"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsVisibilityVal ReposListForAuthenticatedUserVisibility
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsVisibilityVal = ReposListForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsVisibilityVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: parse`)
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: visibility: invalid`)
			}
		}
	}
	// Decode query: affiliation.
	{
		values, ok := queryArgs["affiliation"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsAffiliationVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsAffiliationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsAffiliationVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: affiliation: parse`)
			}
		}
	}
	// Decode query: type.
	{
		values, ok := queryArgs["type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTypeVal ReposListForAuthenticatedUserType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTypeVal = ReposListForAuthenticatedUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: parse`)
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForAuthenticatedUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ReposListForAuthenticatedUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ReposListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: before.
	{
		values, ok := queryArgs["before"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsBeforeVal time.Time
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(s)
					if err != nil {
						return err
					}

					paramsBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsBeforeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: before: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForOrgParams(args map[string]string, r *http.Request) (ReposListForOrgParams, error) {
	var (
		params    ReposListForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: type.
	{
		values, ok := queryArgs["type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTypeVal ReposListForOrgType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTypeVal = ReposListForOrgType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: parse`)
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForOrgSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ReposListForOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ReposListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForUserParams(args map[string]string, r *http.Request) (ReposListForUserParams, error) {
	var (
		params    ReposListForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: type.
	{
		values, ok := queryArgs["type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsTypeVal ReposListForUserType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsTypeVal = ReposListForUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: parse`)
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: type: invalid`)
			}
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForUserSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal ReposListForUserDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = ReposListForUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListForksParams(args map[string]string, r *http.Request) (ReposListForksParams, error) {
	var (
		params    ReposListForksParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal ReposListForksSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = ReposListForksSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsParams(args map[string]string, r *http.Request) (ReposListInvitationsParams, error) {
	var (
		params    ReposListInvitationsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsForAuthenticatedUserParams(args map[string]string, r *http.Request) (ReposListInvitationsForAuthenticatedUserParams, error) {
	var (
		params    ReposListInvitationsForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListLanguagesParams(args map[string]string, r *http.Request) (ReposListLanguagesParams, error) {
	var (
		params ReposListLanguagesParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposListPagesBuildsParams(args map[string]string, r *http.Request) (ReposListPagesBuildsParams, error) {
	var (
		params    ReposListPagesBuildsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListPublicParams(args map[string]string, r *http.Request) (ReposListPublicParams, error) {
	var (
		params    ReposListPublicParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListPullRequestsAssociatedWithCommitParams(args map[string]string, r *http.Request) (ReposListPullRequestsAssociatedWithCommitParams, error) {
	var (
		params    ReposListPullRequestsAssociatedWithCommitParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: commit_sha.
	{
		param := args["commit_sha"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: commit_sha: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListReleaseAssetsParams(args map[string]string, r *http.Request) (ReposListReleaseAssetsParams, error) {
	var (
		params    ReposListReleaseAssetsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListReleasesParams(args map[string]string, r *http.Request) (ReposListReleasesParams, error) {
	var (
		params    ReposListReleasesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListTagsParams(args map[string]string, r *http.Request) (ReposListTagsParams, error) {
	var (
		params    ReposListTagsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListTeamsParams(args map[string]string, r *http.Request) (ReposListTeamsParams, error) {
	var (
		params    ReposListTeamsParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListWebhookDeliveriesParams(args map[string]string, r *http.Request) (ReposListWebhookDeliveriesParams, error) {
	var (
		params    ReposListWebhookDeliveriesParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: cursor.
	{
		values, ok := queryArgs["cursor"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsCursorVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsCursorVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: cursor: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposListWebhooksParams(args map[string]string, r *http.Request) (ReposListWebhooksParams, error) {
	var (
		params    ReposListWebhooksParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeReposMergeParams(args map[string]string, r *http.Request) (ReposMergeParams, error) {
	var (
		params ReposMergeParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposMergeUpstreamParams(args map[string]string, r *http.Request) (ReposMergeUpstreamParams, error) {
	var (
		params ReposMergeUpstreamParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposPingWebhookParams(args map[string]string, r *http.Request) (ReposPingWebhookParams, error) {
	var (
		params ReposPingWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposRedeliverWebhookDeliveryParams(args map[string]string, r *http.Request) (ReposRedeliverWebhookDeliveryParams, error) {
	var (
		params ReposRedeliverWebhookDeliveryParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	// Decode path: delivery_id.
	{
		param := args["delivery_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: delivery_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveAppAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposRemoveAppAccessRestrictionsParams, error) {
	var (
		params ReposRemoveAppAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveCollaboratorParams(args map[string]string, r *http.Request) (ReposRemoveCollaboratorParams, error) {
	var (
		params ReposRemoveCollaboratorParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveStatusCheckContextsParams(args map[string]string, r *http.Request) (ReposRemoveStatusCheckContextsParams, error) {
	var (
		params ReposRemoveStatusCheckContextsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveStatusCheckProtectionParams(args map[string]string, r *http.Request) (ReposRemoveStatusCheckProtectionParams, error) {
	var (
		params ReposRemoveStatusCheckProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveTeamAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposRemoveTeamAccessRestrictionsParams, error) {
	var (
		params ReposRemoveTeamAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposRemoveUserAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposRemoveUserAccessRestrictionsParams, error) {
	var (
		params ReposRemoveUserAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposRenameBranchParams(args map[string]string, r *http.Request) (ReposRenameBranchParams, error) {
	var (
		params ReposRenameBranchParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposReplaceAllTopicsParams(args map[string]string, r *http.Request) (ReposReplaceAllTopicsParams, error) {
	var (
		params ReposReplaceAllTopicsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposRequestPagesBuildParams(args map[string]string, r *http.Request) (ReposRequestPagesBuildParams, error) {
	var (
		params ReposRequestPagesBuildParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetAdminBranchProtectionParams(args map[string]string, r *http.Request) (ReposSetAdminBranchProtectionParams, error) {
	var (
		params ReposSetAdminBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetAppAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposSetAppAccessRestrictionsParams, error) {
	var (
		params ReposSetAppAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetStatusCheckContextsParams(args map[string]string, r *http.Request) (ReposSetStatusCheckContextsParams, error) {
	var (
		params ReposSetStatusCheckContextsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetTeamAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposSetTeamAccessRestrictionsParams, error) {
	var (
		params ReposSetTeamAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposSetUserAccessRestrictionsParams(args map[string]string, r *http.Request) (ReposSetUserAccessRestrictionsParams, error) {
	var (
		params ReposSetUserAccessRestrictionsParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposTestPushWebhookParams(args map[string]string, r *http.Request) (ReposTestPushWebhookParams, error) {
	var (
		params ReposTestPushWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposTransferParams(args map[string]string, r *http.Request) (ReposTransferParams, error) {
	var (
		params ReposTransferParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateParams(args map[string]string, r *http.Request) (ReposUpdateParams, error) {
	var (
		params ReposUpdateParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateBranchProtectionParams(args map[string]string, r *http.Request) (ReposUpdateBranchProtectionParams, error) {
	var (
		params ReposUpdateBranchProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateCommitCommentParams(args map[string]string, r *http.Request) (ReposUpdateCommitCommentParams, error) {
	var (
		params ReposUpdateCommitCommentParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: comment_id.
	{
		param := args["comment_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateInvitationParams(args map[string]string, r *http.Request) (ReposUpdateInvitationParams, error) {
	var (
		params ReposUpdateInvitationParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: invitation_id.
	{
		param := args["invitation_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: invitation_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdatePullRequestReviewProtectionParams(args map[string]string, r *http.Request) (ReposUpdatePullRequestReviewProtectionParams, error) {
	var (
		params ReposUpdatePullRequestReviewProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseParams(args map[string]string, r *http.Request) (ReposUpdateReleaseParams, error) {
	var (
		params ReposUpdateReleaseParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: release_id.
	{
		param := args["release_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: release_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseAssetParams(args map[string]string, r *http.Request) (ReposUpdateReleaseAssetParams, error) {
	var (
		params ReposUpdateReleaseAssetParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: asset_id.
	{
		param := args["asset_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: asset_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateStatusCheckProtectionParams(args map[string]string, r *http.Request) (ReposUpdateStatusCheckProtectionParams, error) {
	var (
		params ReposUpdateStatusCheckProtectionParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: branch.
	{
		param := args["branch"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: branch: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateWebhookParams(args map[string]string, r *http.Request) (ReposUpdateWebhookParams, error) {
	var (
		params ReposUpdateWebhookParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeReposUpdateWebhookConfigForRepoParams(args map[string]string, r *http.Request) (ReposUpdateWebhookConfigForRepoParams, error) {
	var (
		params ReposUpdateWebhookConfigForRepoParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: hook_id.
	{
		param := args["hook_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: hook_id: not specified`)
		}
	}
	return params, nil
}

func decodeScimDeleteUserFromOrgParams(args map[string]string, r *http.Request) (ScimDeleteUserFromOrgParams, error) {
	var (
		params ScimDeleteUserFromOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: scim_user_id.
	{
		param := args["scim_user_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: scim_user_id: not specified`)
		}
	}
	return params, nil
}

func decodeSearchCodeParams(args map[string]string, r *http.Request) (SearchCodeParams, error) {
	var (
		params    SearchCodeParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchCodeSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchCodeSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchCodeOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchCodeOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchCommitsParams(args map[string]string, r *http.Request) (SearchCommitsParams, error) {
	var (
		params    SearchCommitsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchCommitsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchCommitsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchCommitsOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchCommitsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchIssuesAndPullRequestsParams(args map[string]string, r *http.Request) (SearchIssuesAndPullRequestsParams, error) {
	var (
		params    SearchIssuesAndPullRequestsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchIssuesAndPullRequestsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchIssuesAndPullRequestsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchIssuesAndPullRequestsOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchIssuesAndPullRequestsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchLabelsParams(args map[string]string, r *http.Request) (SearchLabelsParams, error) {
	var (
		params    SearchLabelsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: repository_id.
	{
		values, ok := queryArgs["repository_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: repository_id: parse`)
			}
		} else {
			return params, errors.New(`query: repository_id: not specified`)
		}
	}
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchLabelsSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchLabelsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchLabelsOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchLabelsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchReposParams(args map[string]string, r *http.Request) (SearchReposParams, error) {
	var (
		params    SearchReposParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchReposSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchReposSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchReposOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchReposOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchTopicsParams(args map[string]string, r *http.Request) (SearchTopicsParams, error) {
	var (
		params    SearchTopicsParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSearchUsersParams(args map[string]string, r *http.Request) (SearchUsersParams, error) {
	var (
		params    SearchUsersParams
		queryArgs = r.URL.Query()
	)
	// Decode query: q.
	{
		values, ok := queryArgs["q"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: q: parse`)
			}
		} else {
			return params, errors.New(`query: q: not specified`)
		}
	}
	// Decode query: sort.
	{
		values, ok := queryArgs["sort"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSortVal SearchUsersSort
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSortVal = SearchUsersSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsSortVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: parse`)
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: sort: invalid`)
			}
		}
	}
	// Decode query: order.
	{
		values, ok := queryArgs["order"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsOrderVal SearchUsersOrder
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsOrderVal = SearchUsersOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsOrderVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: parse`)
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: order: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningGetAlertParams(args map[string]string, r *http.Request) (SecretScanningGetAlertParams, error) {
	var (
		params SecretScanningGetAlertParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForOrgParams(args map[string]string, r *http.Request) (SecretScanningListAlertsForOrgParams, error) {
	var (
		params    SecretScanningListAlertsForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal SecretScanningListAlertsForOrgState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = SecretScanningListAlertsForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: secret_type.
	{
		values, ok := queryArgs["secret_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSecretTypeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsSecretTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: secret_type: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForRepoParams(args map[string]string, r *http.Request) (SecretScanningListAlertsForRepoParams, error) {
	var (
		params    SecretScanningListAlertsForRepoParams
		queryArgs = r.URL.Query()
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode query: state.
	{
		values, ok := queryArgs["state"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsStateVal SecretScanningListAlertsForRepoState
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsStateVal = SecretScanningListAlertsForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsStateVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: parse`)
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: state: invalid`)
			}
		}
	}
	// Decode query: secret_type.
	{
		values, ok := queryArgs["secret_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSecretTypeVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsSecretTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: secret_type: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeSecretScanningUpdateAlertParams(args map[string]string, r *http.Request) (SecretScanningUpdateAlertParams, error) {
	var (
		params SecretScanningUpdateAlertParams
	)
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	// Decode path: alert_number.
	{
		param := args["alert_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsAlertNumberVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: alert_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddMemberLegacyParams(args map[string]string, r *http.Request) (TeamsAddMemberLegacyParams, error) {
	var (
		params TeamsAddMemberLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateMembershipForUserInOrgParams, error) {
	var (
		params TeamsAddOrUpdateMembershipForUserInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateMembershipForUserLegacyParams, error) {
	var (
		params TeamsAddOrUpdateMembershipForUserLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateProjectPermissionsInOrgParams, error) {
	var (
		params TeamsAddOrUpdateProjectPermissionsInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateProjectPermissionsLegacyParams, error) {
	var (
		params TeamsAddOrUpdateProjectPermissionsLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateRepoPermissionsInOrgParams, error) {
	var (
		params TeamsAddOrUpdateRepoPermissionsInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args map[string]string, r *http.Request) (TeamsAddOrUpdateRepoPermissionsLegacyParams, error) {
	var (
		params TeamsAddOrUpdateRepoPermissionsLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForProjectInOrgParams, error) {
	var (
		params TeamsCheckPermissionsForProjectInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForProjectLegacyParams, error) {
	var (
		params TeamsCheckPermissionsForProjectLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForRepoInOrgParams, error) {
	var (
		params TeamsCheckPermissionsForRepoInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(args map[string]string, r *http.Request) (TeamsCheckPermissionsForRepoLegacyParams, error) {
	var (
		params TeamsCheckPermissionsForRepoLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateParams(args map[string]string, r *http.Request) (TeamsCreateParams, error) {
	var (
		params TeamsCreateParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionCommentInOrgParams, error) {
	var (
		params TeamsCreateDiscussionCommentInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionCommentLegacyParams, error) {
	var (
		params TeamsCreateDiscussionCommentLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionInOrgParams, error) {
	var (
		params TeamsCreateDiscussionInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsCreateDiscussionLegacyParams, error) {
	var (
		params TeamsCreateDiscussionLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args map[string]string, r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, error) {
	var (
		params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args map[string]string, r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams, error) {
	var (
		params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionCommentInOrgParams, error) {
	var (
		params TeamsDeleteDiscussionCommentInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionCommentLegacyParams, error) {
	var (
		params TeamsDeleteDiscussionCommentLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionInOrgParams, error) {
	var (
		params TeamsDeleteDiscussionInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsDeleteDiscussionLegacyParams, error) {
	var (
		params TeamsDeleteDiscussionLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteInOrgParams(args map[string]string, r *http.Request) (TeamsDeleteInOrgParams, error) {
	var (
		params TeamsDeleteInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsDeleteLegacyParams(args map[string]string, r *http.Request) (TeamsDeleteLegacyParams, error) {
	var (
		params TeamsDeleteLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetByNameParams(args map[string]string, r *http.Request) (TeamsGetByNameParams, error) {
	var (
		params TeamsGetByNameParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsGetDiscussionCommentInOrgParams, error) {
	var (
		params TeamsGetDiscussionCommentInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsGetDiscussionCommentLegacyParams, error) {
	var (
		params TeamsGetDiscussionCommentLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsGetDiscussionInOrgParams, error) {
	var (
		params TeamsGetDiscussionInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsGetDiscussionLegacyParams, error) {
	var (
		params TeamsGetDiscussionLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetLegacyParams(args map[string]string, r *http.Request) (TeamsGetLegacyParams, error) {
	var (
		params TeamsGetLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMemberLegacyParams(args map[string]string, r *http.Request) (TeamsGetMemberLegacyParams, error) {
	var (
		params TeamsGetMemberLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsGetMembershipForUserInOrgParams, error) {
	var (
		params TeamsGetMembershipForUserInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsGetMembershipForUserLegacyParams, error) {
	var (
		params TeamsGetMembershipForUserLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListParams(args map[string]string, r *http.Request) (TeamsListParams, error) {
	var (
		params    TeamsListParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListChildInOrgParams(args map[string]string, r *http.Request) (TeamsListChildInOrgParams, error) {
	var (
		params    TeamsListChildInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListChildLegacyParams(args map[string]string, r *http.Request) (TeamsListChildLegacyParams, error) {
	var (
		params    TeamsListChildLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsInOrgParams(args map[string]string, r *http.Request) (TeamsListDiscussionCommentsInOrgParams, error) {
	var (
		params    TeamsListDiscussionCommentsInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionCommentsInOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionCommentsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsLegacyParams(args map[string]string, r *http.Request) (TeamsListDiscussionCommentsLegacyParams, error) {
	var (
		params    TeamsListDiscussionCommentsLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionCommentsLegacyDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionCommentsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsInOrgParams(args map[string]string, r *http.Request) (TeamsListDiscussionsInOrgParams, error) {
	var (
		params    TeamsListDiscussionsInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionsInOrgDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	// Decode query: pinned.
	{
		values, ok := queryArgs["pinned"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPinnedVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPinnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pinned.SetTo(paramsPinnedVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: pinned: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsLegacyParams(args map[string]string, r *http.Request) (TeamsListDiscussionsLegacyParams, error) {
	var (
		params    TeamsListDiscussionsLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: direction.
	{
		values, ok := queryArgs["direction"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsDirectionVal TeamsListDiscussionsLegacyDirection
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsDirectionVal = TeamsListDiscussionsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDirectionVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: parse`)
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: direction: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListForAuthenticatedUserParams(args map[string]string, r *http.Request) (TeamsListForAuthenticatedUserParams, error) {
	var (
		params    TeamsListForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForLegacyParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsForLegacyParams, error) {
	var (
		params TeamsListIdpGroupsForLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForOrgParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsForOrgParams, error) {
	var (
		params    TeamsListIdpGroupsForOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsInOrgParams(args map[string]string, r *http.Request) (TeamsListIdpGroupsInOrgParams, error) {
	var (
		params TeamsListIdpGroupsInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsListMembersInOrgParams(args map[string]string, r *http.Request) (TeamsListMembersInOrgParams, error) {
	var (
		params    TeamsListMembersInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: role.
	{
		values, ok := queryArgs["role"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRoleVal TeamsListMembersInOrgRole
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRoleVal = TeamsListMembersInOrgRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsRoleVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: parse`)
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListMembersLegacyParams(args map[string]string, r *http.Request) (TeamsListMembersLegacyParams, error) {
	var (
		params    TeamsListMembersLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: role.
	{
		values, ok := queryArgs["role"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsRoleVal TeamsListMembersLegacyRole
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsRoleVal = TeamsListMembersLegacyRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsRoleVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: parse`)
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: role: invalid`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsInOrgParams(args map[string]string, r *http.Request) (TeamsListPendingInvitationsInOrgParams, error) {
	var (
		params    TeamsListPendingInvitationsInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsLegacyParams(args map[string]string, r *http.Request) (TeamsListPendingInvitationsLegacyParams, error) {
	var (
		params    TeamsListPendingInvitationsLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsInOrgParams(args map[string]string, r *http.Request) (TeamsListProjectsInOrgParams, error) {
	var (
		params    TeamsListProjectsInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsLegacyParams(args map[string]string, r *http.Request) (TeamsListProjectsLegacyParams, error) {
	var (
		params    TeamsListProjectsLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposInOrgParams(args map[string]string, r *http.Request) (TeamsListReposInOrgParams, error) {
	var (
		params    TeamsListReposInOrgParams
		queryArgs = r.URL.Query()
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposLegacyParams(args map[string]string, r *http.Request) (TeamsListReposLegacyParams, error) {
	var (
		params    TeamsListReposLegacyParams
		queryArgs = r.URL.Query()
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeTeamsRemoveMemberLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveMemberLegacyParams, error) {
	var (
		params TeamsRemoveMemberLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveMembershipForUserInOrgParams, error) {
	var (
		params TeamsRemoveMembershipForUserInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveMembershipForUserLegacyParams, error) {
	var (
		params TeamsRemoveMembershipForUserLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveProjectInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveProjectInOrgParams, error) {
	var (
		params TeamsRemoveProjectInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveProjectLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveProjectLegacyParams, error) {
	var (
		params TeamsRemoveProjectLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: project_id.
	{
		param := args["project_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: project_id: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoInOrgParams(args map[string]string, r *http.Request) (TeamsRemoveRepoInOrgParams, error) {
	var (
		params TeamsRemoveRepoInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoLegacyParams(args map[string]string, r *http.Request) (TeamsRemoveRepoLegacyParams, error) {
	var (
		params TeamsRemoveRepoLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: owner.
	{
		param := args["owner"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: owner: not specified`)
		}
	}
	// Decode path: repo.
	{
		param := args["repo"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: repo: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionCommentInOrgParams, error) {
	var (
		params TeamsUpdateDiscussionCommentInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionCommentLegacyParams, error) {
	var (
		params TeamsUpdateDiscussionCommentLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	// Decode path: comment_number.
	{
		param := args["comment_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: comment_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionInOrgParams, error) {
	var (
		params TeamsUpdateDiscussionInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionLegacyParams(args map[string]string, r *http.Request) (TeamsUpdateDiscussionLegacyParams, error) {
	var (
		params TeamsUpdateDiscussionLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	// Decode path: discussion_number.
	{
		param := args["discussion_number"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: discussion_number: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateInOrgParams(args map[string]string, r *http.Request) (TeamsUpdateInOrgParams, error) {
	var (
		params TeamsUpdateInOrgParams
	)
	// Decode path: org.
	{
		param := args["org"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: org: not specified`)
		}
	}
	// Decode path: team_slug.
	{
		param := args["team_slug"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_slug: not specified`)
		}
	}
	return params, nil
}

func decodeTeamsUpdateLegacyParams(args map[string]string, r *http.Request) (TeamsUpdateLegacyParams, error) {
	var (
		params TeamsUpdateLegacyParams
	)
	// Decode path: team_id.
	{
		param := args["team_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: team_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersBlockParams(args map[string]string, r *http.Request) (UsersBlockParams, error) {
	var (
		params UsersBlockParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckBlockedParams(args map[string]string, r *http.Request) (UsersCheckBlockedParams, error) {
	var (
		params UsersCheckBlockedParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckFollowingForUserParams(args map[string]string, r *http.Request) (UsersCheckFollowingForUserParams, error) {
	var (
		params UsersCheckFollowingForUserParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode path: target_user.
	{
		param := args["target_user"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "target_user",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.TargetUser = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: target_user: not specified`)
		}
	}
	return params, nil
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args map[string]string, r *http.Request) (UsersCheckPersonIsFollowedByAuthenticatedParams, error) {
	var (
		params UsersCheckPersonIsFollowedByAuthenticatedParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersDeleteGpgKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersDeleteGpgKeyForAuthenticatedParams, error) {
	var (
		params UsersDeleteGpgKeyForAuthenticatedParams
	)
	// Decode path: gpg_key_id.
	{
		param := args["gpg_key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gpg_key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersDeletePublicSSHKeyForAuthenticatedParams, error) {
	var (
		params UsersDeletePublicSSHKeyForAuthenticatedParams
	)
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersFollowParams(args map[string]string, r *http.Request) (UsersFollowParams, error) {
	var (
		params UsersFollowParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetByUsernameParams(args map[string]string, r *http.Request) (UsersGetByUsernameParams, error) {
	var (
		params UsersGetByUsernameParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetContextForUserParams(args map[string]string, r *http.Request) (UsersGetContextForUserParams, error) {
	var (
		params    UsersGetContextForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: subject_type.
	{
		values, ok := queryArgs["subject_type"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSubjectTypeVal UsersGetContextForUserSubjectType
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSubjectTypeVal = UsersGetContextForUserSubjectType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectType.SetTo(paramsSubjectTypeVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: subject_type: parse`)
			}
			if err := func() error {
				if params.SubjectType.Set {
					if err := func() error {
						if err := params.SubjectType.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: subject_type: invalid`)
			}
		}
	}
	// Decode query: subject_id.
	{
		values, ok := queryArgs["subject_id"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSubjectIDVal string
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(s)
					if err != nil {
						return err
					}

					paramsSubjectIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectID.SetTo(paramsSubjectIDVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: subject_id: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersGetGpgKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersGetGpgKeyForAuthenticatedParams, error) {
	var (
		params UsersGetGpgKeyForAuthenticatedParams
	)
	// Decode path: gpg_key_id.
	{
		param := args["gpg_key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: gpg_key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(args map[string]string, r *http.Request) (UsersGetPublicSSHKeyForAuthenticatedParams, error) {
	var (
		params UsersGetPublicSSHKeyForAuthenticatedParams
	)
	// Decode path: key_id.
	{
		param := args["key_id"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(s)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: key_id: not specified`)
		}
	}
	return params, nil
}

func decodeUsersListParams(args map[string]string, r *http.Request) (UsersListParams, error) {
	var (
		params    UsersListParams
		queryArgs = r.URL.Query()
	)
	// Decode query: since.
	{
		values, ok := queryArgs["since"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsSinceVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsSinceVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: since: parse`)
			}
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListEmailsForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListEmailsForAuthenticatedParams, error) {
	var (
		params    UsersListEmailsForAuthenticatedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowedByAuthenticatedParams(args map[string]string, r *http.Request) (UsersListFollowedByAuthenticatedParams, error) {
	var (
		params    UsersListFollowedByAuthenticatedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForAuthenticatedUserParams(args map[string]string, r *http.Request) (UsersListFollowersForAuthenticatedUserParams, error) {
	var (
		params    UsersListFollowersForAuthenticatedUserParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForUserParams(args map[string]string, r *http.Request) (UsersListFollowersForUserParams, error) {
	var (
		params    UsersListFollowersForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowingForUserParams(args map[string]string, r *http.Request) (UsersListFollowingForUserParams, error) {
	var (
		params    UsersListFollowingForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListGpgKeysForAuthenticatedParams, error) {
	var (
		params    UsersListGpgKeysForAuthenticatedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForUserParams(args map[string]string, r *http.Request) (UsersListGpgKeysForUserParams, error) {
	var (
		params    UsersListGpgKeysForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicEmailsForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListPublicEmailsForAuthenticatedParams, error) {
	var (
		params    UsersListPublicEmailsForAuthenticatedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicKeysForUserParams(args map[string]string, r *http.Request) (UsersListPublicKeysForUserParams, error) {
	var (
		params    UsersListPublicKeysForUserParams
		queryArgs = r.URL.Query()
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(args map[string]string, r *http.Request) (UsersListPublicSSHKeysForAuthenticatedParams, error) {
	var (
		params    UsersListPublicSSHKeysForAuthenticatedParams
		queryArgs = r.URL.Query()
	)
	// Decode query: per_page.
	{
		values, ok := queryArgs["per_page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPerPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsPerPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: per_page: parse`)
			}
		}
	}
	// Decode query: page.
	{
		values, ok := queryArgs["page"]
		if ok {
			d := uri.NewQueryDecoder(uri.QueryDecoderConfig{
				Values:  values,
				Style:   uri.QueryStyleForm,
				Explode: true,
			})

			if err := func() error {
				var paramsPageVal int
				if err := func() error {
					s, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(s)
					if err != nil {
						return err
					}

					paramsPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsPageVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, `query: page: parse`)
			}
		}
	}
	return params, nil
}

func decodeUsersUnblockParams(args map[string]string, r *http.Request) (UsersUnblockParams, error) {
	var (
		params UsersUnblockParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}

func decodeUsersUnfollowParams(args map[string]string, r *http.Request) (UsersUnfollowParams, error) {
	var (
		params UsersUnfollowParams
	)
	// Decode path: username.
	{
		param := args["username"]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				s, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(s)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New(`path: username: not specified`)
		}
	}
	return params, nil
}
