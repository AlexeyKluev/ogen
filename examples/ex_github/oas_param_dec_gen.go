// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"net/http"
	"time"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args [3]string, r *http.Request) (params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsAddSelectedRepoToOrgSecretParams(args [3]string, r *http.Request) (params ActionsAddSelectedRepoToOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args [3]string, r *http.Request) (params ActionsAddSelfHostedRunnerToGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsApproveWorkflowRunParams(args [3]string, r *http.Request) (params ActionsApproveWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsCancelWorkflowRunParams(args [3]string, r *http.Request) (params ActionsCancelWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsCreateOrUpdateEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateOrgSecretParams(args [2]string, r *http.Request) (params ActionsCreateOrUpdateOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateOrUpdateRepoSecretParams(args [3]string, r *http.Request) (params ActionsCreateOrUpdateRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForOrgParams(args [1]string, r *http.Request) (params ActionsCreateRegistrationTokenForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateRegistrationTokenForRepoParams(args [2]string, r *http.Request) (params ActionsCreateRegistrationTokenForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForOrgParams(args [1]string, r *http.Request) (params ActionsCreateRemoveTokenForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateRemoveTokenForRepoParams(args [2]string, r *http.Request) (params ActionsCreateRemoveTokenForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args [1]string, r *http.Request) (params ActionsCreateSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteArtifactParams(args [3]string, r *http.Request) (params ActionsDeleteArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsDeleteEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteOrgSecretParams(args [2]string, r *http.Request) (params ActionsDeleteOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteRepoSecretParams(args [3]string, r *http.Request) (params ActionsDeleteRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(args [2]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(args [3]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerFromRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args [2]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerGroupFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunParams(args [3]string, r *http.Request) (params ActionsDeleteWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDeleteWorkflowRunLogsParams(args [3]string, r *http.Request) (params ActionsDeleteWorkflowRunLogsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args [2]string, r *http.Request) (params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDownloadArtifactParams(args [4]string, r *http.Request) (params ActionsDownloadArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	// Decode path: archive_format.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "archive_format",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ArchiveFormat = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: archive_format: not specified")
		}
	}
	return params, nil
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsDownloadJobLogsForWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: job_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: job_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsDownloadWorkflowRunLogsParams(args [3]string, r *http.Request) (params ActionsDownloadWorkflowRunLogsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args [2]string, r *http.Request) (params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsGetAllowedActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetAllowedActionsRepositoryParams(args [2]string, r *http.Request) (params ActionsGetAllowedActionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetArtifactParams(args [3]string, r *http.Request) (params ActionsGetArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentPublicKeyParams(args [2]string, r *http.Request) (params ActionsGetEnvironmentPublicKeyParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsGetEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(args [1]string, r *http.Request) (params ActionsGetGithubActionsPermissionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(args [2]string, r *http.Request) (params ActionsGetGithubActionsPermissionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetJobForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsGetJobForWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: job_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: job_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetOrgPublicKeyParams(args [1]string, r *http.Request) (params ActionsGetOrgPublicKeyParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetOrgSecretParams(args [2]string, r *http.Request) (params ActionsGetOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetRepoPublicKeyParams(args [2]string, r *http.Request) (params ActionsGetRepoPublicKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetRepoSecretParams(args [3]string, r *http.Request) (params ActionsGetRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetReviewsForRunParams(args [3]string, r *http.Request) (params ActionsGetReviewsForRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForOrgParams(args [2]string, r *http.Request) (params ActionsGetSelfHostedRunnerForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerForRepoParams(args [3]string, r *http.Request) (params ActionsGetSelfHostedRunnerForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(args [2]string, r *http.Request) (params ActionsGetSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunParams(args [3]string, r *http.Request) (params ActionsGetWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsGetWorkflowRunUsageParams(args [3]string, r *http.Request) (params ActionsGetWorkflowRunUsageParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsListArtifactsForRepoParams(args [2]string, r *http.Request) (params ActionsListArtifactsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListEnvironmentSecretsParams(args [2]string, r *http.Request) (params ActionsListEnvironmentSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListJobsForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsListJobsForWorkflowRunParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := ActionsListJobsForWorkflowRunFilter("latest")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ActionsListJobsForWorkflowRunFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ActionsListJobsForWorkflowRunFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListOrgSecretsParams(args [1]string, r *http.Request) (params ActionsListOrgSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args [2]string, r *http.Request) (params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoSecretsParams(args [2]string, r *http.Request) (params ActionsListRepoSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListRepoWorkflowsParams(args [2]string, r *http.Request) (params ActionsListRepoWorkflowsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForOrgParams(args [1]string, r *http.Request) (params ActionsListRunnerApplicationsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsListRunnerApplicationsForRepoParams(args [2]string, r *http.Request) (params ActionsListRunnerApplicationsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsListSelectedReposForOrgSecretParams(args [2]string, r *http.Request) (params ActionsListSelectedReposForOrgSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(args [1]string, r *http.Request) (params ActionsListSelfHostedRunnerGroupsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForOrgParams(args [1]string, r *http.Request) (params ActionsListSelfHostedRunnersForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersForRepoParams(args [2]string, r *http.Request) (params ActionsListSelfHostedRunnersForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(args [2]string, r *http.Request) (params ActionsListSelfHostedRunnersInGroupForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunArtifactsParams(args [3]string, r *http.Request) (params ActionsListWorkflowRunArtifactsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsListWorkflowRunsForRepoParams(args [2]string, r *http.Request) (params ActionsListWorkflowRunsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: actor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "actor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotActorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotActorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Actor.SetTo(paramsDotActorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: actor: parse")
			}
		}
	}
	// Decode query: branch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "branch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBranchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBranchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Branch.SetTo(paramsDotBranchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: branch: parse")
			}
		}
	}
	// Decode query: event.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "event",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEventVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEventVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Event.SetTo(paramsDotEventVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: event: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ActionsListWorkflowRunsForRepoStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ActionsListWorkflowRunsForRepoStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: created.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "created",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCreatedVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotCreatedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Created.SetTo(paramsDotCreatedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: created: parse")
			}
		}
	}
	return params, nil
}

func decodeActionsReRunWorkflowParams(args [3]string, r *http.Request) (params ActionsReRunWorkflowParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args [3]string, r *http.Request) (params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(args [3]string, r *http.Request) (params ActionsRemoveSelectedRepoFromOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args [3]string, r *http.Request) (params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsRetryWorkflowParams(args [3]string, r *http.Request) (params ActionsRetryWorkflowParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsReviewPendingDeploymentsForRunParams(args [3]string, r *http.Request) (params ActionsReviewPendingDeploymentsForRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetAllowedActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetAllowedActionsRepositoryParams(args [2]string, r *http.Request) (params ActionsSetAllowedActionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetGithubActionsPermissionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(args [2]string, r *http.Request) (params ActionsSetGithubActionsPermissionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args [2]string, r *http.Request) (params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetSelectedReposForOrgSecretParams(args [2]string, r *http.Request) (params ActionsSetSelectedReposForOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args [2]string, r *http.Request) (params ActionsSetSelfHostedRunnersInGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args [2]string, r *http.Request) (params ActionsUpdateSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityCheckRepoIsStarredByAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivityDeleteRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivityDeleteRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivityDeleteThreadSubscriptionParams(args [1]string, r *http.Request) (params ActivityDeleteThreadSubscriptionParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

func decodeActivityGetRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivityGetRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivityGetThreadParams(args [1]string, r *http.Request) (params ActivityGetThreadParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args [1]string, r *http.Request) (params ActivityGetThreadSubscriptionForAuthenticatedUserParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

func decodeActivityListEventsForAuthenticatedUserParams(args [1]string, r *http.Request) (params ActivityListEventsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListNotificationsForAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListNotificationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: all.
	{
		val := bool(false)

		params.All.SetTo(val)
	}
	// Decode query: all.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsDotAllVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: all: parse")
			}
		}
	}
	// Set default value for query: participating.
	{
		val := bool(false)

		params.Participating.SetTo(val)
	}
	// Decode query: participating.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParticipatingVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsDotParticipatingVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: participating: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityListOrgEventsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsParams(args [0]string, r *http.Request) (params ActivityListPublicEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForRepoNetworkParams(args [2]string, r *http.Request) (params ActivityListPublicEventsForRepoNetworkParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicEventsForUserParams(args [1]string, r *http.Request) (params ActivityListPublicEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListPublicOrgEventsParams(args [1]string, r *http.Request) (params ActivityListPublicOrgEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedEventsForUserParams(args [1]string, r *http.Request) (params ActivityListReceivedEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListReceivedPublicEventsForUserParams(args [1]string, r *http.Request) (params ActivityListReceivedPublicEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoEventsParams(args [2]string, r *http.Request) (params ActivityListRepoEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityListRepoNotificationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: all.
	{
		val := bool(false)

		params.All.SetTo(val)
	}
	// Decode query: all.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsDotAllVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: all: parse")
			}
		}
	}
	// Set default value for query: participating.
	{
		val := bool(false)

		params.Participating.SetTo(val)
	}
	// Decode query: participating.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParticipatingVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsDotParticipatingVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: participating: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListReposStarredByAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListReposStarredByAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sort.
	{
		val := ActivityListReposStarredByAuthenticatedUserSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ActivityListReposStarredByAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ActivityListReposStarredByAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := ActivityListReposStarredByAuthenticatedUserDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ActivityListReposStarredByAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ActivityListReposStarredByAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListReposWatchedByUserParams(args [1]string, r *http.Request) (params ActivityListReposWatchedByUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListWatchedReposForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityListWatchersForRepoParams(args [2]string, r *http.Request) (params ActivityListWatchersForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeActivityMarkRepoNotificationsAsReadParams(args [2]string, r *http.Request) (params ActivityMarkRepoNotificationsAsReadParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivityMarkThreadAsReadParams(args [1]string, r *http.Request) (params ActivityMarkThreadAsReadParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

func decodeActivitySetRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivitySetRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivitySetThreadSubscriptionParams(args [1]string, r *http.Request) (params ActivitySetThreadSubscriptionParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

func decodeActivityStarRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityStarRepoForAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityUnstarRepoForAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeAppsAddRepoToInstallationParams(args [2]string, r *http.Request) (params AppsAddRepoToInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsCheckTokenParams(args [1]string, r *http.Request) (params AppsCheckTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsCreateContentAttachmentParams(args [3]string, r *http.Request) (params AppsCreateContentAttachmentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: content_reference_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "content_reference_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ContentReferenceID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: content_reference_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsCreateInstallationAccessTokenParams(args [1]string, r *http.Request) (params AppsCreateInstallationAccessTokenParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsDeleteAuthorizationParams(args [1]string, r *http.Request) (params AppsDeleteAuthorizationParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsDeleteInstallationParams(args [1]string, r *http.Request) (params AppsDeleteInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsDeleteTokenParams(args [1]string, r *http.Request) (params AppsDeleteTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsGetBySlugParams(args [1]string, r *http.Request) (params AppsGetBySlugParams, _ error) {
	// Decode path: app_slug.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "app_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AppSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: app_slug: not specified")
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountParams(args [1]string, r *http.Request) (params AppsGetSubscriptionPlanForAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(args [1]string, r *http.Request) (params AppsGetSubscriptionPlanForAccountStubbedParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsGetWebhookDeliveryParams(args [1]string, r *http.Request) (params AppsGetWebhookDeliveryParams, _ error) {
	// Decode path: delivery_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsListAccountsForPlanParams(args [1]string, r *http.Request) (params AppsListAccountsForPlanParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: plan_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: plan_id: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := AppsListAccountsForPlanSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal AppsListAccountsForPlanSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = AppsListAccountsForPlanSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal AppsListAccountsForPlanDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = AppsListAccountsForPlanDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListAccountsForPlanStubbedParams(args [1]string, r *http.Request) (params AppsListAccountsForPlanStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: plan_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: plan_id: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := AppsListAccountsForPlanStubbedSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal AppsListAccountsForPlanStubbedSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = AppsListAccountsForPlanStubbedSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal AppsListAccountsForPlanStubbedDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = AppsListAccountsForPlanStubbedDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(args [1]string, r *http.Request) (params AppsListInstallationReposForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansParams(args [0]string, r *http.Request) (params AppsListPlansParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListPlansStubbedParams(args [0]string, r *http.Request) (params AppsListPlansStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListReposAccessibleToInstallationParams(args [0]string, r *http.Request) (params AppsListReposAccessibleToInstallationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(args [0]string, r *http.Request) (params AppsListSubscriptionsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args [0]string, r *http.Request) (params AppsListSubscriptionsForAuthenticatedUserStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsListWebhookDeliveriesParams(args [0]string, r *http.Request) (params AppsListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

func decodeAppsRedeliverWebhookDeliveryParams(args [1]string, r *http.Request) (params AppsRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: delivery_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsRemoveRepoFromInstallationParams(args [2]string, r *http.Request) (params AppsRemoveRepoFromInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsResetTokenParams(args [1]string, r *http.Request) (params AppsResetTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsScopeTokenParams(args [1]string, r *http.Request) (params AppsScopeTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsSuspendInstallationParams(args [1]string, r *http.Request) (params AppsSuspendInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

func decodeAppsUnsuspendInstallationParams(args [1]string, r *http.Request) (params AppsUnsuspendInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingGheParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingOrgParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubActionsBillingUserParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingGheParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingOrgParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetGithubPackagesBillingUserParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingGheParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingOrgParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeBillingGetSharedStorageBillingUserParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeChecksCreateSuiteParams(args [2]string, r *http.Request) (params ChecksCreateSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeChecksGetParams(args [3]string, r *http.Request) (params ChecksGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: check_run_id: not specified")
		}
	}
	return params, nil
}

func decodeChecksGetSuiteParams(args [3]string, r *http.Request) (params ChecksGetSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	return params, nil
}

func decodeChecksListAnnotationsParams(args [3]string, r *http.Request) (params ChecksListAnnotationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: check_run_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeChecksListForRefParams(args [3]string, r *http.Request) (params ChecksListForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ChecksListForRefStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ChecksListForRefStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: filter.
	{
		val := ChecksListForRefFilter("latest")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ChecksListForRefFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ChecksListForRefFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: app_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAppIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsDotAppIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: app_id: parse")
			}
		}
	}
	return params, nil
}

func decodeChecksListForSuiteParams(args [3]string, r *http.Request) (params ChecksListForSuiteParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ChecksListForSuiteStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ChecksListForSuiteStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: filter.
	{
		val := ChecksListForSuiteFilter("latest")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ChecksListForSuiteFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ChecksListForSuiteFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeChecksListSuitesForRefParams(args [3]string, r *http.Request) (params ChecksListSuitesForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Decode query: app_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAppIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsDotAppIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: app_id: parse")
			}
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeChecksRerequestSuiteParams(args [3]string, r *http.Request) (params ChecksRerequestSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	return params, nil
}

func decodeChecksSetSuitesPreferencesParams(args [2]string, r *http.Request) (params ChecksSetSuitesPreferencesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeCodeScanningDeleteAnalysisParams(args [3]string, r *http.Request) (params CodeScanningDeleteAnalysisParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: analysis_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: analysis_id: not specified")
		}
	}
	// Decode query: confirm_delete.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "confirm_delete",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotConfirmDeleteVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotConfirmDeleteVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ConfirmDelete.SetTo(paramsDotConfirmDeleteVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: confirm_delete: parse")
			}
		}
	}
	return params, nil
}

func decodeCodeScanningGetAlertParams(args [3]string, r *http.Request) (params CodeScanningGetAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

func decodeCodeScanningGetAnalysisParams(args [3]string, r *http.Request) (params CodeScanningGetAnalysisParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: analysis_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: analysis_id: not specified")
		}
	}
	return params, nil
}

func decodeCodeScanningGetSarifParams(args [3]string, r *http.Request) (params CodeScanningGetSarifParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: sarif_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sarif_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SarifID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: sarif_id: not specified")
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertInstancesParams(args [3]string, r *http.Request) (params CodeScanningListAlertInstancesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListAlertsForRepoParams(args [2]string, r *http.Request) (params CodeScanningListAlertsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: tool_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsDotToolNameValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolNameVal = CodeScanningAnalysisToolName(paramsDotToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsDotToolNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_name: parse")
			}
		}
	}
	// Decode query: tool_guid.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsDotToolGUIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolGUIDVal = CodeScanningAnalysisToolGUID(paramsDotToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsDotToolGUIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_guid: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal CodeScanningAlertState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = CodeScanningAlertState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

func decodeCodeScanningListRecentAnalysesParams(args [2]string, r *http.Request) (params CodeScanningListRecentAnalysesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: tool_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsDotToolNameValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolNameVal = CodeScanningAnalysisToolName(paramsDotToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsDotToolNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_name: parse")
			}
		}
	}
	// Decode query: tool_guid.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsDotToolGUIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolGUIDVal = CodeScanningAnalysisToolGUID(paramsDotToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsDotToolGUIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_guid: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Decode query: sarif_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sarif_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSarifIDVal CodeScanningAnalysisSarifID
				if err := func() error {
					var paramsDotSarifIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotSarifIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotSarifIDVal = CodeScanningAnalysisSarifID(paramsDotSarifIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.SarifID.SetTo(paramsDotSarifIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sarif_id: parse")
			}
		}
	}
	return params, nil
}

func decodeCodeScanningUpdateAlertParams(args [3]string, r *http.Request) (params CodeScanningUpdateAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

func decodeCodeScanningUploadSarifParams(args [2]string, r *http.Request) (params CodeScanningUploadSarifParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeCodesOfConductGetConductCodeParams(args [1]string, r *http.Request) (params CodesOfConductGetConductCodeParams, _ error) {
	// Decode path: key.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: key: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateRemoveTokenForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteScimGroupFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteUserFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminGetAllowedActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetAuditLogParams(args [1]string, r *http.Request) (params EnterpriseAdminGetAuditLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: phrase.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPhraseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsDotPhraseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: phrase: parse")
			}
		}
	}
	// Decode query: include.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeVal EnterpriseAdminGetAuditLogInclude
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIncludeVal = EnterpriseAdminGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsDotIncludeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include: parse")
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: include: invalid")
			}
		}
	}
	// Decode query: after.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal EnterpriseAdminGetAuditLogOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = EnterpriseAdminGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	// Decode query: excludedAttributes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludedAttributesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsDotExcludedAttributesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: excludedAttributes: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListProvisionedGroupsEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: startIndex.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartIndexVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsDotStartIndexVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startIndex: parse")
			}
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCountVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsDotCountVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		}
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
		}
	}
	// Decode query: excludedAttributes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludedAttributesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsDotExcludedAttributesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: excludedAttributes: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: startIndex.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartIndexVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsDotStartIndexVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startIndex: parse")
			}
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCountVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsDotCountVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		}
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListRunnerApplicationsForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args [1]string, r *http.Request) (params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args [1]string, r *http.Request) (params EnterpriseAdminProvisionAndInviteEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetAllowedActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateAttributeForEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsCheckIsStarredParams(args [1]string, r *http.Request) (params GistsCheckIsStarredParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsCreateCommentParams(args [1]string, r *http.Request) (params GistsCreateCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsDeleteParams(args [1]string, r *http.Request) (params GistsDeleteParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsDeleteCommentParams(args [2]string, r *http.Request) (params GistsDeleteCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsForkParams(args [1]string, r *http.Request) (params GistsForkParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsGetParams(args [1]string, r *http.Request) (params GistsGetParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsGetCommentParams(args [2]string, r *http.Request) (params GistsGetCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsGetRevisionParams(args [2]string, r *http.Request) (params GistsGetRevisionParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: sha.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: sha: not specified")
		}
	}
	return params, nil
}

func decodeGistsListParams(args [0]string, r *http.Request) (params GistsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListCommentsParams(args [1]string, r *http.Request) (params GistsListCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListCommitsParams(args [1]string, r *http.Request) (params GistsListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListForUserParams(args [1]string, r *http.Request) (params GistsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListForksParams(args [1]string, r *http.Request) (params GistsListForksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListPublicParams(args [0]string, r *http.Request) (params GistsListPublicParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsListStarredParams(args [0]string, r *http.Request) (params GistsListStarredParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGistsStarParams(args [1]string, r *http.Request) (params GistsStarParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsUnstarParams(args [1]string, r *http.Request) (params GistsUnstarParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

func decodeGistsUpdateCommentParams(args [2]string, r *http.Request) (params GistsUpdateCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeGitCreateBlobParams(args [2]string, r *http.Request) (params GitCreateBlobParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeGitCreateCommitParams(args [2]string, r *http.Request) (params GitCreateCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeGitCreateRefParams(args [2]string, r *http.Request) (params GitCreateRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeGitCreateTagParams(args [2]string, r *http.Request) (params GitCreateTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeGitCreateTreeParams(args [2]string, r *http.Request) (params GitCreateTreeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeGitDeleteRefParams(args [3]string, r *http.Request) (params GitDeleteRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeGitGetBlobParams(args [3]string, r *http.Request) (params GitGetBlobParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: file_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: file_sha: not specified")
		}
	}
	return params, nil
}

func decodeGitGetCommitParams(args [3]string, r *http.Request) (params GitGetCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

func decodeGitGetRefParams(args [3]string, r *http.Request) (params GitGetRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeGitGetTagParams(args [3]string, r *http.Request) (params GitGetTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tag_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: tag_sha: not specified")
		}
	}
	return params, nil
}

func decodeGitGetTreeParams(args [3]string, r *http.Request) (params GitGetTreeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tree_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tree_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TreeSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: tree_sha: not specified")
		}
	}
	// Decode query: recursive.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "recursive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRecursiveVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRecursiveVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Recursive.SetTo(paramsDotRecursiveVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: recursive: parse")
			}
		}
	}
	return params, nil
}

func decodeGitListMatchingRefsParams(args [3]string, r *http.Request) (params GitListMatchingRefsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeGitUpdateRefParams(args [3]string, r *http.Request) (params GitUpdateRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeGitignoreGetTemplateParams(args [1]string, r *http.Request) (params GitignoreGetTemplateParams, _ error) {
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForOrgParams(args [1]string, r *http.Request) (params InteractionsRemoveRestrictionsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeInteractionsRemoveRestrictionsForRepoParams(args [2]string, r *http.Request) (params InteractionsRemoveRestrictionsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeInteractionsSetRestrictionsForOrgParams(args [1]string, r *http.Request) (params InteractionsSetRestrictionsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeInteractionsSetRestrictionsForRepoParams(args [2]string, r *http.Request) (params InteractionsSetRestrictionsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeIssuesAddAssigneesParams(args [3]string, r *http.Request) (params IssuesAddAssigneesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesCheckUserCanBeAssignedParams(args [3]string, r *http.Request) (params IssuesCheckUserCanBeAssignedParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: assignee.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assignee",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Assignee = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: assignee: not specified")
		}
	}
	return params, nil
}

func decodeIssuesCreateParams(args [2]string, r *http.Request) (params IssuesCreateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeIssuesCreateCommentParams(args [3]string, r *http.Request) (params IssuesCreateCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesCreateLabelParams(args [2]string, r *http.Request) (params IssuesCreateLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeIssuesCreateMilestoneParams(args [2]string, r *http.Request) (params IssuesCreateMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeIssuesDeleteCommentParams(args [3]string, r *http.Request) (params IssuesDeleteCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeIssuesDeleteLabelParams(args [3]string, r *http.Request) (params IssuesDeleteLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

func decodeIssuesDeleteMilestoneParams(args [3]string, r *http.Request) (params IssuesDeleteMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesGetParams(args [3]string, r *http.Request) (params IssuesGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesGetCommentParams(args [3]string, r *http.Request) (params IssuesGetCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeIssuesGetEventParams(args [3]string, r *http.Request) (params IssuesGetEventParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: event_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: event_id: not specified")
		}
	}
	return params, nil
}

func decodeIssuesGetLabelParams(args [3]string, r *http.Request) (params IssuesGetLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

func decodeIssuesGetMilestoneParams(args [3]string, r *http.Request) (params IssuesGetMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesListParams(args [0]string, r *http.Request) (params IssuesListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: filter.
	{
		val := IssuesListFilter("assigned")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: collab.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "collab",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCollabVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCollabVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Collab.SetTo(paramsDotCollabVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: collab: parse")
			}
		}
	}
	// Decode query: orgs.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orgs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrgsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotOrgsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orgs.SetTo(paramsDotOrgsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: orgs: parse")
			}
		}
	}
	// Decode query: owned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "owned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOwnedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotOwnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Owned.SetTo(paramsDotOwnedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: owned: parse")
			}
		}
	}
	// Decode query: pulls.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pulls",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPullsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotPullsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pulls.SetTo(paramsDotPullsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pulls: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListAssigneesParams(args [2]string, r *http.Request) (params IssuesListAssigneesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListCommentsParams(args [3]string, r *http.Request) (params IssuesListCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListCommentsForRepoParams(args [2]string, r *http.Request) (params IssuesListCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListCommentsForRepoSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListCommentsForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListCommentsForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListEventsForRepoParams(args [2]string, r *http.Request) (params IssuesListEventsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListForAuthenticatedUserParams(args [0]string, r *http.Request) (params IssuesListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: filter.
	{
		val := IssuesListForAuthenticatedUserFilter("assigned")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListForAuthenticatedUserFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListForAuthenticatedUserFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForAuthenticatedUserState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForAuthenticatedUserSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForAuthenticatedUserDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListForOrgParams(args [1]string, r *http.Request) (params IssuesListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := IssuesListForOrgFilter("assigned")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListForOrgFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListForOrgFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForOrgState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForOrgSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForOrgSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForOrgDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListForRepoParams(args [2]string, r *http.Request) (params IssuesListForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: milestone.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "milestone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMilestoneVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMilestoneVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Milestone.SetTo(paramsDotMilestoneVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: milestone: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForRepoState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: assignee.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "assignee",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAssigneeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAssigneeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Assignee.SetTo(paramsDotAssigneeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: assignee: parse")
			}
		}
	}
	// Decode query: creator.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "creator",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCreatorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCreatorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Creator.SetTo(paramsDotCreatorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: creator: parse")
			}
		}
	}
	// Decode query: mentioned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mentioned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMentionedVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMentionedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mentioned.SetTo(paramsDotMentionedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mentioned: parse")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForRepoSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForRepoDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForMilestoneParams(args [3]string, r *http.Request) (params IssuesListLabelsForMilestoneParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsForRepoParams(args [2]string, r *http.Request) (params IssuesListLabelsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListLabelsOnIssueParams(args [3]string, r *http.Request) (params IssuesListLabelsOnIssueParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesListMilestonesParams(args [2]string, r *http.Request) (params IssuesListMilestonesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListMilestonesState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListMilestonesState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListMilestonesState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListMilestonesSort("due_on")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListMilestonesSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListMilestonesSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListMilestonesDirection("asc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListMilestonesDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListMilestonesDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeIssuesLockParams(args [3]string, r *http.Request) (params IssuesLockParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesRemoveAllLabelsParams(args [3]string, r *http.Request) (params IssuesRemoveAllLabelsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesRemoveAssigneesParams(args [3]string, r *http.Request) (params IssuesRemoveAssigneesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesRemoveLabelParams(args [4]string, r *http.Request) (params IssuesRemoveLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

func decodeIssuesUnlockParams(args [3]string, r *http.Request) (params IssuesUnlockParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesUpdateParams(args [3]string, r *http.Request) (params IssuesUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeIssuesUpdateCommentParams(args [3]string, r *http.Request) (params IssuesUpdateCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeIssuesUpdateLabelParams(args [3]string, r *http.Request) (params IssuesUpdateLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

func decodeIssuesUpdateMilestoneParams(args [3]string, r *http.Request) (params IssuesUpdateMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

func decodeLicensesGetParams(args [1]string, r *http.Request) (params LicensesGetParams, _ error) {
	// Decode path: license.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "license",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.License = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: license: not specified")
		}
	}
	return params, nil
}

func decodeLicensesGetAllCommonlyUsedParams(args [0]string, r *http.Request) (params LicensesGetAllCommonlyUsedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: featured.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeaturedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFeaturedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Featured.SetTo(paramsDotFeaturedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: featured: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeLicensesGetForRepoParams(args [2]string, r *http.Request) (params LicensesGetForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsCancelImportParams(args [2]string, r *http.Request) (params MigrationsCancelImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsDeleteArchiveForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsDeleteArchiveForOrgParams(args [2]string, r *http.Request) (params MigrationsDeleteArchiveForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsDownloadArchiveForOrgParams(args [2]string, r *http.Request) (params MigrationsDownloadArchiveForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsGetArchiveForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsGetCommitAuthorsParams(args [2]string, r *http.Request) (params MigrationsGetCommitAuthorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetImportStatusParams(args [2]string, r *http.Request) (params MigrationsGetImportStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsGetLargeFilesParams(args [2]string, r *http.Request) (params MigrationsGetLargeFilesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsGetStatusForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
		}
	}
	return params, nil
}

func decodeMigrationsGetStatusForOrgParams(args [2]string, r *http.Request) (params MigrationsGetStatusForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal MigrationsGetStatusForOrgExcludeItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = MigrationsGetStatusForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: exclude: invalid")
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params MigrationsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeMigrationsListForOrgParams(args [1]string, r *http.Request) (params MigrationsListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal MigrationsListForOrgExcludeItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = MigrationsListForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: exclude: invalid")
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForOrgParams(args [2]string, r *http.Request) (params MigrationsListReposForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeMigrationsListReposForUserParams(args [1]string, r *http.Request) (params MigrationsListReposForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeMigrationsMapCommitAuthorParams(args [3]string, r *http.Request) (params MigrationsMapCommitAuthorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: author_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "author_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: author_id: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsSetLfsPreferenceParams(args [2]string, r *http.Request) (params MigrationsSetLfsPreferenceParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsStartForOrgParams(args [1]string, r *http.Request) (params MigrationsStartForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsStartImportParams(args [2]string, r *http.Request) (params MigrationsStartImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params MigrationsUnlockRepoForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode path: repo_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo_name: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsUnlockRepoForOrgParams(args [3]string, r *http.Request) (params MigrationsUnlockRepoForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode path: repo_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo_name: not specified")
		}
	}
	return params, nil
}

func decodeMigrationsUpdateImportParams(args [2]string, r *http.Request) (params MigrationsUpdateImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsDeleteAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsDeleteGrantParams(args [1]string, r *http.Request) (params OAuthAuthorizationsDeleteGrantParams, _ error) {
	// Decode path: grant_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: grant_id: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetGrantParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetGrantParams, _ error) {
	// Decode path: grant_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: grant_id: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args [2]string, r *http.Request) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	// Decode path: fingerprint.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fingerprint",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fingerprint = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: fingerprint: not specified")
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListAuthorizationsParams(args [0]string, r *http.Request) (params OAuthAuthorizationsListAuthorizationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: client_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClientIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsDotClientIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: client_id: parse")
			}
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsListGrantsParams(args [0]string, r *http.Request) (params OAuthAuthorizationsListGrantsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: client_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClientIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsDotClientIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: client_id: parse")
			}
		}
	}
	return params, nil
}

func decodeOAuthAuthorizationsUpdateAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsUpdateAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsBlockUserParams(args [2]string, r *http.Request) (params OrgsBlockUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCancelInvitationParams(args [2]string, r *http.Request) (params OrgsCancelInvitationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCheckBlockedUserParams(args [2]string, r *http.Request) (params OrgsCheckBlockedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCheckMembershipForUserParams(args [2]string, r *http.Request) (params OrgsCheckMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCheckPublicMembershipForUserParams(args [2]string, r *http.Request) (params OrgsCheckPublicMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(args [2]string, r *http.Request) (params OrgsConvertMemberToOutsideCollaboratorParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCreateInvitationParams(args [1]string, r *http.Request) (params OrgsCreateInvitationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsCreateWebhookParams(args [1]string, r *http.Request) (params OrgsCreateWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsDeleteWebhookParams(args [2]string, r *http.Request) (params OrgsDeleteWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetParams(args [1]string, r *http.Request) (params OrgsGetParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetAuditLogParams(args [1]string, r *http.Request) (params OrgsGetAuditLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: phrase.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPhraseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsDotPhraseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: phrase: parse")
			}
		}
	}
	// Decode query: include.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeVal OrgsGetAuditLogInclude
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIncludeVal = OrgsGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsDotIncludeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include: parse")
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: include: invalid")
			}
		}
	}
	// Decode query: after.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal OrgsGetAuditLogOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = OrgsGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(args [1]string, r *http.Request) (params OrgsGetMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetMembershipForUserParams(args [2]string, r *http.Request) (params OrgsGetMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookParams(args [2]string, r *http.Request) (params OrgsGetWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookConfigForOrgParams(args [2]string, r *http.Request) (params OrgsGetWebhookConfigForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsGetWebhookDeliveryParams(args [3]string, r *http.Request) (params OrgsGetWebhookDeliveryParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsListParams(args [0]string, r *http.Request) (params OrgsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListBlockedUsersParams(args [1]string, r *http.Request) (params OrgsListBlockedUsersParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsListFailedInvitationsParams(args [1]string, r *http.Request) (params OrgsListFailedInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params OrgsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListForUserParams(args [1]string, r *http.Request) (params OrgsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListInvitationTeamsParams(args [2]string, r *http.Request) (params OrgsListInvitationTeamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListMembersParams(args [1]string, r *http.Request) (params OrgsListMembersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := OrgsListMembersFilter("all")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal OrgsListMembersFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = OrgsListMembersFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: role.
	{
		val := OrgsListMembersRole("all")

		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal OrgsListMembersRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = OrgsListMembersRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListMembershipsForAuthenticatedUserParams(args [0]string, r *http.Request) (params OrgsListMembershipsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal OrgsListMembershipsForAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = OrgsListMembershipsForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListOutsideCollaboratorsParams(args [1]string, r *http.Request) (params OrgsListOutsideCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := OrgsListOutsideCollaboratorsFilter("all")

		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal OrgsListOutsideCollaboratorsFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = OrgsListOutsideCollaboratorsFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListPendingInvitationsParams(args [1]string, r *http.Request) (params OrgsListPendingInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListPublicMembersParams(args [1]string, r *http.Request) (params OrgsListPublicMembersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListSamlSSOAuthorizationsParams(args [1]string, r *http.Request) (params OrgsListSamlSSOAuthorizationsParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsListWebhookDeliveriesParams(args [2]string, r *http.Request) (params OrgsListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsListWebhooksParams(args [1]string, r *http.Request) (params OrgsListWebhooksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeOrgsPingWebhookParams(args [2]string, r *http.Request) (params OrgsPingWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRedeliverWebhookDeliveryParams(args [3]string, r *http.Request) (params OrgsRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRemoveMemberParams(args [2]string, r *http.Request) (params OrgsRemoveMemberParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRemoveMembershipForUserParams(args [2]string, r *http.Request) (params OrgsRemoveMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRemoveOutsideCollaboratorParams(args [2]string, r *http.Request) (params OrgsRemoveOutsideCollaboratorParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args [2]string, r *http.Request) (params OrgsRemovePublicMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(args [2]string, r *http.Request) (params OrgsRemoveSamlSSOAuthorizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: credential_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "credential_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CredentialID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: credential_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsSetMembershipForUserParams(args [2]string, r *http.Request) (params OrgsSetMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args [2]string, r *http.Request) (params OrgsSetPublicMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsUnblockUserParams(args [2]string, r *http.Request) (params OrgsUnblockUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeOrgsUpdateMembershipForAuthenticatedUserParams(args [1]string, r *http.Request) (params OrgsUpdateMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeOrgsUpdateWebhookParams(args [2]string, r *http.Request) (params OrgsUpdateWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeOrgsUpdateWebhookConfigForOrgParams(args [2]string, r *http.Request) (params OrgsUpdateWebhookConfigForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesDeletePackageForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForOrgParams(args [3]string, r *http.Request) (params PackagesDeletePackageForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageForUserParams(args [3]string, r *http.Request) (params PackagesDeletePackageForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesDeletePackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForOrgParams(args [4]string, r *http.Request) (params PackagesDeletePackageVersionForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesDeletePackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesDeletePackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState("active")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args [3]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := PackagesGetAllPackageVersionsForPackageOwnedByOrgState("active")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PackagesGetAllPackageVersionsForPackageOwnedByOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args [3]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesGetPackageForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageForOrganizationParams(args [3]string, r *http.Request) (params PackagesGetPackageForOrganizationParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageForUserParams(args [3]string, r *http.Request) (params PackagesGetPackageForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesGetPackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForOrganizationParams(args [4]string, r *http.Request) (params PackagesGetPackageVersionForOrganizationParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesGetPackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesGetPackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodePackagesListPackagesForAuthenticatedUserParams(args [0]string, r *http.Request) (params PackagesListPackagesForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForAuthenticatedUserPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForAuthenticatedUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForOrganizationParams(args [1]string, r *http.Request) (params PackagesListPackagesForOrganizationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForOrganizationPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForOrganizationVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForOrganizationVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	return params, nil
}

func decodePackagesListPackagesForUserParams(args [1]string, r *http.Request) (params PackagesListPackagesForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForUserPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesRestorePackageForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForOrgParams(args [3]string, r *http.Request) (params PackagesRestorePackageForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageForUserParams(args [3]string, r *http.Request) (params PackagesRestorePackageForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesRestorePackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForOrgParams(args [4]string, r *http.Request) (params PackagesRestorePackageVersionForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodePackagesRestorePackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesRestorePackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsAddCollaboratorParams(args [2]string, r *http.Request) (params ProjectsAddCollaboratorParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeProjectsCreateColumnParams(args [1]string, r *http.Request) (params ProjectsCreateColumnParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsCreateForOrgParams(args [1]string, r *http.Request) (params ProjectsCreateForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeProjectsCreateForRepoParams(args [2]string, r *http.Request) (params ProjectsCreateForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeProjectsDeleteParams(args [1]string, r *http.Request) (params ProjectsDeleteParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsDeleteCardParams(args [1]string, r *http.Request) (params ProjectsDeleteCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsDeleteColumnParams(args [1]string, r *http.Request) (params ProjectsDeleteColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsGetParams(args [1]string, r *http.Request) (params ProjectsGetParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsGetCardParams(args [1]string, r *http.Request) (params ProjectsGetCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsGetColumnParams(args [1]string, r *http.Request) (params ProjectsGetColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsGetPermissionForUserParams(args [2]string, r *http.Request) (params ProjectsGetPermissionForUserParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeProjectsListCardsParams(args [1]string, r *http.Request) (params ProjectsListCardsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	// Set default value for query: archived_state.
	{
		val := ProjectsListCardsArchivedState("not_archived")

		params.ArchivedState.SetTo(val)
	}
	// Decode query: archived_state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "archived_state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotArchivedStateVal ProjectsListCardsArchivedState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotArchivedStateVal = ProjectsListCardsArchivedState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.ArchivedState.SetTo(paramsDotArchivedStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: archived_state: parse")
			}
			if err := func() error {
				if params.ArchivedState.Set {
					if err := func() error {
						if err := params.ArchivedState.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: archived_state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsListCollaboratorsParams(args [1]string, r *http.Request) (params ProjectsListCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Set default value for query: affiliation.
	{
		val := ProjectsListCollaboratorsAffiliation("all")

		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal ProjectsListCollaboratorsAffiliation
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = ProjectsListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: affiliation: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsListColumnsParams(args [1]string, r *http.Request) (params ProjectsListColumnsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsListForOrgParams(args [1]string, r *http.Request) (params ProjectsListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForOrgState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsListForRepoParams(args [2]string, r *http.Request) (params ProjectsListForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForRepoState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsListForUserParams(args [1]string, r *http.Request) (params ProjectsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForUserState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeProjectsMoveCardParams(args [1]string, r *http.Request) (params ProjectsMoveCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsMoveColumnParams(args [1]string, r *http.Request) (params ProjectsMoveColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsRemoveCollaboratorParams(args [2]string, r *http.Request) (params ProjectsRemoveCollaboratorParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeProjectsUpdateParams(args [1]string, r *http.Request) (params ProjectsUpdateParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsUpdateCardParams(args [1]string, r *http.Request) (params ProjectsUpdateCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

func decodeProjectsUpdateColumnParams(args [1]string, r *http.Request) (params ProjectsUpdateColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

func decodePullsCheckIfMergedParams(args [3]string, r *http.Request) (params PullsCheckIfMergedParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsCreateParams(args [2]string, r *http.Request) (params PullsCreateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodePullsCreateReplyForReviewCommentParams(args [4]string, r *http.Request) (params PullsCreateReplyForReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodePullsCreateReviewParams(args [3]string, r *http.Request) (params PullsCreateReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsCreateReviewCommentParams(args [3]string, r *http.Request) (params PullsCreateReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsDeletePendingReviewParams(args [4]string, r *http.Request) (params PullsDeletePendingReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

func decodePullsDeleteReviewCommentParams(args [3]string, r *http.Request) (params PullsDeleteReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodePullsDismissReviewParams(args [4]string, r *http.Request) (params PullsDismissReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

func decodePullsGetParams(args [3]string, r *http.Request) (params PullsGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsGetReviewParams(args [4]string, r *http.Request) (params PullsGetReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

func decodePullsGetReviewCommentParams(args [3]string, r *http.Request) (params PullsGetReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodePullsListParams(args [2]string, r *http.Request) (params PullsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := PullsListState("open")

		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PullsListState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PullsListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: head.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "head",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotHeadVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotHeadVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Head.SetTo(paramsDotHeadVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: head: parse")
			}
		}
	}
	// Decode query: base.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "base",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBaseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBaseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Base.SetTo(paramsDotBaseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: base: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := PullsListSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListCommentsForReviewParams(args [4]string, r *http.Request) (params PullsListCommentsForReviewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListCommitsParams(args [3]string, r *http.Request) (params PullsListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListFilesParams(args [3]string, r *http.Request) (params PullsListFilesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListRequestedReviewersParams(args [3]string, r *http.Request) (params PullsListRequestedReviewersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsParams(args [3]string, r *http.Request) (params PullsListReviewCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := PullsListReviewCommentsSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListReviewCommentsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListReviewCommentsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListReviewCommentsDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListReviewCommentsDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListReviewCommentsForRepoParams(args [2]string, r *http.Request) (params PullsListReviewCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListReviewCommentsForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListReviewCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListReviewCommentsForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListReviewCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsListReviewsParams(args [3]string, r *http.Request) (params PullsListReviewsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodePullsMergeParams(args [3]string, r *http.Request) (params PullsMergeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsRemoveRequestedReviewersParams(args [3]string, r *http.Request) (params PullsRemoveRequestedReviewersParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsSubmitReviewParams(args [4]string, r *http.Request) (params PullsSubmitReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

func decodePullsUpdateParams(args [3]string, r *http.Request) (params PullsUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsUpdateBranchParams(args [3]string, r *http.Request) (params PullsUpdateBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

func decodePullsUpdateReviewParams(args [4]string, r *http.Request) (params PullsUpdateReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

func decodePullsUpdateReviewCommentParams(args [3]string, r *http.Request) (params PullsUpdateReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForCommitCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForIssueParams(args [3]string, r *http.Request) (params ReactionsCreateForIssueParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForIssueCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForIssueCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForPullRequestReviewCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForPullRequestReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForReleaseParams(args [3]string, r *http.Request) (params ReactionsCreateForReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params ReactionsCreateForTeamDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params ReactionsCreateForTeamDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(args [3]string, r *http.Request) (params ReactionsCreateForTeamDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(args [2]string, r *http.Request) (params ReactionsCreateForTeamDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForCommitCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueParams(args [4]string, r *http.Request) (params ReactionsDeleteForIssueParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForIssueCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForIssueCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForPullRequestCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForPullRequestCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionParams(args [4]string, r *http.Request) (params ReactionsDeleteForTeamDiscussionParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(args [5]string, r *http.Request) (params ReactionsDeleteForTeamDiscussionCommentParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[4]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsDeleteLegacyParams(args [1]string, r *http.Request) (params ReactionsDeleteLegacyParams, _ error) {
	// Decode path: reaction_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

func decodeReactionsListForCommitCommentParams(args [3]string, r *http.Request) (params ReactionsListForCommitCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForCommitCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForCommitCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueParams(args [3]string, r *http.Request) (params ReactionsListForIssueParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForIssueContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForIssueContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForIssueCommentParams(args [3]string, r *http.Request) (params ReactionsListForIssueCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForIssueCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForIssueCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForPullRequestReviewCommentParams(args [3]string, r *http.Request) (params ReactionsListForPullRequestReviewCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForPullRequestReviewCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForPullRequestReviewCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params ReactionsListForTeamDiscussionCommentInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionCommentInOrgContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionCommentInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params ReactionsListForTeamDiscussionCommentLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionCommentLegacyContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionCommentLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionInOrgParams(args [3]string, r *http.Request) (params ReactionsListForTeamDiscussionInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionInOrgContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReactionsListForTeamDiscussionLegacyParams(args [2]string, r *http.Request) (params ReactionsListForTeamDiscussionLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionLegacyContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposAcceptInvitationParams(args [1]string, r *http.Request) (params ReposAcceptInvitationParams, _ error) {
	// Decode path: invitation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

func decodeReposAddAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposAddCollaboratorParams(args [3]string, r *http.Request) (params ReposAddCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeReposAddStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposAddStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposAddTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposAddUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposCheckCollaboratorParams(args [3]string, r *http.Request) (params ReposCheckCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeReposCheckVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposCheckVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCompareCommitsParams(args [3]string, r *http.Request) (params ReposCompareCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode path: basehead.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "basehead",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Basehead = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: basehead: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateAutolinkParams(args [2]string, r *http.Request) (params ReposCreateAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateCommitCommentParams(args [3]string, r *http.Request) (params ReposCreateCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposCreateCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateCommitStatusParams(args [3]string, r *http.Request) (params ReposCreateCommitStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: sha: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateDeployKeyParams(args [2]string, r *http.Request) (params ReposCreateDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateDeploymentParams(args [2]string, r *http.Request) (params ReposCreateDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateDeploymentStatusParams(args [3]string, r *http.Request) (params ReposCreateDeploymentStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateDispatchEventParams(args [2]string, r *http.Request) (params ReposCreateDispatchEventParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateForkParams(args [2]string, r *http.Request) (params ReposCreateForkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateInOrgParams(args [1]string, r *http.Request) (params ReposCreateInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateOrUpdateFileContentsParams(args [3]string, r *http.Request) (params ReposCreateOrUpdateFileContentsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: path.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: path: not specified")
		}
	}
	return params, nil
}

func decodeReposCreatePagesSiteParams(args [2]string, r *http.Request) (params ReposCreatePagesSiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateReleaseParams(args [2]string, r *http.Request) (params ReposCreateReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateUsingTemplateParams(args [2]string, r *http.Request) (params ReposCreateUsingTemplateParams, _ error) {
	// Decode path: template_owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TemplateOwner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: template_owner: not specified")
		}
	}
	// Decode path: template_repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TemplateRepo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: template_repo: not specified")
		}
	}
	return params, nil
}

func decodeReposCreateWebhookParams(args [2]string, r *http.Request) (params ReposCreateWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDeclineInvitationParams(args [1]string, r *http.Request) (params ReposDeclineInvitationParams, _ error) {
	// Decode path: invitation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteParams(args [2]string, r *http.Request) (params ReposDeleteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposDeleteAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposDeleteAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteAnEnvironmentParams(args [3]string, r *http.Request) (params ReposDeleteAnEnvironmentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteAutolinkParams(args [3]string, r *http.Request) (params ReposDeleteAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: autolink_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: autolink_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteBranchProtectionParams(args [3]string, r *http.Request) (params ReposDeleteBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteCommitCommentParams(args [3]string, r *http.Request) (params ReposDeleteCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposDeleteCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteDeployKeyParams(args [3]string, r *http.Request) (params ReposDeleteDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: key_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteDeploymentParams(args [3]string, r *http.Request) (params ReposDeleteDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteFileParams(args [3]string, r *http.Request) (params ReposDeleteFileParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: path.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: path: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteInvitationParams(args [3]string, r *http.Request) (params ReposDeleteInvitationParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeletePagesSiteParams(args [2]string, r *http.Request) (params ReposDeletePagesSiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDeletePullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposDeletePullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseParams(args [3]string, r *http.Request) (params ReposDeleteReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteReleaseAssetParams(args [3]string, r *http.Request) (params ReposDeleteReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDeleteWebhookParams(args [3]string, r *http.Request) (params ReposDeleteWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposDisableAutomatedSecurityFixesParams(args [2]string, r *http.Request) (params ReposDisableAutomatedSecurityFixesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDisableLfsForRepoParams(args [2]string, r *http.Request) (params ReposDisableLfsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDisableVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposDisableVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposDownloadTarballArchiveParams(args [3]string, r *http.Request) (params ReposDownloadTarballArchiveParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeReposDownloadZipballArchiveParams(args [3]string, r *http.Request) (params ReposDownloadZipballArchiveParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeReposEnableAutomatedSecurityFixesParams(args [2]string, r *http.Request) (params ReposEnableAutomatedSecurityFixesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposEnableLfsForRepoParams(args [2]string, r *http.Request) (params ReposEnableLfsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposEnableVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposEnableVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetParams(args [2]string, r *http.Request) (params ReposGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposGetAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposGetAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetAllStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposGetAllStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetAllTopicsParams(args [2]string, r *http.Request) (params ReposGetAllTopicsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetAppsWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetAutolinkParams(args [3]string, r *http.Request) (params ReposGetAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: autolink_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: autolink_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetBranchParams(args [3]string, r *http.Request) (params ReposGetBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetBranchProtectionParams(args [3]string, r *http.Request) (params ReposGetBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetClonesParams(args [2]string, r *http.Request) (params ReposGetClonesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per.
	{
		val := ReposGetClonesPer("day")

		params.Per.SetTo(val)
	}
	// Decode query: per.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerVal ReposGetClonesPer
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPerVal = ReposGetClonesPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsDotPerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per: parse")
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: per: invalid")
			}
		}
	}
	return params, nil
}

func decodeReposGetCodeFrequencyStatsParams(args [2]string, r *http.Request) (params ReposGetCodeFrequencyStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCollaboratorPermissionLevelParams(args [3]string, r *http.Request) (params ReposGetCollaboratorPermissionLevelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCombinedStatusForRefParams(args [3]string, r *http.Request) (params ReposGetCombinedStatusForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposGetCommitParams(args [3]string, r *http.Request) (params ReposGetCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCommitActivityStatsParams(args [2]string, r *http.Request) (params ReposGetCommitActivityStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCommitCommentParams(args [3]string, r *http.Request) (params ReposGetCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposGetCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetCommunityProfileMetricsParams(args [2]string, r *http.Request) (params ReposGetCommunityProfileMetricsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetContributorsStatsParams(args [2]string, r *http.Request) (params ReposGetContributorsStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetDeployKeyParams(args [3]string, r *http.Request) (params ReposGetDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: key_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetDeploymentParams(args [3]string, r *http.Request) (params ReposGetDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetDeploymentStatusParams(args [4]string, r *http.Request) (params ReposGetDeploymentStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	// Decode path: status_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "status_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.StatusID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: status_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetLatestPagesBuildParams(args [2]string, r *http.Request) (params ReposGetLatestPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetLatestReleaseParams(args [2]string, r *http.Request) (params ReposGetLatestReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetPagesParams(args [2]string, r *http.Request) (params ReposGetPagesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetPagesBuildParams(args [3]string, r *http.Request) (params ReposGetPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: build_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "build_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.BuildID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: build_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetPagesHealthCheckParams(args [2]string, r *http.Request) (params ReposGetPagesHealthCheckParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetParticipationStatsParams(args [2]string, r *http.Request) (params ReposGetParticipationStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetPullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposGetPullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetPunchCardStatsParams(args [2]string, r *http.Request) (params ReposGetPunchCardStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetReadmeParams(args [2]string, r *http.Request) (params ReposGetReadmeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

func decodeReposGetReadmeInDirectoryParams(args [3]string, r *http.Request) (params ReposGetReadmeInDirectoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: dir.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dir",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Dir = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: dir: not specified")
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

func decodeReposGetReleaseParams(args [3]string, r *http.Request) (params ReposGetReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetReleaseAssetParams(args [3]string, r *http.Request) (params ReposGetReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetReleaseByTagParams(args [3]string, r *http.Request) (params ReposGetReleaseByTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tag.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Tag = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: tag: not specified")
		}
	}
	return params, nil
}

func decodeReposGetStatusChecksProtectionParams(args [3]string, r *http.Request) (params ReposGetStatusChecksProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetTeamsWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetTopPathsParams(args [2]string, r *http.Request) (params ReposGetTopPathsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetTopReferrersParams(args [2]string, r *http.Request) (params ReposGetTopReferrersParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetUsersWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposGetViewsParams(args [2]string, r *http.Request) (params ReposGetViewsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per.
	{
		val := ReposGetViewsPer("day")

		params.Per.SetTo(val)
	}
	// Decode query: per.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerVal ReposGetViewsPer
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPerVal = ReposGetViewsPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsDotPerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per: parse")
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: per: invalid")
			}
		}
	}
	return params, nil
}

func decodeReposGetWebhookParams(args [3]string, r *http.Request) (params ReposGetWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetWebhookConfigForRepoParams(args [3]string, r *http.Request) (params ReposGetWebhookConfigForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposGetWebhookDeliveryParams(args [4]string, r *http.Request) (params ReposGetWebhookDeliveryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeReposListAutolinksParams(args [2]string, r *http.Request) (params ReposListAutolinksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListBranchesParams(args [2]string, r *http.Request) (params ReposListBranchesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: protected.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtectedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotProtectedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Protected.SetTo(paramsDotProtectedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: protected: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListBranchesForHeadCommitParams(args [3]string, r *http.Request) (params ReposListBranchesForHeadCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

func decodeReposListCollaboratorsParams(args [2]string, r *http.Request) (params ReposListCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: affiliation.
	{
		val := ReposListCollaboratorsAffiliation("all")

		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal ReposListCollaboratorsAffiliation
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = ReposListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: affiliation: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListCommentsForCommitParams(args [3]string, r *http.Request) (params ReposListCommentsForCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListCommitCommentsForRepoParams(args [2]string, r *http.Request) (params ReposListCommitCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListCommitStatusesForRefParams(args [3]string, r *http.Request) (params ReposListCommitStatusesForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListCommitsParams(args [2]string, r *http.Request) (params ReposListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: sha.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotShaVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsDotShaVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sha: parse")
			}
		}
	}
	// Decode query: path.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Path.SetTo(paramsDotPathVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: path: parse")
			}
		}
	}
	// Decode query: author.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "author",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAuthorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAuthorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Author.SetTo(paramsDotAuthorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: author: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: until.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUntilVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotUntilVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Until.SetTo(paramsDotUntilVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: until: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListContributorsParams(args [2]string, r *http.Request) (params ReposListContributorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: anon.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "anon",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAnonVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAnonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Anon.SetTo(paramsDotAnonVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: anon: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListDeployKeysParams(args [2]string, r *http.Request) (params ReposListDeployKeysParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListDeploymentStatusesParams(args [3]string, r *http.Request) (params ReposListDeploymentStatusesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListDeploymentsParams(args [2]string, r *http.Request) (params ReposListDeploymentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sha.
	{
		val := string("none")

		params.Sha.SetTo(val)
	}
	// Decode query: sha.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotShaVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsDotShaVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sha: parse")
			}
		}
	}
	// Set default value for query: ref.
	{
		val := string("none")

		params.Ref.SetTo(val)
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Set default value for query: task.
	{
		val := string("none")

		params.Task.SetTo(val)
	}
	// Decode query: task.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "task",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTaskVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTaskVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Task.SetTo(paramsDotTaskVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: task: parse")
			}
		}
	}
	// Set default value for query: environment.
	{
		val := string("none")

		params.Environment.SetTo(val)
	}
	// Decode query: environment.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEnvironmentVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEnvironmentVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Environment.SetTo(paramsDotEnvironmentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: environment: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListForAuthenticatedUserParams(args [0]string, r *http.Request) (params ReposListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: visibility.
	{
		val := ReposListForAuthenticatedUserVisibility("all")

		params.Visibility.SetTo(val)
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal ReposListForAuthenticatedUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = ReposListForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	// Set default value for query: affiliation.
	{
		val := string("owner,collaborator,organization_member")

		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
		}
	}
	// Set default value for query: type.
	{
		val := ReposListForAuthenticatedUserType("all")

		params.Type.SetTo(val)
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForAuthenticatedUserType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForAuthenticatedUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForAuthenticatedUserSort("full_name")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListForOrgParams(args [1]string, r *http.Request) (params ReposListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForOrgType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForOrgType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForOrgSort("created")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForOrgSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListForUserParams(args [1]string, r *http.Request) (params ReposListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: type.
	{
		val := ReposListForUserType("owner")

		params.Type.SetTo(val)
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForUserType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForUserSort("full_name")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListForksParams(args [2]string, r *http.Request) (params ReposListForksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForksSort("newest")

		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForksSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForksSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsParams(args [2]string, r *http.Request) (params ReposListInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListInvitationsForAuthenticatedUserParams(args [0]string, r *http.Request) (params ReposListInvitationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListLanguagesParams(args [2]string, r *http.Request) (params ReposListLanguagesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposListPagesBuildsParams(args [2]string, r *http.Request) (params ReposListPagesBuildsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListPublicParams(args [0]string, r *http.Request) (params ReposListPublicParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListPullRequestsAssociatedWithCommitParams(args [3]string, r *http.Request) (params ReposListPullRequestsAssociatedWithCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListReleaseAssetsParams(args [3]string, r *http.Request) (params ReposListReleaseAssetsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListReleasesParams(args [2]string, r *http.Request) (params ReposListReleasesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListTagsParams(args [2]string, r *http.Request) (params ReposListTagsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListTeamsParams(args [2]string, r *http.Request) (params ReposListTeamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListWebhookDeliveriesParams(args [3]string, r *http.Request) (params ReposListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

func decodeReposListWebhooksParams(args [2]string, r *http.Request) (params ReposListWebhooksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeReposMergeParams(args [2]string, r *http.Request) (params ReposMergeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposMergeUpstreamParams(args [2]string, r *http.Request) (params ReposMergeUpstreamParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposPingWebhookParams(args [3]string, r *http.Request) (params ReposPingWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposRedeliverWebhookDeliveryParams(args [4]string, r *http.Request) (params ReposRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveCollaboratorParams(args [3]string, r *http.Request) (params ReposRemoveCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposRemoveStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveStatusCheckProtectionParams(args [3]string, r *http.Request) (params ReposRemoveStatusCheckProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposRemoveUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposRenameBranchParams(args [3]string, r *http.Request) (params ReposRenameBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposReplaceAllTopicsParams(args [2]string, r *http.Request) (params ReposReplaceAllTopicsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposRequestPagesBuildParams(args [2]string, r *http.Request) (params ReposRequestPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposSetAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposSetAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposSetAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposSetStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposSetStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposSetTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposSetUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposTestPushWebhookParams(args [3]string, r *http.Request) (params ReposTestPushWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposTransferParams(args [2]string, r *http.Request) (params ReposTransferParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateParams(args [2]string, r *http.Request) (params ReposUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateBranchProtectionParams(args [3]string, r *http.Request) (params ReposUpdateBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateCommitCommentParams(args [3]string, r *http.Request) (params ReposUpdateCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateInvitationParams(args [3]string, r *http.Request) (params ReposUpdateInvitationParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdatePullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposUpdatePullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseParams(args [3]string, r *http.Request) (params ReposUpdateReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateReleaseAssetParams(args [3]string, r *http.Request) (params ReposUpdateReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateStatusCheckProtectionParams(args [3]string, r *http.Request) (params ReposUpdateStatusCheckProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateWebhookParams(args [3]string, r *http.Request) (params ReposUpdateWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeReposUpdateWebhookConfigForRepoParams(args [3]string, r *http.Request) (params ReposUpdateWebhookConfigForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

func decodeScimDeleteUserFromOrgParams(args [2]string, r *http.Request) (params ScimDeleteUserFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

func decodeSearchCodeParams(args [0]string, r *http.Request) (params SearchCodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchCodeSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchCodeSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchCodeOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchCodeOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchCodeOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchCommitsParams(args [0]string, r *http.Request) (params SearchCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchCommitsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchCommitsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchCommitsOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchCommitsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchCommitsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchIssuesAndPullRequestsParams(args [0]string, r *http.Request) (params SearchIssuesAndPullRequestsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchIssuesAndPullRequestsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchIssuesAndPullRequestsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchIssuesAndPullRequestsOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchIssuesAndPullRequestsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchIssuesAndPullRequestsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchLabelsParams(args [0]string, r *http.Request) (params SearchLabelsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: repository_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "repository_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: repository_id: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchLabelsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchLabelsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchLabelsOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchLabelsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchLabelsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchReposParams(args [0]string, r *http.Request) (params SearchReposParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchReposSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchReposSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchReposOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchReposOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchReposOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchTopicsParams(args [0]string, r *http.Request) (params SearchTopicsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSearchUsersParams(args [0]string, r *http.Request) (params SearchUsersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchUsersSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchUsersSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchUsersOrder("desc")

		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchUsersOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchUsersOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeSecretScanningGetAlertParams(args [3]string, r *http.Request) (params SecretScanningGetAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForOrgParams(args [1]string, r *http.Request) (params SecretScanningListAlertsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal SecretScanningListAlertsForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = SecretScanningListAlertsForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: secret_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSecretTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsDotSecretTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: secret_type: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeSecretScanningListAlertsForRepoParams(args [2]string, r *http.Request) (params SecretScanningListAlertsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal SecretScanningListAlertsForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = SecretScanningListAlertsForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: secret_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSecretTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsDotSecretTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: secret_type: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeSecretScanningUpdateAlertParams(args [3]string, r *http.Request) (params SecretScanningUpdateAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddMemberLegacyParams(args [2]string, r *http.Request) (params TeamsAddMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsAddOrUpdateMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateProjectPermissionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args [2]string, r *http.Request) (params TeamsAddOrUpdateProjectPermissionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args [4]string, r *http.Request) (params TeamsAddOrUpdateRepoPermissionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateRepoPermissionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(args [3]string, r *http.Request) (params TeamsCheckPermissionsForProjectInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(args [2]string, r *http.Request) (params TeamsCheckPermissionsForProjectLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(args [4]string, r *http.Request) (params TeamsCheckPermissionsForRepoInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(args [3]string, r *http.Request) (params TeamsCheckPermissionsForRepoLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateParams(args [1]string, r *http.Request) (params TeamsCreateParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentInOrgParams(args [3]string, r *http.Request) (params TeamsCreateDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionCommentLegacyParams(args [2]string, r *http.Request) (params TeamsCreateDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionInOrgParams(args [2]string, r *http.Request) (params TeamsCreateDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateDiscussionLegacyParams(args [1]string, r *http.Request) (params TeamsCreateDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args [2]string, r *http.Request) (params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args [1]string, r *http.Request) (params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsDeleteDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsDeleteDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsDeleteDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsDeleteDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteInOrgParams(args [2]string, r *http.Request) (params TeamsDeleteInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsDeleteLegacyParams(args [1]string, r *http.Request) (params TeamsDeleteLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetByNameParams(args [2]string, r *http.Request) (params TeamsGetByNameParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsGetDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsGetDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsGetDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsGetDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetLegacyParams(args [1]string, r *http.Request) (params TeamsGetLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetMemberLegacyParams(args [2]string, r *http.Request) (params TeamsGetMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsGetMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsGetMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsGetMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsListParams(args [1]string, r *http.Request) (params TeamsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListChildInOrgParams(args [2]string, r *http.Request) (params TeamsListChildInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListChildLegacyParams(args [1]string, r *http.Request) (params TeamsListChildLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsInOrgParams(args [3]string, r *http.Request) (params TeamsListDiscussionCommentsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionCommentsInOrgDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionCommentsInOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionCommentsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionCommentsLegacyParams(args [2]string, r *http.Request) (params TeamsListDiscussionCommentsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionCommentsLegacyDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionCommentsLegacyDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionCommentsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsInOrgParams(args [2]string, r *http.Request) (params TeamsListDiscussionsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionsInOrgDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionsInOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: pinned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pinned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPinnedVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPinnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pinned.SetTo(paramsDotPinnedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pinned: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListDiscussionsLegacyParams(args [1]string, r *http.Request) (params TeamsListDiscussionsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionsLegacyDirection("desc")

		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionsLegacyDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params TeamsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForLegacyParams(args [1]string, r *http.Request) (params TeamsListIdpGroupsForLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsForOrgParams(args [1]string, r *http.Request) (params TeamsListIdpGroupsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListIdpGroupsInOrgParams(args [2]string, r *http.Request) (params TeamsListIdpGroupsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsListMembersInOrgParams(args [2]string, r *http.Request) (params TeamsListMembersInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: role.
	{
		val := TeamsListMembersInOrgRole("all")

		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal TeamsListMembersInOrgRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = TeamsListMembersInOrgRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListMembersLegacyParams(args [1]string, r *http.Request) (params TeamsListMembersLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: role.
	{
		val := TeamsListMembersLegacyRole("all")

		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal TeamsListMembersLegacyRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = TeamsListMembersLegacyRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsInOrgParams(args [2]string, r *http.Request) (params TeamsListPendingInvitationsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListPendingInvitationsLegacyParams(args [1]string, r *http.Request) (params TeamsListPendingInvitationsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsInOrgParams(args [2]string, r *http.Request) (params TeamsListProjectsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListProjectsLegacyParams(args [1]string, r *http.Request) (params TeamsListProjectsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposInOrgParams(args [2]string, r *http.Request) (params TeamsListReposInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsListReposLegacyParams(args [1]string, r *http.Request) (params TeamsListReposLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeTeamsRemoveMemberLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsRemoveMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveProjectInOrgParams(args [3]string, r *http.Request) (params TeamsRemoveProjectInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveProjectLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveProjectLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoInOrgParams(args [4]string, r *http.Request) (params TeamsRemoveRepoInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsRemoveRepoLegacyParams(args [3]string, r *http.Request) (params TeamsRemoveRepoLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsUpdateDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsUpdateDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsUpdateDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsUpdateDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateInOrgParams(args [2]string, r *http.Request) (params TeamsUpdateInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

func decodeTeamsUpdateLegacyParams(args [1]string, r *http.Request) (params TeamsUpdateLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

func decodeUsersBlockParams(args [1]string, r *http.Request) (params UsersBlockParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersCheckBlockedParams(args [1]string, r *http.Request) (params UsersCheckBlockedParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersCheckFollowingForUserParams(args [2]string, r *http.Request) (params UsersCheckFollowingForUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: target_user.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "target_user",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TargetUser = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: target_user: not specified")
		}
	}
	return params, nil
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args [1]string, r *http.Request) (params UsersCheckPersonIsFollowedByAuthenticatedParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersDeleteGpgKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersDeleteGpgKeyForAuthenticatedParams, _ error) {
	// Decode path: gpg_key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gpg_key_id: not specified")
		}
	}
	return params, nil
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersDeletePublicSSHKeyForAuthenticatedParams, _ error) {
	// Decode path: key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

func decodeUsersFollowParams(args [1]string, r *http.Request) (params UsersFollowParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersGetByUsernameParams(args [1]string, r *http.Request) (params UsersGetByUsernameParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersGetContextForUserParams(args [1]string, r *http.Request) (params UsersGetContextForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: subject_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectTypeVal UsersGetContextForUserSubjectType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSubjectTypeVal = UsersGetContextForUserSubjectType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectType.SetTo(paramsDotSubjectTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: subject_type: parse")
			}
			if err := func() error {
				if params.SubjectType.Set {
					if err := func() error {
						if err := params.SubjectType.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: subject_type: invalid")
			}
		}
	}
	// Decode query: subject_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSubjectIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectID.SetTo(paramsDotSubjectIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: subject_id: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersGetGpgKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersGetGpgKeyForAuthenticatedParams, _ error) {
	// Decode path: gpg_key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: gpg_key_id: not specified")
		}
	}
	return params, nil
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersGetPublicSSHKeyForAuthenticatedParams, _ error) {
	// Decode path: key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

func decodeUsersListParams(args [0]string, r *http.Request) (params UsersListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListEmailsForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListEmailsForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowedByAuthenticatedParams(args [0]string, r *http.Request) (params UsersListFollowedByAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForAuthenticatedUserParams(args [0]string, r *http.Request) (params UsersListFollowersForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowersForUserParams(args [1]string, r *http.Request) (params UsersListFollowersForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListFollowingForUserParams(args [1]string, r *http.Request) (params UsersListFollowingForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListGpgKeysForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListGpgKeysForUserParams(args [1]string, r *http.Request) (params UsersListGpgKeysForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicEmailsForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListPublicEmailsForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicKeysForUserParams(args [1]string, r *http.Request) (params UsersListPublicKeysForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListPublicSSHKeysForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)

		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)

		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

func decodeUsersUnblockParams(args [1]string, r *http.Request) (params UsersUnblockParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

func decodeUsersUnfollowParams(args [1]string, r *http.Request) (params UsersUnfollowParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}
